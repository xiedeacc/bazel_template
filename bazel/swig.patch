diff --git a/Source/CParse/parser.c b/Source/CParse/parser.c
new file mode 100644
index 000000000..cf61d0bef
--- /dev/null
+++ b/Source/CParse/parser.c
@@ -0,0 +1,13107 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     END = 0,
+     ID = 258,
+     HBLOCK = 259,
+     POUND = 260,
+     STRING = 261,
+     WSTRING = 262,
+     INCLUDE = 263,
+     IMPORT = 264,
+     INSERT = 265,
+     CHARCONST = 266,
+     WCHARCONST = 267,
+     NUM_INT = 268,
+     NUM_FLOAT = 269,
+     NUM_UNSIGNED = 270,
+     NUM_LONG = 271,
+     NUM_ULONG = 272,
+     NUM_LONGLONG = 273,
+     NUM_ULONGLONG = 274,
+     NUM_BOOL = 275,
+     TYPEDEF = 276,
+     TYPE_INT = 277,
+     TYPE_UNSIGNED = 278,
+     TYPE_SHORT = 279,
+     TYPE_LONG = 280,
+     TYPE_FLOAT = 281,
+     TYPE_DOUBLE = 282,
+     TYPE_CHAR = 283,
+     TYPE_WCHAR = 284,
+     TYPE_VOID = 285,
+     TYPE_SIGNED = 286,
+     TYPE_BOOL = 287,
+     TYPE_COMPLEX = 288,
+     TYPE_TYPEDEF = 289,
+     TYPE_RAW = 290,
+     TYPE_NON_ISO_INT8 = 291,
+     TYPE_NON_ISO_INT16 = 292,
+     TYPE_NON_ISO_INT32 = 293,
+     TYPE_NON_ISO_INT64 = 294,
+     LPAREN = 295,
+     RPAREN = 296,
+     COMMA = 297,
+     SEMI = 298,
+     EXTERN = 299,
+     INIT = 300,
+     LBRACE = 301,
+     RBRACE = 302,
+     PERIOD = 303,
+     ELLIPSIS = 304,
+     CONST_QUAL = 305,
+     VOLATILE = 306,
+     REGISTER = 307,
+     STRUCT = 308,
+     UNION = 309,
+     EQUAL = 310,
+     SIZEOF = 311,
+     MODULE = 312,
+     LBRACKET = 313,
+     RBRACKET = 314,
+     BEGINFILE = 315,
+     ENDOFFILE = 316,
+     ILLEGAL = 317,
+     CONSTANT = 318,
+     NAME = 319,
+     RENAME = 320,
+     NAMEWARN = 321,
+     EXTEND = 322,
+     PRAGMA = 323,
+     FEATURE = 324,
+     VARARGS = 325,
+     ENUM = 326,
+     CLASS = 327,
+     TYPENAME = 328,
+     PRIVATE = 329,
+     PUBLIC = 330,
+     PROTECTED = 331,
+     COLON = 332,
+     STATIC = 333,
+     VIRTUAL = 334,
+     FRIEND = 335,
+     THROW = 336,
+     CATCH = 337,
+     EXPLICIT = 338,
+     STATIC_ASSERT = 339,
+     CONSTEXPR = 340,
+     THREAD_LOCAL = 341,
+     DECLTYPE = 342,
+     AUTO = 343,
+     NOEXCEPT = 344,
+     OVERRIDE = 345,
+     FINAL = 346,
+     USING = 347,
+     NAMESPACE = 348,
+     NATIVE = 349,
+     INLINE = 350,
+     TYPEMAP = 351,
+     EXCEPT = 352,
+     ECHO = 353,
+     APPLY = 354,
+     CLEAR = 355,
+     SWIGTEMPLATE = 356,
+     FRAGMENT = 357,
+     WARN = 358,
+     LESSTHAN = 359,
+     GREATERTHAN = 360,
+     DELETE_KW = 361,
+     DEFAULT = 362,
+     LESSTHANOREQUALTO = 363,
+     GREATERTHANOREQUALTO = 364,
+     EQUALTO = 365,
+     NOTEQUALTO = 366,
+     LESSEQUALGREATER = 367,
+     ARROW = 368,
+     QUESTIONMARK = 369,
+     TYPES = 370,
+     PARMS = 371,
+     NONID = 372,
+     DSTAR = 373,
+     DCNOT = 374,
+     TEMPLATE = 375,
+     OPERATOR = 376,
+     CONVERSIONOPERATOR = 377,
+     PARSETYPE = 378,
+     PARSEPARM = 379,
+     PARSEPARMS = 380,
+     DOXYGENSTRING = 381,
+     DOXYGENPOSTSTRING = 382,
+     CAST = 383,
+     LOR = 384,
+     LAND = 385,
+     OR = 386,
+     XOR = 387,
+     AND = 388,
+     RSHIFT = 389,
+     LSHIFT = 390,
+     MINUS = 391,
+     PLUS = 392,
+     MODULO = 393,
+     SLASH = 394,
+     STAR = 395,
+     LNOT = 396,
+     NOT = 397,
+     UMINUS = 398,
+     DCOLON = 399
+   };
+#endif
+/* Tokens.  */
+#define END 0
+#define ID 258
+#define HBLOCK 259
+#define POUND 260
+#define STRING 261
+#define WSTRING 262
+#define INCLUDE 263
+#define IMPORT 264
+#define INSERT 265
+#define CHARCONST 266
+#define WCHARCONST 267
+#define NUM_INT 268
+#define NUM_FLOAT 269
+#define NUM_UNSIGNED 270
+#define NUM_LONG 271
+#define NUM_ULONG 272
+#define NUM_LONGLONG 273
+#define NUM_ULONGLONG 274
+#define NUM_BOOL 275
+#define TYPEDEF 276
+#define TYPE_INT 277
+#define TYPE_UNSIGNED 278
+#define TYPE_SHORT 279
+#define TYPE_LONG 280
+#define TYPE_FLOAT 281
+#define TYPE_DOUBLE 282
+#define TYPE_CHAR 283
+#define TYPE_WCHAR 284
+#define TYPE_VOID 285
+#define TYPE_SIGNED 286
+#define TYPE_BOOL 287
+#define TYPE_COMPLEX 288
+#define TYPE_TYPEDEF 289
+#define TYPE_RAW 290
+#define TYPE_NON_ISO_INT8 291
+#define TYPE_NON_ISO_INT16 292
+#define TYPE_NON_ISO_INT32 293
+#define TYPE_NON_ISO_INT64 294
+#define LPAREN 295
+#define RPAREN 296
+#define COMMA 297
+#define SEMI 298
+#define EXTERN 299
+#define INIT 300
+#define LBRACE 301
+#define RBRACE 302
+#define PERIOD 303
+#define ELLIPSIS 304
+#define CONST_QUAL 305
+#define VOLATILE 306
+#define REGISTER 307
+#define STRUCT 308
+#define UNION 309
+#define EQUAL 310
+#define SIZEOF 311
+#define MODULE 312
+#define LBRACKET 313
+#define RBRACKET 314
+#define BEGINFILE 315
+#define ENDOFFILE 316
+#define ILLEGAL 317
+#define CONSTANT 318
+#define NAME 319
+#define RENAME 320
+#define NAMEWARN 321
+#define EXTEND 322
+#define PRAGMA 323
+#define FEATURE 324
+#define VARARGS 325
+#define ENUM 326
+#define CLASS 327
+#define TYPENAME 328
+#define PRIVATE 329
+#define PUBLIC 330
+#define PROTECTED 331
+#define COLON 332
+#define STATIC 333
+#define VIRTUAL 334
+#define FRIEND 335
+#define THROW 336
+#define CATCH 337
+#define EXPLICIT 338
+#define STATIC_ASSERT 339
+#define CONSTEXPR 340
+#define THREAD_LOCAL 341
+#define DECLTYPE 342
+#define AUTO 343
+#define NOEXCEPT 344
+#define OVERRIDE 345
+#define FINAL 346
+#define USING 347
+#define NAMESPACE 348
+#define NATIVE 349
+#define INLINE 350
+#define TYPEMAP 351
+#define EXCEPT 352
+#define ECHO 353
+#define APPLY 354
+#define CLEAR 355
+#define SWIGTEMPLATE 356
+#define FRAGMENT 357
+#define WARN 358
+#define LESSTHAN 359
+#define GREATERTHAN 360
+#define DELETE_KW 361
+#define DEFAULT 362
+#define LESSTHANOREQUALTO 363
+#define GREATERTHANOREQUALTO 364
+#define EQUALTO 365
+#define NOTEQUALTO 366
+#define LESSEQUALGREATER 367
+#define ARROW 368
+#define QUESTIONMARK 369
+#define TYPES 370
+#define PARMS 371
+#define NONID 372
+#define DSTAR 373
+#define DCNOT 374
+#define TEMPLATE 375
+#define OPERATOR 376
+#define CONVERSIONOPERATOR 377
+#define PARSETYPE 378
+#define PARSEPARM 379
+#define PARSEPARMS 380
+#define DOXYGENSTRING 381
+#define DOXYGENPOSTSTRING 382
+#define CAST 383
+#define LOR 384
+#define LAND 385
+#define OR 386
+#define XOR 387
+#define AND 388
+#define RSHIFT 389
+#define LSHIFT 390
+#define MINUS 391
+#define PLUS 392
+#define MODULO 393
+#define SLASH 394
+#define STAR 395
+#define LNOT 396
+#define NOT 397
+#define UMINUS 398
+#define DCOLON 399
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 25 "parser.y"
+
+#define yylex yylex
+
+/* doh.h uses #pragma GCC poison with GCC to prevent direct calls to certain
+ * standard C library functions being introduced, but those cause errors due
+ * to checks like `#if defined YYMALLOC || defined malloc` in the bison
+ * template code.  We can't easily arrange to include headers after that
+ * template code, so instead we disable the problematic poisoning for this
+ * file.
+ */
+#define DOH_NO_POISON_MALLOC_FREE
+
+#include "swig.h"
+#include "cparse.h"
+#include "preprocessor.h"
+#include <ctype.h>
+
+/* We do this for portability */
+#undef alloca
+#define alloca Malloc
+
+#define YYMALLOC Malloc
+#define YYFREE Free
+
+/* -----------------------------------------------------------------------------
+ *                               Externals
+ * ----------------------------------------------------------------------------- */
+
+int  yyparse(void);
+
+/* NEW Variables */
+
+static Node    *top = 0;      /* Top of the generated parse tree */
+static int      unnamed = 0;  /* Unnamed datatype counter */
+static Hash    *classes = 0;        /* Hash table of classes */
+static Hash    *classes_typedefs = 0; /* Hash table of typedef classes: typedef struct X {...} Y; */
+static Symtab  *prev_symtab = 0;
+static Node    *current_class = 0;
+String  *ModuleName = 0;
+static Node    *module_node = 0;
+static String  *Classprefix = 0;  
+static String  *Namespaceprefix = 0;
+static int      inclass = 0;
+static Node    *currentOuterClass = 0; /* for nested classes */
+static const char *last_cpptype = 0;
+static int      inherit_list = 0;
+static Parm    *template_parameters = 0;
+static int      parsing_template_declaration = 0;
+static int      extendmode   = 0;
+static int      compact_default_args = 0;
+static int      template_reduce = 0;
+static int      cparse_externc = 0;
+int		ignore_nested_classes = 0;
+int		kwargs_supported = 0;
+/* -----------------------------------------------------------------------------
+ *                            Doxygen Comment Globals
+ * ----------------------------------------------------------------------------- */
+static String *currentDeclComment = NULL; /* Comment of C/C++ declaration. */
+static Node *previousNode = NULL; /* Pointer to the previous node (for post comments) */
+static Node *currentNode = NULL; /* Pointer to the current node (for post comments) */
+
+/* -----------------------------------------------------------------------------
+ *                            Assist Functions
+ * ----------------------------------------------------------------------------- */
+
+
+ 
+/* Called by the parser (yyparse) when an error is found.*/
+static void yyerror (const char *e) {
+  (void)e;
+}
+
+static Node *new_node(const_String_or_char_ptr tag) {
+  Node *n = Swig_cparse_new_node(tag);
+  /* Remember the previous node in case it will need a post-comment */
+  previousNode = currentNode;
+  currentNode = n;
+  return n;
+}
+
+/* Copies a node.  Does not copy tree links or symbol table data (except for
+   sym:name) */
+
+static Node *copy_node(Node *n) {
+  Node *nn;
+  Iterator k;
+  nn = NewHash();
+  Setfile(nn,Getfile(n));
+  Setline(nn,Getline(n));
+  for (k = First(n); k.key; k = Next(k)) {
+    String *ci;
+    String *key = k.key;
+    char *ckey = Char(key);
+    if ((strcmp(ckey,"nextSibling") == 0) ||
+	(strcmp(ckey,"previousSibling") == 0) ||
+	(strcmp(ckey,"parentNode") == 0) ||
+	(strcmp(ckey,"lastChild") == 0)) {
+      continue;
+    }
+    if (Strncmp(key,"csym:",5) == 0) continue;
+    /* We do copy sym:name.  For templates */
+    if ((strcmp(ckey,"sym:name") == 0) || 
+	(strcmp(ckey,"sym:weak") == 0) ||
+	(strcmp(ckey,"sym:typename") == 0)) {
+      String *ci = Copy(k.item);
+      Setattr(nn,key, ci);
+      Delete(ci);
+      continue;
+    }
+    if (strcmp(ckey,"sym:symtab") == 0) {
+      Setattr(nn,"sym:needs_symtab", "1");
+    }
+    /* We don't copy any other symbol table attributes */
+    if (strncmp(ckey,"sym:",4) == 0) {
+      continue;
+    }
+    /* If children.  We copy them recursively using this function */
+    if (strcmp(ckey,"firstChild") == 0) {
+      /* Copy children */
+      Node *cn = k.item;
+      while (cn) {
+	Node *copy = copy_node(cn);
+	appendChild(nn,copy);
+	Delete(copy);
+	cn = nextSibling(cn);
+      }
+      continue;
+    }
+    /* We don't copy the symbol table.  But we drop an attribute 
+       requires_symtab so that functions know it needs to be built */
+
+    if (strcmp(ckey,"symtab") == 0) {
+      /* Node defined a symbol table. */
+      Setattr(nn,"requires_symtab","1");
+      continue;
+    }
+    /* Can't copy nodes */
+    if (strcmp(ckey,"node") == 0) {
+      continue;
+    }
+    if ((strcmp(ckey,"parms") == 0) || (strcmp(ckey,"pattern") == 0) || (strcmp(ckey,"throws") == 0)
+	|| (strcmp(ckey,"kwargs") == 0)) {
+      ParmList *pl = CopyParmList(k.item);
+      Setattr(nn,key,pl);
+      Delete(pl);
+      continue;
+    }
+    if (strcmp(ckey,"nested:outer") == 0) { /* don't copy outer classes links, they will be updated later */
+      Setattr(nn, key, k.item);
+      continue;
+    }
+    /* defaultargs will be patched back in later in update_defaultargs() */
+    if (strcmp(ckey,"defaultargs") == 0) {
+      Setattr(nn, "needs_defaultargs", "1");
+      continue;
+    }
+    /* same for abstracts, which contains pointers to the source node children, and so will need to be patch too */
+    if (strcmp(ckey,"abstracts") == 0) {
+      SetFlag(nn, "needs_abstracts");
+      continue;
+    }
+    /* Looks okay.  Just copy the data using Copy */
+    ci = Copy(k.item);
+    Setattr(nn, key, ci);
+    Delete(ci);
+  }
+  return nn;
+}
+
+static void set_comment(Node *n, String *comment) {
+  String *name;
+  Parm *p;
+  if (!n || !comment)
+    return;
+
+  if (Getattr(n, "doxygen"))
+    Append(Getattr(n, "doxygen"), comment);
+  else {
+    Setattr(n, "doxygen", comment);
+    /* This is the first comment, populate it with @params, if any */
+    p = Getattr(n, "parms");
+    while (p) {
+      if (Getattr(p, "doxygen"))
+	Printv(comment, "\n@param ", Getattr(p, "name"), Getattr(p, "doxygen"), NIL);
+      p=nextSibling(p);
+    }
+  }
+  
+  /* Append same comment to every generated overload */
+  name = Getattr(n, "name");
+  if (!name)
+    return;
+  n = nextSibling(n);
+  while (n && Getattr(n, "name") && Strcmp(Getattr(n, "name"), name) == 0) {
+    Setattr(n, "doxygen", comment);
+    n = nextSibling(n);
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ *                              Variables
+ * ----------------------------------------------------------------------------- */
+
+static char  *typemap_lang = 0;    /* Current language setting */
+
+static int cplus_mode  = 0;
+
+/* C++ modes */
+
+#define  CPLUS_PUBLIC    1
+#define  CPLUS_PRIVATE   2
+#define  CPLUS_PROTECTED 3
+
+/* include types */
+static int   import_mode = 0;
+
+void SWIG_typemap_lang(const char *tm_lang) {
+  typemap_lang = Swig_copy_string(tm_lang);
+}
+
+void SWIG_cparse_set_compact_default_args(int defargs) {
+  compact_default_args = defargs;
+}
+
+int SWIG_cparse_template_reduce(int treduce) {
+  template_reduce = treduce;
+  return treduce;  
+}
+
+/* -----------------------------------------------------------------------------
+ *                           Assist functions
+ * ----------------------------------------------------------------------------- */
+
+static int promote_type(int t) {
+  if (t <= T_UCHAR || t == T_CHAR || t == T_WCHAR) return T_INT;
+  return t;
+}
+
+/* Perform type-promotion for binary operators */
+static int promote(int t1, int t2) {
+  t1 = promote_type(t1);
+  t2 = promote_type(t2);
+  return t1 > t2 ? t1 : t2;
+}
+
+static String *yyrename = 0;
+
+/* Forward renaming operator */
+
+static String *resolve_create_node_scope(String *cname, int is_class_definition);
+
+
+Hash *Swig_cparse_features(void) {
+  static Hash   *features_hash = 0;
+  if (!features_hash) features_hash = NewHash();
+  return features_hash;
+}
+
+/* Fully qualify any template parameters */
+static String *feature_identifier_fix(String *s) {
+  String *tp = SwigType_istemplate_templateprefix(s);
+  if (tp) {
+    String *ts, *ta, *tq;
+    ts = SwigType_templatesuffix(s);
+    ta = SwigType_templateargs(s);
+    tq = Swig_symbol_type_qualify(ta,0);
+    Append(tp,tq);
+    Append(tp,ts);
+    Delete(ts);
+    Delete(ta);
+    Delete(tq);
+    return tp;
+  } else {
+    return NewString(s);
+  }
+}
+
+static void set_access_mode(Node *n) {
+  if (cplus_mode == CPLUS_PUBLIC)
+    Setattr(n, "access", "public");
+  else if (cplus_mode == CPLUS_PROTECTED)
+    Setattr(n, "access", "protected");
+  else
+    Setattr(n, "access", "private");
+}
+
+static void restore_access_mode(Node *n) {
+  String *mode = Getattr(n, "access");
+  if (Strcmp(mode, "private") == 0)
+    cplus_mode = CPLUS_PRIVATE;
+  else if (Strcmp(mode, "protected") == 0)
+    cplus_mode = CPLUS_PROTECTED;
+  else
+    cplus_mode = CPLUS_PUBLIC;
+}
+
+/* Generate the symbol table name for an object */
+/* This is a bit of a mess. Need to clean up */
+static String *add_oldname = 0;
+
+
+
+static String *make_name(Node *n, String *name,SwigType *decl) {
+  String *made_name = 0;
+  int destructor = name && (*(Char(name)) == '~');
+
+  if (yyrename) {
+    String *s = NewString(yyrename);
+    Delete(yyrename);
+    yyrename = 0;
+    if (destructor  && (*(Char(s)) != '~')) {
+      Insert(s,0,"~");
+    }
+    return s;
+  }
+
+  if (!name) return 0;
+
+  if (parsing_template_declaration)
+    SetFlag(n, "parsing_template_declaration");
+  made_name = Swig_name_make(n, Namespaceprefix, name, decl, add_oldname);
+  Delattr(n, "parsing_template_declaration");
+
+  return made_name;
+}
+
+/* Generate an unnamed identifier */
+static String *make_unnamed(void) {
+  unnamed++;
+  return NewStringf("$unnamed%d$",unnamed);
+}
+
+/* Return if the node is a friend declaration */
+static int is_friend(Node *n) {
+  return Cmp(Getattr(n,"storage"),"friend") == 0;
+}
+
+static int is_operator(String *name) {
+  return Strncmp(name,"operator ", 9) == 0;
+}
+
+
+/* Add declaration list to symbol table */
+static int  add_only_one = 0;
+
+static void add_symbols(Node *n) {
+  String *decl;
+  String *wrn = 0;
+
+  if (inclass && n) {
+    cparse_normalize_void(n);
+  }
+  while (n) {
+    String *symname = 0;
+    /* for friends, we need to pop the scope once */
+    String *old_prefix = 0;
+    Symtab *old_scope = 0;
+    int isfriend = inclass && is_friend(n);
+    int iscdecl = Cmp(nodeType(n),"cdecl") == 0;
+    int only_csymbol = 0;
+    
+    if (inclass) {
+      String *name = Getattr(n, "name");
+      if (isfriend) {
+	/* for friends, we need to add the scopename if needed */
+	String *prefix = name ? Swig_scopename_prefix(name) : 0;
+	old_prefix = Namespaceprefix;
+	old_scope = Swig_symbol_popscope();
+	Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+	if (!prefix) {
+	  if (name && !is_operator(name) && Namespaceprefix) {
+	    String *nname = NewStringf("%s::%s", Namespaceprefix, name);
+	    Setattr(n,"name",nname);
+	    Delete(nname);
+	  }
+	} else {
+	  Symtab *st = Swig_symbol_getscope(prefix);
+	  String *ns = st ? Getattr(st,"name") : prefix;
+	  String *base  = Swig_scopename_last(name);
+	  String *nname = NewStringf("%s::%s", ns, base);
+	  Setattr(n,"name",nname);
+	  Delete(nname);
+	  Delete(base);
+	  Delete(prefix);
+	}
+	Namespaceprefix = 0;
+      } else {
+	/* for member functions, we need to remove the redundant
+	   class scope if provided, as in
+	   
+	   struct Foo {
+	   int Foo::method(int a);
+	   };
+	   
+	*/
+	String *prefix = name ? Swig_scopename_prefix(name) : 0;
+	if (prefix) {
+	  if (Classprefix && (Equal(prefix,Classprefix))) {
+	    String *base = Swig_scopename_last(name);
+	    Setattr(n,"name",base);
+	    Delete(base);
+	  }
+	  Delete(prefix);
+	}
+      }
+    }
+
+    if (!isfriend && (inclass || extendmode)) {
+      Setattr(n,"ismember","1");
+    }
+
+    if (extendmode) {
+      if (!Getattr(n, "template"))
+        SetFlag(n,"isextendmember");
+    }
+
+    if (!isfriend && inclass) {
+      if ((cplus_mode != CPLUS_PUBLIC)) {
+	only_csymbol = 1;
+	if (cplus_mode == CPLUS_PROTECTED) {
+	  Setattr(n,"access", "protected");
+	  only_csymbol = !Swig_need_protected(n);
+	} else {
+	  Setattr(n,"access", "private");
+	  /* private are needed only when they are pure virtuals - why? */
+	  if ((Cmp(Getattr(n,"storage"),"virtual") == 0) && (Cmp(Getattr(n,"value"),"0") == 0)) {
+	    only_csymbol = 0;
+	  }
+	  if (Cmp(nodeType(n),"destructor") == 0) {
+	    /* Needed for "unref" feature */
+	    only_csymbol = 0;
+	  }
+	}
+      } else {
+	  Setattr(n,"access", "public");
+      }
+    }
+    if (Getattr(n,"sym:name")) {
+      n = nextSibling(n);
+      continue;
+    }
+    decl = Getattr(n,"decl");
+    if (!SwigType_isfunction(decl)) {
+      String *name = Getattr(n,"name");
+      String *makename = Getattr(n,"parser:makename");
+      if (iscdecl) {	
+	String *storage = Getattr(n, "storage");
+	if (Cmp(storage,"typedef") == 0) {
+	  Setattr(n,"kind","typedef");
+	} else {
+	  SwigType *type = Getattr(n,"type");
+	  String *value = Getattr(n,"value");
+	  Setattr(n,"kind","variable");
+	  if (value && Len(value)) {
+	    Setattr(n,"hasvalue","1");
+	  }
+	  if (type) {
+	    SwigType *ty;
+	    SwigType *tmp = 0;
+	    if (decl) {
+	      ty = tmp = Copy(type);
+	      SwigType_push(ty,decl);
+	    } else {
+	      ty = type;
+	    }
+	    if (!SwigType_ismutable(ty) || (storage && Strstr(storage, "constexpr"))) {
+	      SetFlag(n,"hasconsttype");
+	      SetFlag(n,"feature:immutable");
+	    }
+	    if (tmp) Delete(tmp);
+	  }
+	  if (!type) {
+	    Printf(stderr,"notype name %s\n", name);
+	  }
+	}
+      }
+      Swig_features_get(Swig_cparse_features(), Namespaceprefix, name, 0, n);
+      if (makename) {
+	symname = make_name(n, makename,0);
+        Delattr(n,"parser:makename"); /* temporary information, don't leave it hanging around */
+      } else {
+        makename = name;
+	symname = make_name(n, makename,0);
+      }
+      
+      if (!symname) {
+	symname = Copy(Getattr(n,"unnamed"));
+      }
+      if (symname) {
+	if (parsing_template_declaration)
+	  SetFlag(n, "parsing_template_declaration");
+	wrn = Swig_name_warning(n, Namespaceprefix, symname,0);
+	Delattr(n, "parsing_template_declaration");
+      }
+    } else {
+      String *name = Getattr(n,"name");
+      SwigType *fdecl = Copy(decl);
+      SwigType *fun = SwigType_pop_function(fdecl);
+      if (iscdecl) {	
+	Setattr(n,"kind","function");
+      }
+      
+      Swig_features_get(Swig_cparse_features(),Namespaceprefix,name,fun,n);
+
+      symname = make_name(n, name,fun);
+      if (parsing_template_declaration)
+	SetFlag(n, "parsing_template_declaration");
+      wrn = Swig_name_warning(n, Namespaceprefix,symname,fun);
+      Delattr(n, "parsing_template_declaration");
+      
+      Delete(fdecl);
+      Delete(fun);
+      
+    }
+    if (!symname) {
+      n = nextSibling(n);
+      continue;
+    }
+    if (cparse_cplusplus) {
+      String *value = Getattr(n, "value");
+      if (value && Strcmp(value, "delete") == 0) {
+	/* C++11 deleted definition / deleted function */
+        SetFlag(n,"deleted");
+        SetFlag(n,"feature:ignore");
+      }
+      if (SwigType_isrvalue_reference(Getattr(n, "refqualifier"))) {
+	/* Ignore rvalue ref-qualifiers by default
+	 * Use Getattr instead of GetFlag to handle explicit ignore and explicit not ignore */
+	if (!(Getattr(n, "feature:ignore") || Strncmp(symname, "$ignore", 7) == 0)) {
+	  SWIG_WARN_NODE_BEGIN(n);
+	  Swig_warning(WARN_TYPE_RVALUE_REF_QUALIFIER_IGNORED, Getfile(n), Getline(n),
+	      "Method with rvalue ref-qualifier %s ignored.\n", Swig_name_decl(n));
+	  SWIG_WARN_NODE_END(n);
+	  SetFlag(n, "feature:ignore");
+	}
+      }
+    }
+    if (only_csymbol || GetFlag(n, "feature:ignore") || Strncmp(symname, "$ignore", 7) == 0) {
+      /* Only add to C symbol table and continue */
+      Swig_symbol_add(0, n);
+      if (!only_csymbol && !GetFlag(n, "feature:ignore")) {
+	/* Print the warning attached to $ignore name, if any */
+        char *c = Char(symname) + 7;
+	if (strlen(c)) {
+	  SWIG_WARN_NODE_BEGIN(n);
+	  Swig_warning(0,Getfile(n), Getline(n), "%s\n",c+1);
+	  SWIG_WARN_NODE_END(n);
+	}
+	/* If the symbol was ignored via "rename" and is visible, set also feature:ignore*/
+	SetFlag(n, "feature:ignore");
+      }
+      if (!GetFlag(n, "feature:ignore") && Strcmp(symname,"$ignore") == 0) {
+	/* Add feature:ignore if the symbol was explicitly ignored, regardless of visibility */
+	SetFlag(n, "feature:ignore");
+      }
+    } else {
+      Node *c;
+      if ((wrn) && (Len(wrn))) {
+	String *metaname = symname;
+	if (!Getmeta(metaname,"already_warned")) {
+	  SWIG_WARN_NODE_BEGIN(n);
+	  Swig_warning(0,Getfile(n),Getline(n), "%s\n", wrn);
+	  SWIG_WARN_NODE_END(n);
+	  Setmeta(metaname,"already_warned","1");
+	}
+      }
+      c = Swig_symbol_add(symname,n);
+
+      if (c != n) {
+        /* symbol conflict attempting to add in the new symbol */
+        if (Getattr(n,"sym:weak")) {
+          Setattr(n,"sym:name",symname);
+        } else {
+          String *e = NewStringEmpty();
+          String *en = NewStringEmpty();
+          String *ec = NewStringEmpty();
+          int redefined = Swig_need_redefined_warn(n,c,inclass);
+          if (redefined) {
+            Printf(en,"Identifier '%s' redefined (ignored)",symname);
+            Printf(ec,"previous definition of '%s'",symname);
+          } else {
+            Printf(en,"Redundant redeclaration of '%s'",symname);
+            Printf(ec,"previous declaration of '%s'",symname);
+          }
+          if (Cmp(symname,Getattr(n,"name"))) {
+            Printf(en," (Renamed from '%s')", SwigType_namestr(Getattr(n,"name")));
+          }
+          Printf(en,",");
+          if (Cmp(symname,Getattr(c,"name"))) {
+            Printf(ec," (Renamed from '%s')", SwigType_namestr(Getattr(c,"name")));
+          }
+          Printf(ec,".");
+	  SWIG_WARN_NODE_BEGIN(n);
+          if (redefined) {
+            Swig_warning(WARN_PARSE_REDEFINED,Getfile(n),Getline(n),"%s\n",en);
+            Swig_warning(WARN_PARSE_REDEFINED,Getfile(c),Getline(c),"%s\n",ec);
+          } else if (!is_friend(n) && !is_friend(c)) {
+            Swig_warning(WARN_PARSE_REDUNDANT,Getfile(n),Getline(n),"%s\n",en);
+            Swig_warning(WARN_PARSE_REDUNDANT,Getfile(c),Getline(c),"%s\n",ec);
+          }
+	  SWIG_WARN_NODE_END(n);
+          Printf(e,"%s:%d:%s\n%s:%d:%s\n",Getfile(n),Getline(n),en,
+                 Getfile(c),Getline(c),ec);
+          Setattr(n,"error",e);
+	  Delete(e);
+          Delete(en);
+          Delete(ec);
+        }
+      }
+    }
+    /* restore the class scope if needed */
+    if (isfriend) {
+      Swig_symbol_setscope(old_scope);
+      if (old_prefix) {
+	Delete(Namespaceprefix);
+	Namespaceprefix = old_prefix;
+      }
+    }
+    Delete(symname);
+
+    if (add_only_one) return;
+    n = nextSibling(n);
+  }
+}
+
+
+/* add symbols a parse tree node copy */
+
+static void add_symbols_copy(Node *n) {
+  String *name;
+  int    emode = 0;
+  while (n) {
+    char *cnodeType = Char(nodeType(n));
+
+    if (strcmp(cnodeType,"access") == 0) {
+      String *kind = Getattr(n,"kind");
+      if (Strcmp(kind,"public") == 0) {
+	cplus_mode = CPLUS_PUBLIC;
+      } else if (Strcmp(kind,"private") == 0) {
+	cplus_mode = CPLUS_PRIVATE;
+      } else if (Strcmp(kind,"protected") == 0) {
+	cplus_mode = CPLUS_PROTECTED;
+      }
+      n = nextSibling(n);
+      continue;
+    }
+
+    add_oldname = Getattr(n,"sym:name");
+    if ((add_oldname) || (Getattr(n,"sym:needs_symtab"))) {
+      int old_inclass = -1;
+      Node *old_current_class = 0;
+      if (add_oldname) {
+	DohIncref(add_oldname);
+	/*  Disable this, it prevents %rename to work with templates */
+	/* If already renamed, we used that name  */
+	/*
+	if (Strcmp(add_oldname, Getattr(n,"name")) != 0) {
+	  Delete(yyrename);
+	  yyrename = Copy(add_oldname);
+	}
+	*/
+      }
+      Delattr(n,"sym:needs_symtab");
+      Delattr(n,"sym:name");
+
+      add_only_one = 1;
+      add_symbols(n);
+
+      if (Getattr(n,"partialargs")) {
+	Swig_symbol_cadd(Getattr(n,"partialargs"),n);
+      }
+      add_only_one = 0;
+      name = Getattr(n,"name");
+      if (Getattr(n,"requires_symtab")) {
+	Swig_symbol_newscope();
+	Swig_symbol_setscopename(name);
+	Delete(Namespaceprefix);
+	Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+      }
+      if (strcmp(cnodeType,"class") == 0) {
+	old_inclass = inclass;
+	inclass = 1;
+	old_current_class = current_class;
+	current_class = n;
+	if (Strcmp(Getattr(n,"kind"),"class") == 0) {
+	  cplus_mode = CPLUS_PRIVATE;
+	} else {
+	  cplus_mode = CPLUS_PUBLIC;
+	}
+      }
+      if (strcmp(cnodeType,"extend") == 0) {
+	emode = cplus_mode;
+	cplus_mode = CPLUS_PUBLIC;
+      }
+      add_symbols_copy(firstChild(n));
+      if (strcmp(cnodeType,"extend") == 0) {
+	cplus_mode = emode;
+      }
+      if (Getattr(n,"requires_symtab")) {
+	Setattr(n,"symtab", Swig_symbol_popscope());
+	Delattr(n,"requires_symtab");
+	Delete(Namespaceprefix);
+	Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+      }
+      if (add_oldname) {
+	Delete(add_oldname);
+	add_oldname = 0;
+      }
+      if (strcmp(cnodeType,"class") == 0) {
+	inclass = old_inclass;
+	current_class = old_current_class;
+      }
+    } else {
+      if (strcmp(cnodeType,"extend") == 0) {
+	emode = cplus_mode;
+	cplus_mode = CPLUS_PUBLIC;
+      }
+      add_symbols_copy(firstChild(n));
+      if (strcmp(cnodeType,"extend") == 0) {
+	cplus_mode = emode;
+      }
+    }
+    n = nextSibling(n);
+  }
+}
+
+/* Add in the "defaultargs" attribute for functions in instantiated templates.
+ * n should be any instantiated template (class or start of linked list of functions). */
+static void update_defaultargs(Node *n) {
+  if (n) {
+    Node *firstdefaultargs = n;
+    update_defaultargs(firstChild(n));
+    n = nextSibling(n);
+    /* recursively loop through nodes of all types, but all we really need are the overloaded functions */
+    while (n) {
+      update_defaultargs(firstChild(n));
+      if (!Getattr(n, "defaultargs")) {
+	if (Getattr(n, "needs_defaultargs")) {
+	  Setattr(n, "defaultargs", firstdefaultargs);
+	  Delattr(n, "needs_defaultargs");
+	} else {
+	  firstdefaultargs = n;
+	}
+      } else {
+	/* Functions added in with %extend (for specialized template classes) will already have default args patched up */
+	assert(Getattr(n, "defaultargs") == firstdefaultargs);
+      }
+      n = nextSibling(n);
+    }
+  }
+}
+
+/* Check a set of declarations to see if any are pure-abstract */
+
+static List *pure_abstracts(Node *n) {
+  List *abstracts = 0;
+  while (n) {
+    if (Cmp(nodeType(n),"cdecl") == 0) {
+      String *decl = Getattr(n,"decl");
+      if (SwigType_isfunction(decl)) {
+	String *init = Getattr(n,"value");
+	if (Cmp(init,"0") == 0) {
+	  if (!abstracts) {
+	    abstracts = NewList();
+	  }
+	  Append(abstracts,n);
+	  SetFlag(n,"abstract");
+	}
+      }
+    } else if (Cmp(nodeType(n),"destructor") == 0) {
+      if (Cmp(Getattr(n,"value"),"0") == 0) {
+	if (!abstracts) {
+	  abstracts = NewList();
+	}
+	Append(abstracts,n);
+	SetFlag(n,"abstract");
+      }
+    }
+    n = nextSibling(n);
+  }
+  return abstracts;
+}
+
+/* Recompute the "abstracts" attribute for the classes in instantiated templates, similarly to update_defaultargs() above. */
+static void update_abstracts(Node *n) {
+  for (; n; n = nextSibling(n)) {
+    Node* const child = firstChild(n);
+    if (!child)
+      continue;
+
+    update_abstracts(child);
+
+    if (Getattr(n, "needs_abstracts")) {
+      Setattr(n, "abstracts", pure_abstracts(child));
+      Delattr(n, "needs_abstracts");
+    }
+  }
+}
+
+/* Make a classname */
+
+static String *make_class_name(String *name) {
+  String *nname = 0;
+  String *prefix;
+  if (Namespaceprefix) {
+    nname= NewStringf("%s::%s", Namespaceprefix, name);
+  } else {
+    nname = NewString(name);
+  }
+  prefix = SwigType_istemplate_templateprefix(nname);
+  if (prefix) {
+    String *args, *qargs;
+    args   = SwigType_templateargs(nname);
+    qargs  = Swig_symbol_type_qualify(args,0);
+    Append(prefix,qargs);
+    Delete(nname);
+    Delete(args);
+    Delete(qargs);
+    nname = prefix;
+  }
+  return nname;
+}
+
+/* Use typedef name as class name */
+
+static void add_typedef_name(Node *n, Node *declnode, String *oldName, Symtab *cscope, String *scpname) {
+  String *class_rename = 0;
+  SwigType *decl = Getattr(declnode, "decl");
+  if (!decl || !Len(decl)) {
+    String *cname;
+    String *tdscopename;
+    String *class_scope = Swig_symbol_qualifiedscopename(cscope);
+    String *name = Getattr(declnode, "name");
+    cname = Copy(name);
+    Setattr(n, "tdname", cname);
+    tdscopename = class_scope ? NewStringf("%s::%s", class_scope, name) : Copy(name);
+    class_rename = Getattr(n, "class_rename");
+    if (class_rename && (Strcmp(class_rename, oldName) == 0))
+      Setattr(n, "class_rename", NewString(name));
+    if (!classes_typedefs) classes_typedefs = NewHash();
+    if (!Equal(scpname, tdscopename) && !Getattr(classes_typedefs, tdscopename)) {
+      Setattr(classes_typedefs, tdscopename, n);
+    }
+    Setattr(n, "decl", decl);
+    Delete(class_scope);
+    Delete(cname);
+    Delete(tdscopename);
+  }
+}
+
+/* If the class name is qualified.  We need to create or lookup namespace entries */
+
+static Symtab *set_scope_to_global(void) {
+  Symtab *symtab = Swig_symbol_global_scope();
+  Swig_symbol_setscope(symtab);
+  return symtab;
+}
+ 
+/* Remove the block braces, { and }, if the 'noblock' attribute is set.
+ * Node *kw can be either a Hash or Parmlist. */
+static String *remove_block(Node *kw, const String *inputcode) {
+  String *modified_code = 0;
+  while (kw) {
+   String *name = Getattr(kw,"name");
+   if (name && (Cmp(name,"noblock") == 0)) {
+     char *cstr = Char(inputcode);
+     int len = Len(inputcode);
+     if (len && cstr[0] == '{') {
+       --len; ++cstr; 
+       if (len && cstr[len - 1] == '}') { --len; }
+       /* we now remove the extra spaces */
+       while (len && isspace((int)cstr[0])) { --len; ++cstr; }
+       while (len && isspace((int)cstr[len - 1])) { --len; }
+       modified_code = NewStringWithSize(cstr, len);
+       break;
+     }
+   }
+   kw = nextSibling(kw);
+  }
+  return modified_code;
+}
+
+/*
+#define RESOLVE_DEBUG 1
+*/
+static Node *nscope = 0;
+static Node *nscope_inner = 0;
+
+/* Remove the scope prefix from cname and return the base name without the prefix.
+ * The scopes required for the symbol name are resolved and/or created, if required.
+ * For example AA::BB::CC as input returns CC and creates the namespace AA then inner 
+ * namespace BB in the current scope. */
+static String *resolve_create_node_scope(String *cname, int is_class_definition) {
+  Symtab *gscope = 0;
+  Node *cname_node = 0;
+  String *last = Swig_scopename_last(cname);
+  nscope = 0;
+  nscope_inner = 0;  
+
+  if (Strncmp(cname,"::" ,2) != 0) {
+    if (is_class_definition) {
+      /* Only lookup symbols which are in scope via a using declaration but not via a using directive.
+         For example find y via 'using x::y' but not y via a 'using namespace x'. */
+      cname_node = Swig_symbol_clookup_no_inherit(cname, 0);
+      if (!cname_node) {
+	Node *full_lookup_node = Swig_symbol_clookup(cname, 0);
+	if (full_lookup_node) {
+	 /* This finds a symbol brought into scope via both a using directive and a using declaration. */
+	  Node *last_node = Swig_symbol_clookup_no_inherit(last, 0);
+	  if (last_node == full_lookup_node)
+	    cname_node = last_node;
+	}
+      }
+    } else {
+      /* For %template, the template needs to be in scope via any means. */
+      cname_node = Swig_symbol_clookup(cname, 0);
+    }
+  }
+#if RESOLVE_DEBUG
+  if (!cname_node)
+    Printf(stdout, "symbol does not yet exist (%d): [%s]\n", is_class_definition, cname);
+  else
+    Printf(stdout, "symbol does exist (%d): [%s]\n", is_class_definition, cname);
+#endif
+
+  if (cname_node) {
+    /* The symbol has been defined already or is in another scope.
+       If it is a weak symbol, it needs replacing and if it was brought into the current scope,
+       the scope needs adjusting appropriately for the new symbol.
+       Similarly for defined templates. */
+    Symtab *symtab = Getattr(cname_node, "sym:symtab");
+    Node *sym_weak = Getattr(cname_node, "sym:weak");
+    if ((symtab && sym_weak) || Equal(nodeType(cname_node), "template")) {
+      /* Check if the scope is the current scope */
+      String *current_scopename = Swig_symbol_qualifiedscopename(0);
+      String *found_scopename = Swig_symbol_qualifiedscopename(symtab);
+      if (!current_scopename)
+	current_scopename = NewString("");
+      if (!found_scopename)
+	found_scopename = NewString("");
+
+      {
+	int fail = 1;
+	List *current_scopes = Swig_scopename_tolist(current_scopename);
+	List *found_scopes = Swig_scopename_tolist(found_scopename);
+        Iterator cit = First(current_scopes);
+	Iterator fit = First(found_scopes);
+#if RESOLVE_DEBUG
+Printf(stdout, "comparing current: [%s] found: [%s]\n", current_scopename, found_scopename);
+#endif
+	for (; fit.item && cit.item; fit = Next(fit), cit = Next(cit)) {
+	  String *current = cit.item;
+	  String *found = fit.item;
+#if RESOLVE_DEBUG
+	  Printf(stdout, "  looping %s %s\n", current, found);
+#endif
+	  if (Strcmp(current, found) != 0)
+	    break;
+	}
+
+	if (!cit.item) {
+	  String *subscope = NewString("");
+	  for (; fit.item; fit = Next(fit)) {
+	    if (Len(subscope) > 0)
+	      Append(subscope, "::");
+	    Append(subscope, fit.item);
+	  }
+	  if (Len(subscope) > 0)
+	    cname = NewStringf("%s::%s", subscope, last);
+	  else
+	    cname = Copy(last);
+#if RESOLVE_DEBUG
+	  Printf(stdout, "subscope to create: [%s] cname: [%s]\n", subscope, cname);
+#endif
+	  fail = 0;
+	  Delete(subscope);
+	} else {
+	  if (is_class_definition) {
+	    if (!fit.item) {
+	      /* It is valid to define a new class with the same name as one forward declared in a parent scope */
+	      fail = 0;
+	    } else if (Swig_scopename_check(cname)) {
+	      /* Classes defined with scope qualifiers must have a matching forward declaration in matching scope */
+	      fail = 1;
+	    } else {
+	      /* This may let through some invalid cases */
+	      fail = 0;
+	    }
+#if RESOLVE_DEBUG
+	    Printf(stdout, "scope for class definition, fail: %d\n", fail);
+#endif
+	  } else {
+#if RESOLVE_DEBUG
+	    Printf(stdout, "no matching base scope for template\n");
+#endif
+	    fail = 1;
+	  }
+	}
+
+	Delete(found_scopes);
+	Delete(current_scopes);
+
+	if (fail) {
+	  String *cname_resolved = NewStringf("%s::%s", found_scopename, last);
+	  Swig_error(cparse_file, cparse_line, "'%s' resolves to '%s' and was incorrectly instantiated in scope '%s' instead of within scope '%s'.\n", cname, cname_resolved, current_scopename, found_scopename);
+	  cname = Copy(last);
+	  Delete(cname_resolved);
+	}
+      }
+
+      Delete(current_scopename);
+      Delete(found_scopename);
+    }
+  } else if (!is_class_definition) {
+    /* A template instantiation requires a template to be found in scope... fail here too?
+    Swig_error(cparse_file, cparse_line, "No template found to instantiate '%s' with %%template.\n", cname);
+     */
+  }
+
+  if (Swig_scopename_check(cname)) {
+    Node   *ns;
+    String *prefix = Swig_scopename_prefix(cname);
+    if (prefix && (Strncmp(prefix,"::",2) == 0)) {
+/* I don't think we can use :: global scope to declare classes and hence neither %template. - consider reporting error instead - wsfulton. */
+      /* Use the global scope */
+      String *nprefix = NewString(Char(prefix)+2);
+      Delete(prefix);
+      prefix= nprefix;
+      gscope = set_scope_to_global();
+    }
+    if (Len(prefix) == 0) {
+      String *base = Copy(last);
+      /* Use the global scope, but we need to add a 'global' namespace.  */
+      if (!gscope) gscope = set_scope_to_global();
+      /* note that this namespace is not the "unnamed" one,
+	 and we don't use Setattr(nscope,"name", ""),
+	 because the unnamed namespace is private */
+      nscope = new_node("namespace");
+      Setattr(nscope,"symtab", gscope);;
+      nscope_inner = nscope;
+      Delete(last);
+      return base;
+    }
+    /* Try to locate the scope */
+    ns = Swig_symbol_clookup(prefix,0);
+    if (!ns) {
+      Swig_error(cparse_file,cparse_line,"Undefined scope '%s'\n", prefix);
+    } else {
+      Symtab *nstab = Getattr(ns,"symtab");
+      if (!nstab) {
+	Swig_error(cparse_file,cparse_line, "'%s' is not defined as a valid scope.\n", prefix);
+	ns = 0;
+      } else {
+	/* Check if the node scope is the current scope */
+	String *tname = Swig_symbol_qualifiedscopename(0);
+	String *nname = Swig_symbol_qualifiedscopename(nstab);
+	if (tname && (Strcmp(tname,nname) == 0)) {
+	  ns = 0;
+	  cname = Copy(last);
+	}
+	Delete(tname);
+	Delete(nname);
+      }
+      if (ns) {
+	/* we will try to create a new node using the namespaces we
+	   can find in the scope name */
+	List *scopes = Swig_scopename_tolist(prefix);
+	String *sname;
+	Iterator si;
+
+	for (si = First(scopes); si.item; si = Next(si)) {
+	  Node *ns1,*ns2;
+	  sname = si.item;
+	  ns1 = Swig_symbol_clookup(sname,0);
+	  assert(ns1);
+	  if (Strcmp(nodeType(ns1),"namespace") == 0) {
+	    if (Getattr(ns1,"alias")) {
+	      ns1 = Getattr(ns1,"namespace");
+	    }
+	  } else {
+	    /* now this last part is a class */
+	    si = Next(si);
+	    /*  or a nested class tree, which is unrolled here */
+	    for (; si.item; si = Next(si)) {
+	      if (si.item) {
+		Printf(sname,"::%s",si.item);
+	      }
+	    }
+	    /* we get the 'inner' class */
+	    nscope_inner = Swig_symbol_clookup(sname,0);
+	    /* set the scope to the inner class */
+	    Swig_symbol_setscope(Getattr(nscope_inner,"symtab"));
+	    /* save the last namespace prefix */
+	    Delete(Namespaceprefix);
+	    Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+	    /* and return the node name, including the inner class prefix */
+	    break;
+	  }
+	  /* here we just populate the namespace tree as usual */
+	  ns2 = new_node("namespace");
+	  Setattr(ns2,"name",sname);
+	  Setattr(ns2,"symtab", Getattr(ns1,"symtab"));
+	  add_symbols(ns2);
+	  Swig_symbol_setscope(Getattr(ns1,"symtab"));
+	  Delete(Namespaceprefix);
+	  Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+	  if (nscope_inner) {
+	    if (Getattr(nscope_inner,"symtab") != Getattr(ns2,"symtab")) {
+	      appendChild(nscope_inner,ns2);
+	      Delete(ns2);
+	    }
+	  }
+	  nscope_inner = ns2;
+	  if (!nscope) nscope = ns2;
+	}
+	cname = Copy(last);
+	Delete(scopes);
+      }
+    }
+    Delete(prefix);
+  }
+  Delete(last);
+
+  return cname;
+}
+ 
+/* look for simple typedef name in typedef list */
+static String *try_to_find_a_name_for_unnamed_structure(const char *storage, Node *decls) {
+  String *name = 0;
+  Node *n = decls;
+  if (storage && (strcmp(storage, "typedef") == 0)) {
+    for (; n; n = nextSibling(n)) {
+      if (!Len(Getattr(n, "decl"))) {
+	name = Copy(Getattr(n, "name"));
+	break;
+      }
+    }
+  }
+  return name;
+}
+
+/* traverse copied tree segment, and update outer class links*/
+static void update_nested_classes(Node *n)
+{
+  Node *c = firstChild(n);
+  while (c) {
+    if (Getattr(c, "nested:outer"))
+      Setattr(c, "nested:outer", n);
+    update_nested_classes(c);
+    c = nextSibling(c);
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ * nested_forward_declaration()
+ * 
+ * Nested struct handling for C++ code if the nested classes are disabled.
+ * Create the nested class/struct/union as a forward declaration.
+ * ----------------------------------------------------------------------------- */
+
+static Node *nested_forward_declaration(const char *storage, const char *kind, String *sname, String *name, Node *cpp_opt_declarators) {
+  Node *nn = 0;
+
+  if (sname) {
+    /* Add forward declaration of the nested type */
+    Node *n = new_node("classforward");
+    Setattr(n, "kind", kind);
+    Setattr(n, "name", sname);
+    Setattr(n, "storage", storage);
+    Setattr(n, "sym:weak", "1");
+    add_symbols(n);
+    nn = n;
+  }
+
+  /* Add any variable instances. Also add in any further typedefs of the nested type.
+     Note that anonymous typedefs (eg typedef struct {...} a, b;) are treated as class forward declarations */
+  if (cpp_opt_declarators) {
+    int storage_typedef = (storage && (strcmp(storage, "typedef") == 0));
+    int variable_of_anonymous_type = !sname && !storage_typedef;
+    if (!variable_of_anonymous_type) {
+      int anonymous_typedef = !sname && (storage && (strcmp(storage, "typedef") == 0));
+      Node *n = cpp_opt_declarators;
+      SwigType *type = name;
+      while (n) {
+	Setattr(n, "type", type);
+	Setattr(n, "storage", storage);
+	if (anonymous_typedef) {
+	  Setattr(n, "nodeType", "classforward");
+	  Setattr(n, "sym:weak", "1");
+	}
+	n = nextSibling(n);
+      }
+      add_symbols(cpp_opt_declarators);
+
+      if (nn) {
+	set_nextSibling(nn, cpp_opt_declarators);
+      } else {
+	nn = cpp_opt_declarators;
+      }
+    }
+  }
+
+  if (!currentOuterClass || !GetFlag(currentOuterClass, "nested")) {
+    if (nn && Equal(nodeType(nn), "classforward")) {
+      Node *n = nn;
+      if (!GetFlag(n, "feature:ignore")) {
+	SWIG_WARN_NODE_BEGIN(n);
+	Swig_warning(WARN_PARSE_NAMED_NESTED_CLASS, cparse_file, cparse_line,"Nested %s not currently supported (%s ignored)\n", kind, sname ? sname : name);
+	SWIG_WARN_NODE_END(n);
+      }
+    } else {
+      Swig_warning(WARN_PARSE_UNNAMED_NESTED_CLASS, cparse_file, cparse_line, "Nested %s not currently supported (ignored).\n", kind);
+    }
+  }
+
+  return nn;
+}
+
+
+Node *Swig_cparse(File *f) {
+  scanner_file(f);
+  top = 0;
+  yyparse();
+  return top;
+}
+
+static void single_new_feature(const char *featurename, String *val, Hash *featureattribs, char *declaratorid, SwigType *type, ParmList *declaratorparms, String *qualifier) {
+  String *fname;
+  String *name;
+  String *fixname;
+  SwigType *t = Copy(type);
+
+  /* Printf(stdout, "single_new_feature: [%s] [%s] [%s] [%s] [%s] [%s]\n", featurename, val, declaratorid, t, ParmList_str_defaultargs(declaratorparms), qualifier); */
+
+  /* Warn about deprecated features */
+  if (strcmp(featurename, "nestedworkaround") == 0)
+    Swig_warning(WARN_DEPRECATED_NESTED_WORKAROUND, cparse_file, cparse_line, "The 'nestedworkaround' feature is deprecated.\n");
+
+  fname = NewStringf("feature:%s",featurename);
+  if (declaratorid) {
+    fixname = feature_identifier_fix(declaratorid);
+  } else {
+    fixname = NewStringEmpty();
+  }
+  if (Namespaceprefix) {
+    name = NewStringf("%s::%s",Namespaceprefix, fixname);
+  } else {
+    name = fixname;
+  }
+
+  if (declaratorparms) Setmeta(val,"parms",declaratorparms);
+  if (!Len(t)) t = 0;
+  if (t) {
+    if (qualifier) SwigType_push(t,qualifier);
+    if (SwigType_isfunction(t)) {
+      SwigType *decl = SwigType_pop_function(t);
+      if (SwigType_ispointer(t)) {
+	String *nname = NewStringf("*%s",name);
+	Swig_feature_set(Swig_cparse_features(), nname, decl, fname, val, featureattribs);
+	Delete(nname);
+      } else {
+	Swig_feature_set(Swig_cparse_features(), name, decl, fname, val, featureattribs);
+      }
+      Delete(decl);
+    } else if (SwigType_ispointer(t)) {
+      String *nname = NewStringf("*%s",name);
+      Swig_feature_set(Swig_cparse_features(),nname,0,fname,val, featureattribs);
+      Delete(nname);
+    }
+  } else {
+    /* Global feature, that is, feature not associated with any particular symbol */
+    Swig_feature_set(Swig_cparse_features(),name,0,fname,val, featureattribs);
+  }
+  Delete(fname);
+  Delete(name);
+}
+
+/* Add a new feature to the Hash. Additional features are added if the feature has a parameter list (declaratorparms)
+ * and one or more of the parameters have a default argument. An extra feature is added for each defaulted parameter,
+ * simulating the equivalent overloaded method. */
+static void new_feature(const char *featurename, String *val, Hash *featureattribs, char *declaratorid, SwigType *type, ParmList *declaratorparms, String *qualifier) {
+
+  ParmList *declparms = declaratorparms;
+
+  /* remove the { and } braces if the noblock attribute is set */
+  String *newval = remove_block(featureattribs, val);
+  val = newval ? newval : val;
+
+  /* Add the feature */
+  single_new_feature(featurename, val, featureattribs, declaratorid, type, declaratorparms, qualifier);
+
+  /* Add extra features if there are default parameters in the parameter list */
+  if (type) {
+    while (declparms) {
+      if (ParmList_has_defaultargs(declparms)) {
+
+        /* Create a parameter list for the new feature by copying all
+           but the last (defaulted) parameter */
+        ParmList* newparms = CopyParmListMax(declparms, ParmList_len(declparms)-1);
+
+        /* Create new declaration - with the last parameter removed */
+        SwigType *newtype = Copy(type);
+        Delete(SwigType_pop_function(newtype)); /* remove the old parameter list from newtype */
+        SwigType_add_function(newtype,newparms);
+
+        single_new_feature(featurename, Copy(val), featureattribs, declaratorid, newtype, newparms, qualifier);
+        declparms = newparms;
+      } else {
+        declparms = 0;
+      }
+    }
+  }
+}
+
+/* check if a function declaration is a plain C object */
+static int is_cfunction(Node *n) {
+  if (!cparse_cplusplus || cparse_externc)
+    return 1;
+  if (Swig_storage_isexternc(n)) {
+    return 1;
+  }
+  return 0;
+}
+
+/* If the Node is a function with parameters, check to see if any of the parameters
+ * have default arguments. If so create a new function for each defaulted argument. 
+ * The additional functions form a linked list of nodes with the head being the original Node n. */
+static void default_arguments(Node *n) {
+  Node *function = n;
+
+  if (function) {
+    ParmList *varargs = Getattr(function,"feature:varargs");
+    if (varargs) {
+      /* Handles the %varargs directive by looking for "feature:varargs" and 
+       * substituting ... with an alternative set of arguments.  */
+      Parm     *p = Getattr(function,"parms");
+      Parm     *pp = 0;
+      while (p) {
+	SwigType *t = Getattr(p,"type");
+	if (Strcmp(t,"v(...)") == 0) {
+	  if (pp) {
+	    ParmList *cv = Copy(varargs);
+	    set_nextSibling(pp,cv);
+	    Delete(cv);
+	  } else {
+	    ParmList *cv =  Copy(varargs);
+	    Setattr(function,"parms", cv);
+	    Delete(cv);
+	  }
+	  break;
+	}
+	pp = p;
+	p = nextSibling(p);
+      }
+    }
+
+    /* Do not add in functions if kwargs is being used or if user wants old default argument wrapping
+       (one wrapped method per function irrespective of number of default arguments) */
+    if (compact_default_args 
+	|| is_cfunction(function) 
+	|| GetFlag(function,"feature:compactdefaultargs") 
+	|| (GetFlag(function,"feature:kwargs") && kwargs_supported)) {
+      ParmList *p = Getattr(function,"parms");
+      if (p) 
+        Setattr(p,"compactdefargs", "1"); /* mark parameters for special handling */
+      function = 0; /* don't add in extra methods */
+    }
+  }
+
+  while (function) {
+    ParmList *parms = Getattr(function,"parms");
+    if (ParmList_has_defaultargs(parms)) {
+
+      /* Create a parameter list for the new function by copying all
+         but the last (defaulted) parameter */
+      ParmList* newparms = CopyParmListMax(parms,ParmList_len(parms)-1);
+
+      /* Create new function and add to symbol table */
+      {
+	SwigType *ntype = Copy(nodeType(function));
+	char *cntype = Char(ntype);
+        Node *new_function = new_node(ntype);
+        SwigType *decl = Copy(Getattr(function,"decl"));
+        int constqualifier = SwigType_isconst(decl);
+	String *ccode = Copy(Getattr(function,"code"));
+	String *cstorage = Copy(Getattr(function,"storage"));
+	String *cvalue = Copy(Getattr(function,"value"));
+	SwigType *ctype = Copy(Getattr(function,"type"));
+	String *cthrow = Copy(Getattr(function,"throw"));
+
+        Delete(SwigType_pop_function(decl)); /* remove the old parameter list from decl */
+        SwigType_add_function(decl,newparms);
+        if (constqualifier)
+          SwigType_add_qualifier(decl,"const");
+
+        Setattr(new_function,"name", Getattr(function,"name"));
+        Setattr(new_function,"code", ccode);
+        Setattr(new_function,"decl", decl);
+        Setattr(new_function,"parms", newparms);
+        Setattr(new_function,"storage", cstorage);
+        Setattr(new_function,"value", cvalue);
+        Setattr(new_function,"type", ctype);
+        Setattr(new_function,"throw", cthrow);
+
+	Delete(ccode);
+	Delete(cstorage);
+	Delete(cvalue);
+	Delete(ctype);
+	Delete(cthrow);
+	Delete(decl);
+
+        {
+          Node *throws = Getattr(function,"throws");
+	  ParmList *pl = CopyParmList(throws);
+          if (throws) Setattr(new_function,"throws",pl);
+	  Delete(pl);
+        }
+
+        /* copy specific attributes for global (or in a namespace) template functions - these are not templated class methods */
+        if (strcmp(cntype,"template") == 0) {
+          Node *templatetype = Getattr(function,"templatetype");
+          Node *symtypename = Getattr(function,"sym:typename");
+          Parm *templateparms = Getattr(function,"templateparms");
+          if (templatetype) {
+	    Node *tmp = Copy(templatetype);
+	    Setattr(new_function,"templatetype",tmp);
+	    Delete(tmp);
+	  }
+          if (symtypename) {
+	    Node *tmp = Copy(symtypename);
+	    Setattr(new_function,"sym:typename",tmp);
+	    Delete(tmp);
+	  }
+          if (templateparms) {
+	    Parm *tmp = CopyParmList(templateparms);
+	    Setattr(new_function,"templateparms",tmp);
+	    Delete(tmp);
+	  }
+        } else if (strcmp(cntype,"constructor") == 0) {
+          /* only copied for constructors as this is not a user defined feature - it is hard coded in the parser */
+          if (GetFlag(function,"feature:new")) SetFlag(new_function,"feature:new");
+        }
+
+        add_symbols(new_function);
+        /* mark added functions as ones with overloaded parameters and point to the parsed method */
+        Setattr(new_function,"defaultargs", n);
+
+        /* Point to the new function, extending the linked list */
+        set_nextSibling(function, new_function);
+	Delete(new_function);
+        function = new_function;
+	
+	Delete(ntype);
+      }
+    } else {
+      function = 0;
+    }
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ * mark_nodes_as_extend()
+ *
+ * Used by the %extend to mark subtypes with "feature:extend".
+ * template instances declared within %extend are skipped
+ * ----------------------------------------------------------------------------- */
+
+static void mark_nodes_as_extend(Node *n) {
+  for (; n; n = nextSibling(n)) {
+    if (Getattr(n, "template") && Strcmp(nodeType(n), "class") == 0)
+      continue;
+    /* Fix me: extend is not a feature. Replace with isextendmember? */
+    Setattr(n, "feature:extend", "1");
+    mark_nodes_as_extend(firstChild(n));
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ * add_qualifier_to_declarator()
+ *
+ * Normally the qualifier is pushed on to the front of the type.
+ * Adding a qualifier to a pointer to member function is a special case.
+ * For example       : typedef double (Cls::*pmf)(void) const;
+ * The qualifier is  : q(const).
+ * The declarator is : m(Cls).f(void).
+ * We need           : m(Cls).q(const).f(void).
+ * ----------------------------------------------------------------------------- */
+
+static String *add_qualifier_to_declarator(SwigType *type, SwigType *qualifier) {
+  int is_pointer_to_member_function = 0;
+  String *decl = Copy(type);
+  String *poppedtype = NewString("");
+  assert(qualifier);
+
+  while (decl) {
+    if (SwigType_ismemberpointer(decl)) {
+      String *memberptr = SwigType_pop(decl);
+      if (SwigType_isfunction(decl)) {
+	is_pointer_to_member_function = 1;
+	SwigType_push(decl, qualifier);
+	SwigType_push(decl, memberptr);
+	Insert(decl, 0, poppedtype);
+	Delete(memberptr);
+	break;
+      } else {
+	Append(poppedtype, memberptr);
+      }
+      Delete(memberptr);
+    } else {
+      String *popped = SwigType_pop(decl);
+      if (!popped)
+	break;
+      Append(poppedtype, popped);
+      Delete(popped);
+    }
+  }
+
+  if (!is_pointer_to_member_function) {
+    Delete(decl);
+    decl = Copy(type);
+    SwigType_push(decl, qualifier);
+  }
+
+  Delete(poppedtype);
+  return decl;
+}
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 1554 "parser.y"
+{
+  const char  *id;
+  List  *bases;
+  struct Define {
+    String *val;
+    String *rawval;
+    int     type;
+    String *qualifier;
+    String *refqualifier;
+    String *bitfield;
+    Parm   *throws;
+    String *throwf;
+    String *nexcept;
+    String *final;
+  } dtype;
+  struct {
+    const char *type;
+    String *filename;
+    int   line;
+  } loc;
+  struct {
+    char      *id;
+    SwigType  *type;
+    String    *defarg;
+    ParmList  *parms;
+    short      have_parms;
+    ParmList  *throws;
+    String    *throwf;
+    String    *nexcept;
+    String    *final;
+  } decl;
+  Parm         *tparms;
+  struct {
+    String     *method;
+    Hash       *kwargs;
+  } tmap;
+  struct {
+    String     *type;
+    String     *us;
+  } ptype;
+  SwigType     *type;
+  String       *str;
+  Parm         *p;
+  ParmList     *pl;
+  int           intvalue;
+  Node         *node;
+}
+/* Line 193 of yacc.c.  */
+#line 1963 "parser.c"
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 216 of yacc.c.  */
+#line 1976 "parser.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  62
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   6281
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  145
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  185
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  632
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  1204
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   399
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
+      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,    98,    99,   100,   101,   102,   103,   104,
+     105,   106,   107,   108,   109,   110,   111,   112,   113,   114,
+     115,   116,   117,   118,   119,   120,   121,   122,   123,   124,
+     125,   126,   127,   128,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138,   139,   140,   141,   142,   143,   144
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     5,     9,    12,    16,    19,    25,    29,
+      32,    35,    38,    40,    42,    44,    46,    48,    50,    52,
+      55,    57,    59,    61,    63,    65,    67,    69,    71,    73,
+      75,    77,    79,    81,    83,    85,    87,    89,    91,    93,
+      95,    97,    98,   107,   113,   117,   123,   129,   139,   143,
+     147,   150,   153,   159,   162,   168,   171,   176,   178,   180,
+     188,   196,   202,   203,   211,   213,   215,   218,   221,   223,
+     229,   235,   241,   245,   250,   254,   262,   271,   277,   281,
+     283,   285,   289,   291,   296,   304,   311,   313,   315,   323,
+     333,   342,   353,   359,   367,   374,   383,   385,   387,   393,
+     398,   404,   412,   414,   418,   425,   432,   441,   443,   446,
+     450,   452,   455,   459,   466,   472,   482,   485,   487,   489,
+     491,   492,   499,   501,   508,   519,   521,   528,   538,   540,
+     546,   548,   550,   552,   554,   556,   558,   560,   562,   565,
+     567,   580,   595,   604,   606,   608,   610,   612,   614,   615,
+     619,   621,   624,   627,   630,   632,   638,   647,   659,   666,
+     668,   670,   672,   674,   676,   678,   679,   690,   691,   700,
+     702,   707,   712,   713,   720,   724,   731,   736,   744,   746,
+     748,   750,   752,   754,   756,   758,   761,   763,   766,   768,
+     772,   774,   778,   783,   784,   791,   792,   798,   804,   807,
+     808,   809,   817,   819,   821,   822,   826,   828,   830,   832,
+     834,   836,   838,   840,   842,   846,   848,   850,   852,   854,
+     856,   858,   860,   862,   864,   866,   869,   872,   879,   886,
+     894,   903,   912,   921,   931,   939,   945,   948,   951,   954,
+     957,   959,   961,   963,   965,   967,   969,   971,   973,   975,
+     977,   979,   982,   987,   990,   993,   998,  1001,  1007,  1009,
+    1011,  1013,  1015,  1017,  1020,  1022,  1024,  1027,  1030,  1032,
+    1034,  1036,  1038,  1040,  1042,  1045,  1048,  1051,  1054,  1056,
+    1059,  1062,  1065,  1068,  1070,  1072,  1075,  1077,  1081,  1086,
+    1088,  1091,  1099,  1101,  1103,  1106,  1109,  1111,  1114,  1116,
+    1120,  1122,  1124,  1126,  1129,  1131,  1135,  1137,  1140,  1146,
+    1149,  1152,  1154,  1157,  1160,  1162,  1168,  1170,  1172,  1178,
+    1180,  1183,  1187,  1191,  1193,  1196,  1199,  1203,  1208,  1214,
+    1219,  1223,  1228,  1233,  1236,  1240,  1244,  1249,  1255,  1262,
+    1269,  1275,  1281,  1283,  1286,  1290,  1295,  1301,  1305,  1310,
+    1315,  1317,  1320,  1325,  1330,  1335,  1341,  1348,  1354,  1361,
+    1365,  1370,  1375,  1381,  1383,  1386,  1389,  1392,  1396,  1400,
+    1402,  1405,  1408,  1410,  1412,  1415,  1419,  1423,  1428,  1432,
+    1437,  1440,  1444,  1448,  1453,  1459,  1463,  1467,  1470,  1473,
+    1475,  1477,  1480,  1482,  1484,  1486,  1488,  1491,  1493,  1495,
+    1497,  1499,  1502,  1504,  1507,  1511,  1513,  1515,  1517,  1520,
+    1522,  1524,  1527,  1529,  1534,  1536,  1538,  1541,  1543,  1545,
+    1547,  1549,  1551,  1553,  1555,  1557,  1559,  1561,  1563,  1565,
+    1567,  1569,  1570,  1573,  1575,  1577,  1579,  1581,  1583,  1585,
+    1587,  1589,  1592,  1594,  1596,  1598,  1601,  1605,  1610,  1612,
+    1616,  1618,  1621,  1623,  1627,  1629,  1631,  1633,  1637,  1644,
+    1648,  1655,  1659,  1666,  1670,  1677,  1679,  1681,  1683,  1689,
+    1696,  1701,  1704,  1706,  1708,  1710,  1712,  1714,  1718,  1723,
+    1729,  1735,  1741,  1748,  1755,  1758,  1761,  1763,  1765,  1767,
+    1769,  1771,  1773,  1775,  1777,  1781,  1785,  1789,  1793,  1797,
+    1801,  1805,  1809,  1813,  1817,  1821,  1825,  1829,  1833,  1839,
+    1845,  1849,  1853,  1857,  1863,  1866,  1869,  1872,  1875,  1878,
+    1880,  1882,  1884,  1885,  1889,  1891,  1893,  1897,  1898,  1903,
+    1904,  1911,  1913,  1915,  1917,  1919,  1921,  1924,  1927,  1929,
+    1931,  1933,  1935,  1937,  1939,  1941,  1943,  1945,  1947,  1949,
+    1951,  1954,  1957,  1959,  1961,  1963,  1965,  1970,  1972,  1974,
+    1980,  1983,  1988,  1990,  1992,  1995,  1997,  1999,  2003,  2007,
+    2012,  2017,  2021,  2026,  2029,  2031,  2033,  2037,  2040,  2045,
+    2048,  2051,  2055,  2057,  2059,  2061,  2063,  2065,  2067,  2069,
+    2071,  2074,  2079,  2081,  2085,  2087,  2090,  2094,  2098,  2101,
+    2104,  2107,  2109,  2112,  2114,  2118,  2121,  2126,  2128,  2132,
+    2134,  2138,  2142,  2145,  2148,  2151,  2154,  2156,  2159,  2161,
+    2163,  2165,  2167,  2171,  2173,  2177,  2183,  2185,  2189,  2193,
+    2199,  2201,  2203
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int16 yyrhs[] =
+{
+     146,     0,    -1,   147,    -1,   123,   243,    43,    -1,   123,
+       1,    -1,   124,   243,    43,    -1,   124,     1,    -1,   125,
+      40,   239,    41,    43,    -1,   125,     1,    43,    -1,   147,
+     148,    -1,   147,   126,    -1,   147,   127,    -1,   329,    -1,
+     149,    -1,   186,    -1,   203,    -1,    43,    -1,     1,    -1,
+     202,    -1,     1,   122,    -1,   150,    -1,   152,    -1,   153,
+      -1,   154,    -1,   155,    -1,   156,    -1,   159,    -1,   160,
+      -1,   163,    -1,   164,    -1,   165,    -1,   166,    -1,   167,
+      -1,   168,    -1,   171,    -1,   173,    -1,   176,    -1,   178,
+      -1,   183,    -1,   184,    -1,   185,    -1,    -1,    67,   326,
+     301,   317,    46,   151,   220,    47,    -1,    99,   182,    46,
+     180,    47,    -1,   100,   180,    43,    -1,    63,   314,    55,
+     270,    43,    -1,    63,   263,   253,   250,    43,    -1,    63,
+     263,   255,    40,   239,    41,   259,   250,    43,    -1,    63,
+       1,    43,    -1,    63,     1,     0,    -1,    98,     4,    -1,
+      98,   323,    -1,    97,    40,   314,    41,    46,    -1,    97,
+      46,    -1,    97,    40,   314,    41,    43,    -1,    97,    43,
+      -1,   323,    46,   243,    47,    -1,   323,    -1,   157,    -1,
+     102,    40,   158,    42,   327,    41,     4,    -1,   102,    40,
+     158,    42,   327,    41,    46,    -1,   102,    40,   158,    41,
+      43,    -1,    -1,   162,   326,   323,    60,   161,   147,    61,
+      -1,     8,    -1,     9,    -1,    95,     4,    -1,    95,    46,
+      -1,     4,    -1,    10,    40,   315,    41,   323,    -1,    10,
+      40,   315,    41,     4,    -1,    10,    40,   315,    41,    46,
+      -1,    57,   326,   315,    -1,    64,    40,   315,    41,    -1,
+      64,    40,    41,    -1,    94,    40,   314,    41,   238,   314,
+      43,    -1,    94,    40,   314,    41,   238,   263,   253,    43,
+      -1,    68,   170,   314,    55,   169,    -1,    68,   170,   314,
+      -1,   323,    -1,     4,    -1,    40,   314,    41,    -1,   329,
+      -1,   172,   253,   315,    43,    -1,   172,    40,   327,    41,
+     253,   308,    43,    -1,   172,    40,   327,    41,   323,    43,
+      -1,    65,    -1,    66,    -1,    69,    40,   315,    41,   253,
+     308,   174,    -1,    69,    40,   315,    42,   328,    41,   253,
+     308,    43,    -1,    69,    40,   315,   175,    41,   253,   308,
+     174,    -1,    69,    40,   315,    42,   328,   175,    41,   253,
+     308,    43,    -1,    69,    40,   315,    41,   174,    -1,    69,
+      40,   315,    42,   328,    41,    43,    -1,    69,    40,   315,
+     175,    41,   174,    -1,    69,    40,   315,    42,   328,   175,
+      41,    43,    -1,   325,    -1,    43,    -1,   116,    40,   239,
+      41,    43,    -1,    42,   315,    55,   328,    -1,    42,   315,
+      55,   328,   175,    -1,    70,    40,   177,    41,   253,   308,
+      43,    -1,   239,    -1,    13,    42,   243,    -1,    96,    40,
+     179,    41,   180,   325,    -1,    96,    40,   179,    41,   180,
+      43,    -1,    96,    40,   179,    41,   180,    55,   182,    43,
+      -1,   327,    -1,   182,   181,    -1,    42,   182,   181,    -1,
+     329,    -1,   263,   252,    -1,    40,   239,    41,    -1,    40,
+     239,    41,    40,   239,    41,    -1,   115,    40,   239,    41,
+     174,    -1,   101,    40,   316,    41,   321,   104,   244,   105,
+      43,    -1,   103,   323,    -1,   188,    -1,   201,    -1,   200,
+      -1,    -1,    44,   323,    46,   187,   147,    47,    -1,   192,
+      -1,    92,   317,    55,   263,   252,    43,    -1,   120,   104,
+     212,   105,    92,   317,    55,   263,   252,    43,    -1,   230,
+      -1,   238,   263,   253,   308,   190,   189,    -1,   238,    88,
+     253,   308,   113,   191,   304,   190,   189,    -1,    43,    -1,
+      42,   253,   308,   190,   189,    -1,    46,    -1,     1,    -1,
+     250,    -1,   267,    -1,    32,    -1,    30,    -1,    35,    -1,
+     317,    -1,   317,   133,    -1,   266,    -1,   238,    88,   317,
+      55,   193,   194,    40,   239,    41,   308,   195,   196,    -1,
+     238,    88,   317,    55,   193,   194,    40,   239,    41,   308,
+     113,   263,   195,   196,    -1,   238,    88,   317,    55,   193,
+     194,   195,   196,    -1,    58,    -1,   104,    -1,   329,    -1,
+      46,    -1,    43,    -1,    -1,    40,   197,    43,    -1,    71,
+      -1,    71,    72,    -1,    71,    53,    -1,    77,   265,    -1,
+     329,    -1,   238,   198,   275,   199,    43,    -1,   238,   198,
+     275,   199,    46,   278,    47,    43,    -1,   238,   198,   275,
+     199,    46,   278,    47,   253,   308,   190,   189,    -1,   238,
+     263,    40,   239,    41,   309,    -1,   204,    -1,   208,    -1,
+     209,    -1,   216,    -1,   217,    -1,   229,    -1,    -1,   238,
+     299,   317,   305,   290,    46,   205,   220,    47,   207,    -1,
+      -1,   238,   299,   290,    46,   206,   220,    47,   207,    -1,
+      43,    -1,   253,   308,   190,   189,    -1,   238,   299,   317,
+      43,    -1,    -1,   120,   104,   212,   105,   210,   211,    -1,
+     120,   299,   317,    -1,   120,   191,   317,    40,   239,    41,
+      -1,    44,   120,   299,   317,    -1,    44,   120,   191,   317,
+      40,   239,    41,    -1,   188,    -1,   204,    -1,   226,    -1,
+     209,    -1,   208,    -1,   228,    -1,   213,    -1,   214,   215,
+      -1,   329,    -1,   298,   250,    -1,   243,    -1,    42,   214,
+     215,    -1,   329,    -1,    92,   317,    43,    -1,    92,    93,
+     317,    43,    -1,    -1,    93,   317,    46,   218,   147,    47,
+      -1,    -1,    93,    46,   219,   147,    47,    -1,    93,   314,
+      55,   317,    43,    -1,   225,   220,    -1,    -1,    -1,    67,
+      46,   221,   220,    47,   222,   220,    -1,   160,    -1,   329,
+      -1,    -1,     1,   223,   220,    -1,   186,    -1,   226,    -1,
+     227,    -1,   231,    -1,   232,    -1,   228,    -1,   208,    -1,
+     204,    -1,   238,   317,    43,    -1,   216,    -1,   209,    -1,
+     229,    -1,   184,    -1,   185,    -1,   235,    -1,   159,    -1,
+     183,    -1,    43,    -1,   224,    -1,   126,   224,    -1,   224,
+     127,    -1,   238,   263,    40,   239,    41,   309,    -1,   142,
+     319,    40,   239,    41,   233,    -1,    79,   142,   319,    40,
+     239,    41,   234,    -1,   238,   122,   263,   258,    40,   239,
+      41,   234,    -1,   238,   122,   263,   133,    40,   239,    41,
+     234,    -1,   238,   122,   263,   130,    40,   239,    41,   234,
+      -1,   238,   122,   263,   258,   133,    40,   239,    41,   234,
+      -1,   238,   122,   263,    40,   239,    41,   234,    -1,    82,
+      40,   239,    41,    46,    -1,    84,    40,    -1,    75,    77,
+      -1,    74,    77,    -1,    76,    77,    -1,   168,    -1,   154,
+      -1,   166,    -1,   171,    -1,   173,    -1,   176,    -1,   164,
+      -1,   178,    -1,   152,    -1,   153,    -1,   155,    -1,   308,
+      43,    -1,   308,    55,   272,    43,    -1,   308,    46,    -1,
+     308,    43,    -1,   308,    55,   270,    43,    -1,   308,    46,
+      -1,   238,   236,    77,   283,    43,    -1,   267,    -1,    32,
+      -1,    30,    -1,    35,    -1,   317,    -1,    44,   323,    -1,
+      44,    -1,   237,    -1,   237,    86,    -1,   237,    21,    -1,
+      78,    -1,    21,    -1,    79,    -1,    80,    -1,    83,    -1,
+      85,    -1,    83,    85,    -1,    85,    83,    -1,    78,    85,
+      -1,    85,    78,    -1,    86,    -1,    86,    78,    -1,    78,
+      86,    -1,    44,    86,    -1,    86,    44,    -1,   329,    -1,
+     240,    -1,   243,   241,    -1,   329,    -1,    42,   243,   241,
+      -1,    42,   127,   243,   241,    -1,   329,    -1,   264,   251,
+      -1,   120,   104,   299,   105,   299,   317,   250,    -1,    49,
+      -1,   242,    -1,   126,   242,    -1,   242,   127,    -1,   245,
+      -1,   247,   246,    -1,   329,    -1,    42,   247,   246,    -1,
+     329,    -1,   243,    -1,   286,    -1,   286,   249,    -1,   329,
+      -1,    42,   286,   249,    -1,   329,    -1,    55,   270,    -1,
+      55,   270,    58,   283,    59,    -1,    55,    46,    -1,    77,
+     283,    -1,   329,    -1,   253,   250,    -1,   256,   250,    -1,
+     250,    -1,   255,    40,   239,    41,   259,    -1,   253,    -1,
+     256,    -1,   255,    40,   239,    41,   259,    -1,   329,    -1,
+     258,   254,    -1,   258,   133,   254,    -1,   258,   130,   254,
+      -1,   255,    -1,   133,   254,    -1,   130,   254,    -1,   317,
+     118,   254,    -1,   258,   317,   118,   254,    -1,   258,   317,
+     118,   133,   254,    -1,   317,   118,   133,   254,    -1,   258,
+      49,   254,    -1,   258,   133,    49,   254,    -1,   258,   130,
+      49,   254,    -1,    49,   255,    -1,   133,    49,   254,    -1,
+     130,    49,   254,    -1,   317,   118,    49,   254,    -1,   258,
+     317,   118,    49,   254,    -1,   258,   317,   118,   133,    49,
+     254,    -1,   258,   317,   118,   130,    49,   254,    -1,   317,
+     118,   133,    49,   254,    -1,   317,   118,   130,    49,   254,
+      -1,   317,    -1,   142,   317,    -1,    40,   317,    41,    -1,
+      40,   258,   254,    41,    -1,    40,   317,   118,   254,    41,
+      -1,   254,    58,    59,    -1,   254,    58,   283,    59,    -1,
+     254,    40,   239,    41,    -1,   317,    -1,   142,   317,    -1,
+      40,   258,   255,    41,    -1,    40,   133,   255,    41,    -1,
+      40,   130,   255,    41,    -1,    40,   317,   118,   253,    41,
+      -1,    40,   317,   118,   261,   253,    41,    -1,    40,   317,
+     118,   256,    41,    -1,    40,   317,   118,   261,   256,    41,
+      -1,   255,    58,    59,    -1,   255,    58,   283,    59,    -1,
+     255,    40,   239,    41,    -1,   121,     3,    40,   239,    41,
+      -1,   258,    -1,   258,   257,    -1,   258,   133,    -1,   258,
+     130,    -1,   258,   133,   257,    -1,   258,   130,   257,    -1,
+     257,    -1,   133,   257,    -1,   130,   257,    -1,   133,    -1,
+     130,    -1,   317,   118,    -1,   317,   118,   261,    -1,   258,
+     317,   118,    -1,   258,   317,   118,   257,    -1,   257,    58,
+      59,    -1,   257,    58,   283,    59,    -1,    58,    59,    -1,
+      58,   283,    59,    -1,    40,   256,    41,    -1,   257,    40,
+     239,    41,    -1,   257,    40,   239,    41,   259,    -1,    40,
+     239,    41,    -1,   140,   261,   258,    -1,   140,   258,    -1,
+     140,   261,    -1,   140,    -1,   261,    -1,   261,   260,    -1,
+     260,    -1,   133,    -1,   130,    -1,   262,    -1,   262,   261,
+      -1,    50,    -1,    51,    -1,    52,    -1,   264,    -1,   261,
+     265,    -1,   265,    -1,   265,   261,    -1,   261,   265,   261,
+      -1,   267,    -1,    32,    -1,    30,    -1,   198,   317,    -1,
+      35,    -1,   317,    -1,   299,   317,    -1,   266,    -1,    87,
+      40,   317,    41,    -1,   268,    -1,   269,    -1,   269,   268,
+      -1,    22,    -1,    24,    -1,    25,    -1,    28,    -1,    29,
+      -1,    26,    -1,    27,    -1,    31,    -1,    23,    -1,    33,
+      -1,    36,    -1,    37,    -1,    38,    -1,    39,    -1,    -1,
+     271,   283,    -1,   272,    -1,   273,    -1,   274,    -1,   106,
+      -1,   107,    -1,   314,    -1,   329,    -1,   154,    -1,   154,
+     276,    -1,   276,    -1,   329,    -1,   279,    -1,   279,   127,
+      -1,   279,    42,   278,    -1,   279,    42,   127,   278,    -1,
+     277,    -1,   277,   280,   277,    -1,   281,    -1,   126,   281,
+      -1,   314,    -1,   314,    55,   282,    -1,   283,    -1,   286,
+      -1,   263,    -1,     3,   113,     3,    -1,     3,   113,     3,
+      40,   248,    41,    -1,   284,   113,     3,    -1,   284,   113,
+       3,    40,   248,    41,    -1,     3,    48,     3,    -1,     3,
+      48,     3,    40,   248,    41,    -1,   284,    48,     3,    -1,
+     284,    48,     3,    40,   248,    41,    -1,   287,    -1,   284,
+      -1,   323,    -1,    56,    40,   263,   251,    41,    -1,    56,
+      49,    40,   263,   251,    41,    -1,    56,    40,   285,    41,
+      -1,    56,   285,    -1,   324,    -1,    11,    -1,    12,    -1,
+     285,    -1,   288,    -1,    40,   283,    41,    -1,    40,   283,
+      41,   283,    -1,    40,   283,   258,    41,   283,    -1,    40,
+     283,   133,    41,   283,    -1,    40,   283,   130,    41,   283,
+      -1,    40,   283,   258,   133,    41,   283,    -1,    40,   283,
+     258,   130,    41,   283,    -1,   133,   283,    -1,   140,   283,
+      -1,    13,    -1,    14,    -1,    15,    -1,    16,    -1,    17,
+      -1,    18,    -1,    19,    -1,    20,    -1,   283,   137,   283,
+      -1,   283,   136,   283,    -1,   283,   140,   283,    -1,   283,
+     139,   283,    -1,   283,   138,   283,    -1,   283,   133,   283,
+      -1,   283,   131,   283,    -1,   283,   132,   283,    -1,   283,
+     135,   283,    -1,   283,   134,   283,    -1,   283,   130,   283,
+      -1,   283,   129,   283,    -1,   283,   110,   283,    -1,   283,
+     111,   283,    -1,    40,   283,   105,   283,    41,    -1,    40,
+     285,   104,   283,    41,    -1,   283,   109,   283,    -1,   283,
+     108,   283,    -1,   283,   112,   283,    -1,   283,   114,   283,
+      77,   283,    -1,   136,   283,    -1,   137,   283,    -1,   142,
+     283,    -1,   141,   283,    -1,   263,    40,    -1,    49,    -1,
+     329,    -1,   291,    -1,    -1,    77,   292,   293,    -1,   329,
+      -1,   294,    -1,   293,    42,   294,    -1,    -1,   302,   295,
+     317,   289,    -1,    -1,   302,   297,   296,   302,   317,   289,
+      -1,    75,    -1,    74,    -1,    76,    -1,    72,    -1,    73,
+      -1,    72,    49,    -1,    73,    49,    -1,   298,    -1,    53,
+      -1,    54,    -1,    72,    -1,    53,    -1,    54,    -1,   300,
+      -1,   329,    -1,    79,    -1,   329,    -1,    90,    -1,    91,
+      -1,    91,    90,    -1,    90,    91,    -1,   303,    -1,   329,
+      -1,    91,    -1,   329,    -1,    81,    40,   239,    41,    -1,
+      89,    -1,   303,    -1,    81,    40,   239,    41,   303,    -1,
+      89,   303,    -1,    89,    40,   283,    41,    -1,   259,    -1,
+     306,    -1,   259,   306,    -1,   307,    -1,   329,    -1,   308,
+     310,    43,    -1,   308,   310,    46,    -1,    40,   239,    41,
+      43,    -1,    40,   239,    41,    46,    -1,    55,   270,    43,
+      -1,   306,    55,   272,    43,    -1,    77,   311,    -1,   329,
+      -1,   312,    -1,   311,    42,   312,    -1,   312,    49,    -1,
+     311,    42,   312,    49,    -1,   317,    40,    -1,   317,    46,
+      -1,   104,   244,   105,    -1,     3,    -1,    90,    -1,    91,
+      -1,   314,    -1,   272,    -1,   323,    -1,   315,    -1,   329,
+      -1,   319,   318,    -1,   117,   144,   320,   318,    -1,   319,
+      -1,   117,   144,   320,    -1,   121,    -1,   121,   313,    -1,
+     117,   144,   121,    -1,   144,   320,   318,    -1,   144,   320,
+      -1,   144,   121,    -1,   119,   319,    -1,   314,    -1,   314,
+     313,    -1,   319,    -1,   120,   314,   313,    -1,   314,   322,
+      -1,   117,   144,   314,   322,    -1,   314,    -1,   117,   144,
+     314,    -1,   121,    -1,   117,   144,   121,    -1,   144,   314,
+     322,    -1,   144,   314,    -1,   144,   121,    -1,   119,   314,
+      -1,   323,     6,    -1,     6,    -1,   324,     7,    -1,     7,
+      -1,   323,    -1,    46,    -1,     4,    -1,    40,   327,    41,
+      -1,   329,    -1,   315,    55,   328,    -1,   315,    55,   328,
+      42,   327,    -1,   315,    -1,   315,    42,   327,    -1,   315,
+      55,   157,    -1,   315,    55,   157,    42,   327,    -1,   323,
+      -1,   287,    -1,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,  1730,  1730,  1742,  1746,  1749,  1752,  1755,  1758,  1763,
+    1772,  1776,  1783,  1788,  1789,  1790,  1791,  1792,  1802,  1818,
+    1828,  1829,  1830,  1831,  1832,  1833,  1834,  1835,  1836,  1837,
+    1838,  1839,  1840,  1841,  1842,  1843,  1844,  1845,  1846,  1847,
+    1848,  1855,  1855,  1937,  1947,  1961,  1981,  2005,  2029,  2033,
+    2044,  2053,  2072,  2078,  2084,  2089,  2096,  2103,  2107,  2120,
+    2129,  2144,  2157,  2157,  2213,  2214,  2221,  2240,  2271,  2275,
+    2285,  2290,  2308,  2351,  2357,  2370,  2376,  2402,  2408,  2415,
+    2416,  2419,  2420,  2427,  2473,  2519,  2530,  2533,  2560,  2566,
+    2572,  2578,  2586,  2592,  2598,  2604,  2612,  2613,  2614,  2617,
+    2622,  2632,  2668,  2669,  2704,  2721,  2729,  2742,  2764,  2770,
+    2774,  2777,  2788,  2793,  2806,  2818,  3117,  3127,  3134,  3135,
+    3139,  3139,  3172,  3178,  3188,  3200,  3209,  3289,  3352,  3356,
+    3381,  3385,  3396,  3401,  3402,  3403,  3407,  3408,  3409,  3413,
+    3424,  3429,  3434,  3441,  3447,  3451,  3454,  3459,  3462,  3462,
+    3475,  3478,  3481,  3490,  3493,  3500,  3522,  3551,  3649,  3702,
+    3703,  3704,  3705,  3706,  3707,  3716,  3716,  3965,  3965,  4112,
+    4113,  4125,  4143,  4143,  4404,  4410,  4416,  4422,  4428,  4431,
+    4434,  4437,  4440,  4443,  4448,  4484,  4488,  4491,  4495,  4500,
+    4504,  4509,  4519,  4550,  4550,  4608,  4608,  4630,  4657,  4674,
+    4679,  4674,  4687,  4688,  4689,  4689,  4703,  4704,  4721,  4722,
+    4723,  4724,  4725,  4726,  4727,  4728,  4729,  4730,  4731,  4732,
+    4733,  4734,  4735,  4736,  4738,  4741,  4745,  4757,  4786,  4816,
+    4849,  4868,  4889,  4911,  4934,  4957,  4965,  4972,  4979,  4987,
+    4995,  4998,  5002,  5005,  5006,  5007,  5008,  5009,  5010,  5011,
+    5012,  5015,  5026,  5037,  5050,  5061,  5072,  5086,  5089,  5092,
+    5093,  5097,  5099,  5107,  5119,  5120,  5121,  5128,  5129,  5130,
+    5131,  5132,  5133,  5134,  5135,  5136,  5137,  5138,  5139,  5140,
+    5141,  5142,  5143,  5144,  5151,  5162,  5166,  5173,  5177,  5182,
+    5186,  5198,  5208,  5218,  5221,  5225,  5231,  5244,  5248,  5251,
+    5255,  5259,  5287,  5295,  5299,  5302,  5306,  5309,  5322,  5338,
+    5349,  5359,  5371,  5375,  5379,  5386,  5408,  5425,  5444,  5463,
+    5470,  5478,  5487,  5496,  5500,  5509,  5520,  5531,  5543,  5553,
+    5567,  5575,  5584,  5593,  5597,  5606,  5617,  5628,  5640,  5650,
+    5660,  5671,  5684,  5691,  5699,  5715,  5723,  5734,  5745,  5756,
+    5775,  5783,  5800,  5808,  5815,  5822,  5833,  5845,  5856,  5868,
+    5879,  5890,  5910,  5931,  5937,  5943,  5950,  5957,  5966,  5975,
+    5978,  5987,  5996,  6003,  6010,  6017,  6025,  6035,  6046,  6057,
+    6068,  6075,  6082,  6085,  6102,  6120,  6130,  6137,  6143,  6148,
+    6155,  6159,  6164,  6171,  6175,  6181,  6185,  6191,  6192,  6193,
+    6199,  6205,  6209,  6210,  6214,  6221,  6224,  6225,  6229,  6230,
+    6232,  6235,  6238,  6243,  6254,  6279,  6282,  6336,  6340,  6344,
+    6348,  6352,  6356,  6360,  6364,  6368,  6372,  6376,  6380,  6384,
+    6388,  6394,  6394,  6410,  6415,  6418,  6424,  6439,  6455,  6456,
+    6459,  6460,  6464,  6465,  6475,  6479,  6484,  6494,  6505,  6510,
+    6515,  6518,  6524,  6532,  6544,  6559,  6560,  6580,  6584,  6588,
+    6592,  6596,  6600,  6604,  6608,  6615,  6618,  6621,  6625,  6630,
+    6642,  6650,  6654,  6659,  6673,  6690,  6691,  6694,  6704,  6722,
+    6729,  6736,  6743,  6751,  6759,  6763,  6769,  6770,  6771,  6772,
+    6773,  6774,  6775,  6776,  6779,  6783,  6787,  6791,  6795,  6799,
+    6803,  6807,  6811,  6815,  6819,  6823,  6827,  6831,  6839,  6849,
+    6853,  6857,  6861,  6870,  6876,  6880,  6884,  6888,  6892,  6908,
+    6911,  6916,  6921,  6921,  6922,  6925,  6942,  6951,  6951,  6969,
+    6969,  6987,  6988,  6989,  6992,  6996,  7000,  7004,  7010,  7013,
+    7017,  7023,  7027,  7031,  7037,  7040,  7045,  7046,  7049,  7052,
+    7055,  7058,  7063,  7066,  7071,  7074,  7079,  7085,  7091,  7097,
+    7103,  7109,  7117,  7125,  7130,  7137,  7140,  7150,  7161,  7172,
+    7182,  7192,  7200,  7212,  7213,  7216,  7217,  7218,  7219,  7222,
+    7234,  7240,  7249,  7250,  7251,  7254,  7255,  7256,  7259,  7260,
+    7263,  7268,  7272,  7275,  7278,  7281,  7284,  7289,  7293,  7296,
+    7303,  7309,  7312,  7317,  7320,  7326,  7331,  7335,  7338,  7341,
+    7344,  7349,  7353,  7356,  7359,  7365,  7368,  7371,  7379,  7382,
+    7385,  7389,  7394,  7407,  7411,  7416,  7422,  7426,  7431,  7435,
+    7442,  7445,  7450
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "END", "error", "$undefined", "ID", "HBLOCK", "POUND", "STRING",
+  "WSTRING", "INCLUDE", "IMPORT", "INSERT", "CHARCONST", "WCHARCONST",
+  "NUM_INT", "NUM_FLOAT", "NUM_UNSIGNED", "NUM_LONG", "NUM_ULONG",
+  "NUM_LONGLONG", "NUM_ULONGLONG", "NUM_BOOL", "TYPEDEF", "TYPE_INT",
+  "TYPE_UNSIGNED", "TYPE_SHORT", "TYPE_LONG", "TYPE_FLOAT", "TYPE_DOUBLE",
+  "TYPE_CHAR", "TYPE_WCHAR", "TYPE_VOID", "TYPE_SIGNED", "TYPE_BOOL",
+  "TYPE_COMPLEX", "TYPE_TYPEDEF", "TYPE_RAW", "TYPE_NON_ISO_INT8",
+  "TYPE_NON_ISO_INT16", "TYPE_NON_ISO_INT32", "TYPE_NON_ISO_INT64",
+  "LPAREN", "RPAREN", "COMMA", "SEMI", "EXTERN", "INIT", "LBRACE",
+  "RBRACE", "PERIOD", "ELLIPSIS", "CONST_QUAL", "VOLATILE", "REGISTER",
+  "STRUCT", "UNION", "EQUAL", "SIZEOF", "MODULE", "LBRACKET", "RBRACKET",
+  "BEGINFILE", "ENDOFFILE", "ILLEGAL", "CONSTANT", "NAME", "RENAME",
+  "NAMEWARN", "EXTEND", "PRAGMA", "FEATURE", "VARARGS", "ENUM", "CLASS",
+  "TYPENAME", "PRIVATE", "PUBLIC", "PROTECTED", "COLON", "STATIC",
+  "VIRTUAL", "FRIEND", "THROW", "CATCH", "EXPLICIT", "STATIC_ASSERT",
+  "CONSTEXPR", "THREAD_LOCAL", "DECLTYPE", "AUTO", "NOEXCEPT", "OVERRIDE",
+  "FINAL", "USING", "NAMESPACE", "NATIVE", "INLINE", "TYPEMAP", "EXCEPT",
+  "ECHO", "APPLY", "CLEAR", "SWIGTEMPLATE", "FRAGMENT", "WARN", "LESSTHAN",
+  "GREATERTHAN", "DELETE_KW", "DEFAULT", "LESSTHANOREQUALTO",
+  "GREATERTHANOREQUALTO", "EQUALTO", "NOTEQUALTO", "LESSEQUALGREATER",
+  "ARROW", "QUESTIONMARK", "TYPES", "PARMS", "NONID", "DSTAR", "DCNOT",
+  "TEMPLATE", "OPERATOR", "CONVERSIONOPERATOR", "PARSETYPE", "PARSEPARM",
+  "PARSEPARMS", "DOXYGENSTRING", "DOXYGENPOSTSTRING", "CAST", "LOR",
+  "LAND", "OR", "XOR", "AND", "RSHIFT", "LSHIFT", "MINUS", "PLUS",
+  "MODULO", "SLASH", "STAR", "LNOT", "NOT", "UMINUS", "DCOLON", "$accept",
+  "program", "interface", "declaration", "swig_directive",
+  "extend_directive", "@1", "apply_directive", "clear_directive",
+  "constant_directive", "echo_directive", "except_directive", "stringtype",
+  "fname", "fragment_directive", "include_directive", "@2", "includetype",
+  "inline_directive", "insert_directive", "module_directive",
+  "name_directive", "native_directive", "pragma_directive", "pragma_arg",
+  "pragma_lang", "rename_directive", "rename_namewarn",
+  "feature_directive", "stringbracesemi", "featattr", "varargs_directive",
+  "varargs_parms", "typemap_directive", "typemap_type", "tm_list",
+  "tm_tail", "typemap_parm", "types_directive", "template_directive",
+  "warn_directive", "c_declaration", "@3", "c_decl", "c_decl_tail",
+  "initializer", "cpp_alternate_rettype", "cpp_lambda_decl",
+  "lambda_introducer", "lambda_template", "lambda_body", "lambda_tail",
+  "@4", "c_enum_key", "c_enum_inherit", "c_enum_forward_decl",
+  "c_enum_decl", "c_constructor_decl", "cpp_declaration", "cpp_class_decl",
+  "@5", "@6", "cpp_opt_declarators", "cpp_forward_class_decl",
+  "cpp_template_decl", "@7", "cpp_template_possible", "template_parms",
+  "templateparameters", "templateparameter", "templateparameterstail",
+  "cpp_using_decl", "cpp_namespace_decl", "@8", "@9", "cpp_members", "@10",
+  "@11", "@12", "cpp_member_no_dox", "cpp_member", "cpp_constructor_decl",
+  "cpp_destructor_decl", "cpp_conversion_operator", "cpp_catch_decl",
+  "cpp_static_assert", "cpp_protection_decl", "cpp_swig_directive",
+  "cpp_end", "cpp_vend", "anonymous_bitfield", "anon_bitfield_type",
+  "extern_string", "storage_class", "parms", "rawparms", "ptail",
+  "parm_no_dox", "parm", "valparms", "rawvalparms", "valptail", "valparm",
+  "callparms", "callptail", "def_args", "parameter_declarator",
+  "plain_declarator", "declarator", "notso_direct_declarator",
+  "direct_declarator", "abstract_declarator", "direct_abstract_declarator",
+  "pointer", "cv_ref_qualifier", "ref_qualifier", "type_qualifier",
+  "type_qualifier_raw", "type", "rawtype", "type_right", "decltype",
+  "primitive_type", "primitive_type_list", "type_specifier", "definetype",
+  "@13", "default_delete", "deleted_definition", "explicit_default",
+  "ename", "constant_directives", "optional_ignored_defines", "enumlist",
+  "enumlist_item", "edecl_with_dox", "edecl", "etype", "expr", "exprmem",
+  "exprsimple", "valexpr", "exprnum", "exprcompound", "variadic",
+  "inherit", "raw_inherit", "@14", "base_list", "base_specifier", "@15",
+  "@16", "access_specifier", "templcpptype", "cpptype", "classkey",
+  "classkeyopt", "opt_virtual", "virt_specifier_seq",
+  "virt_specifier_seq_opt", "class_virt_specifier_opt",
+  "exception_specification", "qualifiers_exception_specification",
+  "cpp_const", "ctor_end", "ctor_initializer", "mem_initializer_list",
+  "mem_initializer", "less_valparms_greater", "identifier", "idstring",
+  "idstringopt", "idcolon", "idcolontail", "idtemplate",
+  "idtemplatetemplate", "idcolonnt", "idcolontailnt", "string", "wstring",
+  "stringbrace", "options", "kwargs", "stringnum", "empty", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
+     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
+     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
+     335,   336,   337,   338,   339,   340,   341,   342,   343,   344,
+     345,   346,   347,   348,   349,   350,   351,   352,   353,   354,
+     355,   356,   357,   358,   359,   360,   361,   362,   363,   364,
+     365,   366,   367,   368,   369,   370,   371,   372,   373,   374,
+     375,   376,   377,   378,   379,   380,   381,   382,   383,   384,
+     385,   386,   387,   388,   389,   390,   391,   392,   393,   394,
+     395,   396,   397,   398,   399
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint16 yyr1[] =
+{
+       0,   145,   146,   146,   146,   146,   146,   146,   146,   147,
+     147,   147,   147,   148,   148,   148,   148,   148,   148,   148,
+     149,   149,   149,   149,   149,   149,   149,   149,   149,   149,
+     149,   149,   149,   149,   149,   149,   149,   149,   149,   149,
+     149,   151,   150,   152,   153,   154,   154,   154,   154,   154,
+     155,   155,   156,   156,   156,   156,   157,   158,   158,   159,
+     159,   159,   161,   160,   162,   162,   163,   163,   164,   164,
+     164,   164,   165,   166,   166,   167,   167,   168,   168,   169,
+     169,   170,   170,   171,   171,   171,   172,   172,   173,   173,
+     173,   173,   173,   173,   173,   173,   174,   174,   174,   175,
+     175,   176,   177,   177,   178,   178,   178,   179,   180,   181,
+     181,   182,   182,   182,   183,   184,   185,   186,   186,   186,
+     187,   186,   186,   186,   186,   186,   188,   188,   189,   189,
+     189,   189,   190,   191,   191,   191,   191,   191,   191,   191,
+     192,   192,   192,   193,   194,   194,   195,   196,   197,   196,
+     198,   198,   198,   199,   199,   200,   201,   201,   202,   203,
+     203,   203,   203,   203,   203,   205,   204,   206,   204,   207,
+     207,   208,   210,   209,   209,   209,   209,   209,   211,   211,
+     211,   211,   211,   211,   212,   213,   213,   214,   214,   215,
+     215,   216,   216,   218,   217,   219,   217,   217,   220,   221,
+     222,   220,   220,   220,   223,   220,   224,   224,   224,   224,
+     224,   224,   224,   224,   224,   224,   224,   224,   224,   224,
+     224,   224,   224,   224,   225,   225,   225,   226,   227,   227,
+     228,   228,   228,   228,   228,   229,   230,   231,   231,   231,
+     232,   232,   232,   232,   232,   232,   232,   232,   232,   232,
+     232,   233,   233,   233,   234,   234,   234,   235,   236,   236,
+     236,   236,   236,   237,   238,   238,   238,   238,   238,   238,
+     238,   238,   238,   238,   238,   238,   238,   238,   238,   238,
+     238,   238,   238,   238,   239,   240,   240,   241,   241,   241,
+     242,   242,   242,   243,   243,   243,   244,   245,   245,   246,
+     246,   247,   247,   248,   248,   249,   249,   250,   250,   250,
+     250,   250,   251,   251,   251,   251,   252,   252,   252,   252,
+     253,   253,   253,   253,   253,   253,   253,   253,   253,   253,
+     253,   253,   253,   253,   253,   253,   253,   253,   253,   253,
+     253,   253,   254,   254,   254,   254,   254,   254,   254,   254,
+     255,   255,   255,   255,   255,   255,   255,   255,   255,   255,
+     255,   255,   255,   256,   256,   256,   256,   256,   256,   256,
+     256,   256,   256,   256,   256,   256,   256,   256,   257,   257,
+     257,   257,   257,   257,   257,   257,   258,   258,   258,   258,
+     259,   259,   259,   260,   260,   261,   261,   262,   262,   262,
+     263,   264,   264,   264,   264,   265,   265,   265,   265,   265,
+     265,   265,   265,   266,   267,   268,   268,   269,   269,   269,
+     269,   269,   269,   269,   269,   269,   269,   269,   269,   269,
+     269,   271,   270,   270,   272,   272,   273,   274,   275,   275,
+     276,   276,   277,   277,   278,   278,   278,   278,   278,   279,
+     280,   280,   281,   281,   282,   283,   283,   284,   284,   284,
+     284,   284,   284,   284,   284,   285,   285,   285,   285,   285,
+     285,   285,   285,   285,   285,   286,   286,   286,   286,   286,
+     286,   286,   286,   286,   286,   286,   287,   287,   287,   287,
+     287,   287,   287,   287,   288,   288,   288,   288,   288,   288,
+     288,   288,   288,   288,   288,   288,   288,   288,   288,   288,
+     288,   288,   288,   288,   288,   288,   288,   288,   288,   289,
+     289,   290,   292,   291,   291,   293,   293,   295,   294,   296,
+     294,   297,   297,   297,   298,   298,   298,   298,   299,   299,
+     299,   300,   300,   300,   301,   301,   302,   302,   303,   303,
+     303,   303,   304,   304,   305,   305,   306,   306,   306,   306,
+     306,   306,   307,   307,   307,   308,   308,   309,   309,   309,
+     309,   309,   309,   310,   310,   311,   311,   311,   311,   312,
+     312,   313,   314,   314,   314,   315,   315,   315,   316,   316,
+     317,   317,   317,   317,   317,   317,   317,   318,   318,   318,
+     318,   319,   319,   320,   320,   321,   321,   321,   321,   321,
+     321,   322,   322,   322,   322,   323,   323,   324,   324,   325,
+     325,   325,   326,   326,   327,   327,   327,   327,   327,   327,
+     328,   328,   329
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     3,     2,     3,     2,     5,     3,     2,
+       2,     2,     1,     1,     1,     1,     1,     1,     1,     2,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     0,     8,     5,     3,     5,     5,     9,     3,     3,
+       2,     2,     5,     2,     5,     2,     4,     1,     1,     7,
+       7,     5,     0,     7,     1,     1,     2,     2,     1,     5,
+       5,     5,     3,     4,     3,     7,     8,     5,     3,     1,
+       1,     3,     1,     4,     7,     6,     1,     1,     7,     9,
+       8,    10,     5,     7,     6,     8,     1,     1,     5,     4,
+       5,     7,     1,     3,     6,     6,     8,     1,     2,     3,
+       1,     2,     3,     6,     5,     9,     2,     1,     1,     1,
+       0,     6,     1,     6,    10,     1,     6,     9,     1,     5,
+       1,     1,     1,     1,     1,     1,     1,     1,     2,     1,
+      12,    14,     8,     1,     1,     1,     1,     1,     0,     3,
+       1,     2,     2,     2,     1,     5,     8,    11,     6,     1,
+       1,     1,     1,     1,     1,     0,    10,     0,     8,     1,
+       4,     4,     0,     6,     3,     6,     4,     7,     1,     1,
+       1,     1,     1,     1,     1,     2,     1,     2,     1,     3,
+       1,     3,     4,     0,     6,     0,     5,     5,     2,     0,
+       0,     7,     1,     1,     0,     3,     1,     1,     1,     1,
+       1,     1,     1,     1,     3,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     2,     2,     6,     6,     7,
+       8,     8,     8,     9,     7,     5,     2,     2,     2,     2,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     2,     4,     2,     2,     4,     2,     5,     1,     1,
+       1,     1,     1,     2,     1,     1,     2,     2,     1,     1,
+       1,     1,     1,     1,     2,     2,     2,     2,     1,     2,
+       2,     2,     2,     1,     1,     2,     1,     3,     4,     1,
+       2,     7,     1,     1,     2,     2,     1,     2,     1,     3,
+       1,     1,     1,     2,     1,     3,     1,     2,     5,     2,
+       2,     1,     2,     2,     1,     5,     1,     1,     5,     1,
+       2,     3,     3,     1,     2,     2,     3,     4,     5,     4,
+       3,     4,     4,     2,     3,     3,     4,     5,     6,     6,
+       5,     5,     1,     2,     3,     4,     5,     3,     4,     4,
+       1,     2,     4,     4,     4,     5,     6,     5,     6,     3,
+       4,     4,     5,     1,     2,     2,     2,     3,     3,     1,
+       2,     2,     1,     1,     2,     3,     3,     4,     3,     4,
+       2,     3,     3,     4,     5,     3,     3,     2,     2,     1,
+       1,     2,     1,     1,     1,     1,     2,     1,     1,     1,
+       1,     2,     1,     2,     3,     1,     1,     1,     2,     1,
+       1,     2,     1,     4,     1,     1,     2,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     0,     2,     1,     1,     1,     1,     1,     1,     1,
+       1,     2,     1,     1,     1,     2,     3,     4,     1,     3,
+       1,     2,     1,     3,     1,     1,     1,     3,     6,     3,
+       6,     3,     6,     3,     6,     1,     1,     1,     5,     6,
+       4,     2,     1,     1,     1,     1,     1,     3,     4,     5,
+       5,     5,     6,     6,     2,     2,     1,     1,     1,     1,
+       1,     1,     1,     1,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     5,     5,
+       3,     3,     3,     5,     2,     2,     2,     2,     2,     1,
+       1,     1,     0,     3,     1,     1,     3,     0,     4,     0,
+       6,     1,     1,     1,     1,     1,     2,     2,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       2,     2,     1,     1,     1,     1,     4,     1,     1,     5,
+       2,     4,     1,     1,     2,     1,     1,     3,     3,     4,
+       4,     3,     4,     2,     1,     1,     3,     2,     4,     2,
+       2,     3,     1,     1,     1,     1,     1,     1,     1,     1,
+       2,     4,     1,     3,     1,     2,     3,     3,     2,     2,
+       2,     1,     2,     1,     3,     2,     4,     1,     3,     1,
+       3,     3,     2,     2,     2,     2,     1,     2,     1,     1,
+       1,     1,     3,     1,     3,     5,     1,     3,     3,     5,
+       1,     1,     0
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint16 yydefact[] =
+{
+     632,     0,     0,     0,     0,     0,    12,     4,   582,   417,
+     425,   418,   419,   422,   423,   420,   421,   407,   424,   406,
+     426,   409,   427,   428,   429,   430,   292,   397,   398,   399,
+     539,   540,   150,   534,   535,     0,   583,   584,     0,     0,
+     594,     0,     0,   293,     0,     0,   395,   632,   402,   412,
+     405,   414,   415,   538,     0,   601,   410,   592,     6,     0,
+       0,   632,     1,    17,    68,    64,    65,     0,   269,    16,
+     264,   632,     0,     0,    86,    87,   632,   632,     0,     0,
+     268,   270,   271,     0,   272,     0,   273,   278,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    10,    11,     9,    13,    20,    21,    22,    23,
+      24,    25,    26,    27,   632,    28,    29,    30,    31,    32,
+      33,    34,     0,    35,    36,    37,    38,    39,    40,    14,
+     117,   122,   119,   118,    18,    15,   159,   160,   161,   162,
+     163,   164,   125,   265,     0,   283,   152,   151,   536,   537,
+       0,     0,     0,   632,   595,   294,   408,   295,     3,   401,
+     396,   632,     0,   431,     0,     0,   594,   373,   372,   389,
+       0,   314,   290,   632,   323,   632,   369,   363,   350,   311,
+     403,   416,   411,   602,     0,     0,   590,     5,     8,     0,
+     284,   632,   286,    19,     0,   616,   281,     0,   263,     0,
+       0,   623,     0,     0,   400,   601,     0,   632,     0,     0,
+      82,     0,   632,   276,   280,   632,   274,   236,   277,   275,
+     282,   279,     0,     0,   195,   601,     0,     0,    66,    67,
+       0,     0,    55,    53,    50,    51,   632,     0,   632,     0,
+     632,   632,     0,   116,   632,   135,   134,   136,   632,     0,
+     139,   133,     0,   137,     0,     0,     0,     0,     0,   323,
+       0,   350,   267,   266,     0,   632,     0,   632,     0,     0,
+     596,   603,   593,     0,   582,   618,   473,   474,   486,   487,
+     488,   489,   490,   491,   492,   493,     0,     0,     0,     0,
+       0,     0,     0,     0,   301,     0,   296,   632,   456,   400,
+       0,   466,   475,   455,   465,   476,   467,   472,   298,   404,
+     632,   373,   372,     0,     0,   363,   410,     0,   333,   350,
+     309,   436,   437,   307,     0,   433,   434,   435,   380,     0,
+     455,   310,     0,   632,     0,     0,   325,   371,   342,     0,
+     324,   370,   387,   388,   351,   312,   632,     0,   313,   632,
+       0,     0,   366,   365,   320,   364,   342,   374,   600,   599,
+     598,     0,     0,   285,   289,   586,   585,     0,   587,     0,
+       0,   615,   120,   626,     0,    72,    49,    48,   632,   323,
+     431,    74,     0,   542,   543,   541,   544,     0,   545,     0,
+      78,     0,     0,     0,   102,     0,     0,   191,     0,   632,
+       0,   193,     0,     0,   107,     0,     0,     0,   111,   316,
+     323,   317,   319,    44,     0,   108,   110,   588,     0,   589,
+      58,     0,    57,     0,     0,   184,   632,   188,   538,   186,
+       0,   174,   138,     0,     0,     0,     0,   585,     0,     0,
+       0,     0,   632,     0,     0,   342,     0,   632,   350,   632,
+     601,   439,   632,   632,   522,     0,   521,   411,   524,   413,
+       0,   591,     0,     0,     0,     0,   475,     0,     0,     0,
+     471,   484,   514,   515,   485,   517,   516,   581,     0,   297,
+     300,   518,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   617,   373,   372,   363,   410,     0,     0,   385,
+     382,   366,   365,     0,   350,   374,     0,   432,   381,   632,
+     363,   410,   335,   343,   632,     0,   334,   386,     0,   359,
+       0,     0,   378,     0,   330,     0,   322,   368,     0,   321,
+     367,   376,     0,     0,     0,   326,   375,   597,     7,     0,
+     632,     0,     0,   176,   632,     0,     0,   622,     0,   632,
+       0,    73,     0,    81,     0,     0,     0,     0,     0,     0,
+       0,   192,   632,     0,     0,   632,   632,     0,     0,   112,
+       0,   632,   632,     0,     0,     0,     0,     0,   172,     0,
+     185,   190,   187,   632,    62,     0,     0,     0,     0,    83,
+       0,     0,     0,   557,   548,   549,   394,   393,   562,   392,
+     390,   558,   563,   565,     0,   566,     0,     0,     0,   154,
+       0,   410,   632,   632,   167,   171,   554,   632,   555,   604,
+       0,   461,   457,   477,     0,     0,     0,   389,     0,     0,
+     632,     0,     0,   632,   511,   510,   506,   507,   512,     0,
+     505,   504,   500,   501,   499,   503,   502,   495,   494,   498,
+     497,   496,   463,   459,     0,   374,   354,   353,   352,   376,
+       0,     0,   375,     0,     0,     0,   342,   344,   374,     0,
+     347,     0,   361,   360,   383,   379,   332,   331,     0,     0,
+       0,   327,   377,   336,     0,     0,   329,   632,   287,    70,
+      71,    69,   632,     0,   627,   628,   631,   630,   624,    46,
+       0,    45,    41,    80,    77,    79,   621,    97,   620,     0,
+      92,   632,   619,    96,     0,   630,     0,     0,   103,   632,
+     235,     0,   196,   197,     0,   264,     0,     0,    54,    52,
+     632,    43,     0,   109,     0,   609,   607,     0,    61,     0,
+       0,   114,     0,   632,   632,     0,   632,     0,   632,     0,
+       0,   361,   632,     0,   560,   551,   550,   564,   391,     0,
+     143,   632,   153,   155,   632,   632,     0,   132,   546,   523,
+     525,   527,   547,     0,     0,   632,   632,   632,   478,     0,
+       0,     0,   389,   388,     0,     0,     0,     0,     0,   470,
+     632,   299,     0,   632,   632,   355,   357,     0,     0,   308,
+     362,   345,     0,   349,   348,   315,   384,   337,     0,     0,
+     328,   341,   340,   288,     0,   121,     0,     0,   361,     0,
+     632,     0,     0,     0,     0,     0,    94,   632,     0,   123,
+     194,   263,     0,   601,   105,     0,   104,     0,   361,     0,
+       0,     0,   605,   632,     0,    56,     0,   264,     0,   178,
+     179,   182,   181,   173,   180,   183,     0,   189,   175,     0,
+       0,    85,     0,     0,   632,   144,     0,   145,   440,   442,
+     448,     0,   444,   443,   632,   431,   563,   632,   158,   131,
+       0,   128,   130,   126,   632,   532,   531,   533,     0,   529,
+     204,   223,     0,     0,     0,     0,   270,   632,     0,   248,
+     249,   241,   250,   221,   202,   246,   242,   240,   243,   244,
+     245,   247,   222,   218,   219,   206,   213,   212,   216,   215,
+       0,   224,     0,   207,   208,   211,   217,   209,   210,   220,
+       0,   283,   165,   291,     0,   455,   304,     0,   508,   481,
+     480,   479,     0,     0,   509,   468,     0,   513,     0,     0,
+     356,   358,   346,   339,   338,   177,   629,   625,   632,     0,
+       0,    88,   630,    99,    93,   632,     0,     0,   101,     0,
+      75,     0,   113,   318,   610,   608,   614,   613,   612,     0,
+      59,    60,     0,   632,     0,     0,     0,    63,    84,   556,
+     561,   552,   632,   553,   632,   146,     0,   441,     0,   632,
+     450,   452,     0,   632,   445,     0,     0,     0,     0,     0,
+     574,   632,   526,   632,   632,     0,   199,   238,   237,   239,
+       0,   225,     0,     0,   226,   198,   407,   406,   409,     0,
+     405,   410,     0,   462,     0,   303,   306,   458,   483,   482,
+     469,   464,   460,     0,    42,     0,   100,     0,    95,   632,
+      90,    76,   106,   606,   611,     0,   632,     0,     0,   632,
+     559,     0,     0,   148,   147,   142,   451,   449,     0,   156,
+     632,   632,   446,     0,   571,     0,   573,   575,     0,   567,
+     568,   632,   519,   528,   520,     0,   205,     0,     0,   632,
+     169,   168,   632,     0,   214,     0,   455,    47,    98,    89,
+       0,   115,     0,   172,   632,     0,     0,     0,     0,   127,
+     632,     0,   453,   454,   632,   447,   569,   570,   572,     0,
+     577,   579,   580,     0,   632,     0,   632,     0,   632,     0,
+       0,   305,    91,   124,     0,   632,   632,   632,     0,   632,
+       0,   149,     0,   576,   129,   530,   200,     0,   632,     0,
+     257,   166,   632,     0,     0,     0,   632,   227,     0,     0,
+     157,   578,     0,   632,   228,     0,   170,   234,     0,   632,
+     632,   632,     0,     0,   140,   201,   229,   251,   253,     0,
+     254,   256,   431,   232,   231,   230,   632,     0,     0,     0,
+     233,   141,   252,   255
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     4,     5,   104,   105,   106,   829,   909,   910,   911,
+     912,   111,   420,   421,   913,   914,   756,   114,   115,   915,
+     117,   916,   119,   917,   714,   209,   918,   122,   919,   720,
+     567,   920,   393,   921,   403,   239,   415,   240,   922,   923,
+     924,   925,   554,   130,   893,   776,   249,   131,   771,   876,
+    1006,  1075,  1121,    42,   618,   132,   133,   134,   135,   926,
+    1042,   783,  1101,   927,   928,   753,   863,   424,   425,   426,
+     590,   929,   140,   575,   399,   930,  1097,  1172,  1025,   931,
+     932,   933,   934,   935,   936,   142,   937,   938,  1174,  1177,
+     939,  1039,   143,   940,   313,   190,   363,    43,   191,   295,
+     296,   479,   297,   944,  1045,   777,   172,   408,   173,   336,
+     259,   175,   176,   260,   608,   609,    45,    46,   298,   204,
+      48,    49,    50,    51,    52,   323,   324,   365,   326,   327,
+     449,   879,   880,   881,   882,  1009,  1010,  1122,   300,   301,
+     302,   330,   304,   305,  1093,   455,   456,   623,   779,   780,
+     898,  1024,   899,    53,    54,   386,   387,   781,   611,  1002,
+     627,   612,   613,  1178,   888,  1019,  1086,  1087,   183,    55,
+     373,   418,    56,   186,    57,   272,   747,   852,   306,   307,
+     723,   200,   374,   708,   192
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -1090
+static const yytype_int16 yypact[] =
+{
+     674,  4663,  4768,    51,    86,  4097, -1090, -1090, -1090, -1090,
+   -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090,
+   -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090,
+   -1090, -1090,   398,    30,    61,   150, -1090, -1090,    62,   109,
+     197,  5491,   195,    95,   302,  5778,   693,   403,   693, -1090,
+   -1090, -1090,  3190, -1090,   195,   197, -1090,   196, -1090,   315,
+     333,  5084, -1090,   263, -1090, -1090, -1090,   356, -1090, -1090,
+      48,   380,  5161,   415, -1090, -1090,   380,   438,   445,   458,
+     378, -1090, -1090,   488,   406,   509,   451,   249,   136,   320,
+     513,   303,   517,   599,   600,  5563,  5563,   539,   556,   399,
+     580,  5849, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090,
+   -1090, -1090, -1090, -1090,   380, -1090, -1090, -1090, -1090, -1090,
+   -1090, -1090,  1398, -1090, -1090, -1090, -1090, -1090, -1090, -1090,
+   -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090,
+   -1090, -1090, -1090,    36,  5635, -1090, -1090, -1090, -1090, -1090,
+     195,   234,   423,  2309, -1090, -1090, -1090, -1090, -1090,   693,
+   -1090,  3682,   875,   214,  2575,  3367,    53,  1024,  1194,    46,
+     195, -1090, -1090,   165,   334,   165,   360,   114,   512, -1090,
+   -1090, -1090, -1090, -1090,   133,   541, -1090, -1090, -1090,   612,
+   -1090,   617, -1090, -1090,   946, -1090, -1090,  6049,    58,   946,
+     946, -1090,    89,  1869, -1090,   179,   456,   350,   133,   133,
+   -1090,   946,  4979, -1090, -1090,  5084, -1090, -1090, -1090, -1090,
+   -1090, -1090,   195,   555, -1090,   191,   633,   133, -1090, -1090,
+     946,   133, -1090, -1090, -1090,   681,  5084,   643,  1035,   657,
+     670,   946,   399,   681,  5084, -1090, -1090, -1090,  5084,   195,
+   -1090, -1090,   195,   581,   399,  1805,   240,  2026,   946,   467,
+    1406,   615, -1090, -1090,  1869,   195,  1903,   431,   678,   133,
+   -1090, -1090,   196,   631,    47, -1090, -1090, -1090, -1090, -1090,
+   -1090, -1090, -1090, -1090, -1090, -1090,  3367,  1645,  3367,  3367,
+    3367,  3367,  3367,  3367, -1090,   642, -1090,   710,   719,   339,
+    2675,   123, -1090,    25, -1090, -1090,   681,   765, -1090, -1090,
+    3801,   527,   527,   735,   753,  1937,   675,   142,   467, -1090,
+   -1090, -1090, -1090,   743,  3367, -1090, -1090, -1090, -1090,  6042,
+   -1090,  2675,   766,  3801,  1309,   195,   473,   360, -1090,  1309,
+     473,   360, -1090,   694, -1090, -1090,  5084,  2707, -1090,  5084,
+    2839,  1309,  1665,  1688,   473,   360,   697,  1412, -1090, -1090,
+     196,   790,  4873, -1090, -1090, -1090, -1090,   795,   681,   195,
+     195, -1090, -1090,   393,   798, -1090, -1090, -1090,   165,   483,
+     559, -1090,   803, -1090, -1090, -1090, -1090,   195, -1090,   809,
+     796,   593,   818,   820, -1090,   822,   821, -1090,  5707, -1090,
+     195, -1090,   826,   831, -1090,   835,   839,  5563, -1090, -1090,
+     528, -1090, -1090, -1090,  5563, -1090, -1090, -1090,   840, -1090,
+   -1090,   654,   366,   843,   791, -1090,   856, -1090,   286, -1090,
+     860, -1090, -1090,   158,   875,   875,   875,   265,   783,   865,
+     227,   868,  5084,  2101,  2106,   799,  1430,  2161,    52,   836,
+     313, -1090,  3920,  2161, -1090,   872, -1090,   355, -1090, -1090,
+     197, -1090,   423,   911,   919,  2544,   819,    47,  5418,   889,
+   -1090,  2944, -1090, -1090, -1090, -1090, -1090, -1090,  2309, -1090,
+   -1090, -1090,  3367,  3367,  3367,  3367,  3367,  3367,  3367,  3367,
+    3367,  3367,  3367,  3367,  3367,  3367,  3367,  3367,  3367,  3367,
+     932,   933, -1090,   544,   544,  1800,   823,   448,   498, -1090,
+   -1090,   544,   544,   520,   824,  1274,  3367,  2675, -1090,  5084,
+    1981,    37,   473, -1090,  5084,  2971,   473, -1090,   898, -1090,
+    6075,   899, -1090,  6087,   473,  1309,   473,   360,  1309,   473,
+     360,   384,  1309,   894,  2124,   473, -1090, -1090, -1090,  5084,
+     617,   273,   907, -1090, -1090,   946,  2337, -1090,   908,  5084,
+     914, -1090,   904, -1090,   607,  1227,  2404,   917,  5084,  1869,
+     915, -1090,  1035,  4212,   921, -1090,   925,  5563,   425,   920,
+     923,  5084,   670,   534,   924,   946,  5084,    81,   879,  5084,
+   -1090, -1090, -1090,  5084, -1090,  1274,  1585,  1309,    65, -1090,
+     931,  1970,   938,   171,   888,   891, -1090, -1090,   601, -1090,
+     540, -1090, -1090, -1090,   870, -1090,   929,  5778,   663, -1090,
+     947,   783,   165,   912, -1090, -1090, -1090,   930, -1090, -1090,
+     195,   954,   958,  3367,  3367,  3103,  3235,  3499,   173,  3367,
+     403,   959,  5707,   710,  1370,  1370,  2150,  2150,  1946,  2805,
+    3069,  3201,  2166,  2813,  2944,   752,   752,   688,   688, -1090,
+   -1090, -1090,   974,   975,   824,   693, -1090, -1090, -1090,   544,
+     977,   978,  1035,  6129,   979,   525,   824, -1090,   218,   981,
+   -1090,  6141,   199, -1090,   199, -1090,   473,   473,  1309,   967,
+    2139,   473,   360,   473,  1309,  1309,   473,   617, -1090, -1090,
+   -1090,   681,  5084,  4327, -1090,   987, -1090,   366,   990, -1090,
+     993, -1090, -1090, -1090, -1090,   681, -1090, -1090, -1090,   995,
+   -1090,  2161,   681, -1090,   984,   281,   698,  1227, -1090,  2161,
+   -1090,   997, -1090, -1090,  4442,    57,  5707,   672, -1090, -1090,
+    5084, -1090,  1002, -1090,   902, -1090,   321,   943, -1090,  1007,
+    1003, -1090,   195,  1033,   856,  1008, -1090,  1035,  2161,   365,
+    1309, -1090,  5084,  3367, -1090, -1090, -1090, -1090, -1090,  3758,
+   -1090,   951, -1090, -1090,   994,  2701,   444, -1090, -1090,  1014,
+   -1090,   852, -1090,  2454,  1012,   165,  3367,  3367,  2675,  3772,
+    3367,  3367,  3499,  3991,  3367,  1020,  1022,  4734,  1026, -1090,
+     403, -1090,  3367,  3367,  3367, -1090, -1090,  1027,  1028, -1090,
+   -1090, -1090,   530, -1090, -1090, -1090, -1090,   473,  1309,  1309,
+     473,   473,   473, -1090,  1029, -1090,   946,   946,   199,  2454,
+    5084,    81,  2337,  1630,   946,  1030, -1090,  2161,  1031, -1090,
+   -1090,   681,  1869,    27, -1090,  5563, -1090,  1037,   199,    71,
+     133,   118, -1090,  2309,   318, -1090,  1010,    48,  5949, -1090,
+   -1090, -1090, -1090, -1090, -1090, -1090,  5233, -1090, -1090,  4557,
+    1043, -1090,  1046,  4839,   679, -1090,    29, -1090,   994, -1090,
+      59,  1042,    31, -1090,  5084,   559,  1021,  1013, -1090, -1090,
+    1869, -1090, -1090, -1090,   912, -1090, -1090, -1090,   195, -1090,
+   -1090, -1090,  1050,  1015,  1044,  1051,   957,  3581,   133, -1090,
+   -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090,
+   -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090, -1090,
+    1054,   976,  2454, -1090, -1090, -1090, -1090, -1090, -1090, -1090,
+    5306,  1057, -1090, -1090,  1064,   767, -1090,  1067, -1090,  2675,
+    2675,  2675,  3367,  3367, -1090, -1090,  1069,  2937,  1082,  1086,
+   -1090, -1090, -1090,   473,   473, -1090, -1090, -1090,   165,  1084,
+    1091, -1090,   681,  1094, -1090,  2161,  1650,    81, -1090,  1090,
+   -1090,  1100, -1090, -1090, -1090,   321, -1090, -1090,   321,  1032,
+   -1090, -1090,  5707,  5084,  1869,  5707,  1998, -1090, -1090,   679,
+   -1090, -1090,   165, -1090,  5084, -1090,   668, -1090,   133,   994,
+   -1090,  1089,  1745,   139, -1090,  1105,  1107,   559,   195,   680,
+   -1090,  2161, -1090,  1099,   912,  2454, -1090, -1090, -1090, -1090,
+     133, -1090,  1111,  1858, -1090, -1090,  1078,  1080,  1083,  1087,
+    1093,   270,  2454, -1090,  3367, -1090, -1090, -1090,  2675,  2675,
+   -1090, -1090, -1090,  1118, -1090,  1124, -1090,  1128, -1090,  2161,
+   -1090, -1090, -1090, -1090, -1090,  1131,  1035,  1079,   141,  3920,
+   -1090,   444,  1142, -1090, -1090, -1090, -1090, -1090,  3367, -1090,
+    2161,   994, -1090,   682, -1090,  1145,  1148,  1146,   385, -1090,
+   -1090,   165, -1090, -1090, -1090,   195, -1090,  2454,  1154,  5084,
+   -1090, -1090,  2161,  3367, -1090,  1151,   767, -1090, -1090, -1090,
+    1162, -1090,  1164, -1090,  5084,  1170,  1173,    19,  1176, -1090,
+    2161,  1171, -1090,  2675,   165, -1090, -1090, -1090, -1090,   195,
+   -1090, -1090, -1090,   444,  1099,  1172,  5084,  1180,   165,  4945,
+    1858, -1090, -1090, -1090,  1181,  5084,  5084,  5084,  1184,  2701,
+      15, -1090,   444,  1178, -1090, -1090, -1090,  1187,  2161,   444,
+   -1090, -1090,  2161,  1188,  1198,  1199,  5084, -1090,  5707,   668,
+   -1090, -1090,  2454,  2161, -1090,   548, -1090, -1090,   595,  2161,
+    2161,  2161,  1200,  1179, -1090, -1090, -1090, -1090, -1090,   559,
+   -1090, -1090,   559, -1090, -1090, -1090,  2161,   668,  1202,  1203,
+   -1090, -1090, -1090, -1090
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+   -1090, -1090,  -376, -1090, -1090, -1090, -1090,    -4,    28,    17,
+      34, -1090,   686, -1090,    85,    87, -1090, -1090, -1090,   104,
+   -1090,   107, -1090,   108, -1090, -1090,   111, -1090,   113,  -558,
+    -681,   115, -1090,   120, -1090,  -361,   665,   -81,   121,   128,
+     132,   137, -1090,   495,  -956,  -944,  -169, -1090, -1090, -1090,
+   -1078, -1089, -1090,  -120, -1090, -1090, -1090, -1090, -1090,    14,
+   -1090, -1090,   110,    43,    79, -1090, -1090,   258, -1090,   664,
+     500,   143, -1090, -1090, -1090,  -797, -1090, -1090, -1090,   348,
+   -1090,   505, -1090,   506,   182, -1090, -1090, -1090, -1090,  -271,
+   -1090, -1090, -1090,     4,    90, -1090,  -497,  1220,     6,   409,
+   -1090,   621,   787,  -304,   162,   -35,  -590,  -557,   390,  1619,
+     -21,  -145,    -1,   620,  -633,   659,    20, -1090,   -61,    40,
+     -20,   -95,   -97,  1219, -1090,  -370, -1090,  -161, -1090, -1090,
+   -1090,   394,   266,  -958, -1090, -1090,   274, -1090,  1330, -1090,
+    -243,  -140,  -536, -1090,   140,   651, -1090, -1090, -1090,   387,
+   -1090, -1090, -1090,  -227,   -41, -1090, -1090,   259,  -576, -1090,
+   -1090,  -591, -1090,   491,   138, -1090, -1090,   157,   -22,  1359,
+    -112, -1090,  1041,  -241,  -148,  1103, -1090,  -253,  1639, -1090,
+     552,    98,  -190,  -528,     0
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -633
+static const yytype_int16 yytable[] =
+{
+       6,   107,   325,   271,   251,   145,   250,    44,    59,   144,
+     560,   203,   171,   303,   237,   731,   314,   767,   154,   136,
+     706,   428,   109,   573,   265,   159,   174,   764,   369,   751,
+     706,   461,   969,   108,   238,   238,   358,   271,   726,   110,
+     404,    47,    47,   466,   470,   835,   580,   179,   137,   815,
+     798,   816,    60,   698,   195,  1082,   332,   262,  1071,  1147,
+     252,  1005,     8,   195,   371,   439,   160,  -302,   180,  1004,
+     980,   201,  1169,  1013,     8,  1005,   201,   210,   677,   148,
+    1184,    47,   367,   266,   138,   716,    62,   195,   375,   376,
+     112,    61,   113,   411,   382,   463,    27,    28,    29,   391,
+     251,    47,   250,   267,   372,  1197,   677,   616,  1201,   116,
+     149,   273,   118,   120,   201,  1119,   121,     8,   123,   547,
+     124,     8,   263,  1125,   717,   125,   126,   718,  1168,   417,
+    -302,   153,   377,   127,   196,  1035,     8,   128,   345,     8,
+     348,   318,   129,   196,   154,     8,   441,  1133,   139,    36,
+      37,   189,  1148,   308,   333,   678,   370,   153,  1014,   294,
+     464,    36,    37,   351,   371,   314,   337,   341,   197,   836,
+     446,   500,   164,   179,   207,   179,   355,  1154,   703,   309,
+    1152,  1114,   379,   760,   886,  1008,   169,   141,   314,   343,
+     150,   364,   984,   299,  1159,   968,  1170,   719,     8,   734,
+     823,    47,    72,  1176,    36,    37,   151,   388,    36,    37,
+     956,   763,   254,   152,   794,   983,   737,   410,   594,   325,
+     163,     8,   157,    36,    37,   641,    36,    37,  1096,   222,
+       8,    38,    36,    37,   380,    40,   501,     8,   412,   987,
+     416,   419,   165,     8,   352,  1105,   400,   353,   429,    27,
+      28,    29,    47,    38,   427,    47,   335,    40,   440,    38,
+     320,   604,   605,    40,   171,   451,  1081,   458,    27,    28,
+      29,  1115,   434,   971,  1116,   435,    47,   699,   174,   195,
+     440,   169,   169,   153,    47,    36,    37,   371,    47,   334,
+     507,   508,  1056,   220,   513,   153,   706,   480,  1001,   179,
+    1135,   153,   394,   795,   973,   395,   796,   228,    36,    37,
+     337,   341,    38,  1104,   355,   184,    40,    36,    37,   700,
+     321,   322,   990,     8,    36,    37,   406,   221,  -632,   606,
+      36,    37,   607,   582,   423,    38,  -587,   572,   303,    40,
+     185,   163,     8,   558,    38,   158,   238,  -262,    40,   229,
+      47,   537,   540,   238,   269,   270,  -438,    38,   187,  -438,
+     335,    40,   428,   165,   991,   704,   224,   169,   550,   153,
+     671,   371,   371,    47,   346,  1185,   188,   546,   179,   161,
+     869,  -632,   335,  -601,  -601,   193,    47,     8,   162,    47,
+    -438,  -632,   347,   592,   163,   749,   194,   164,   625,     6,
+     349,  -632,    47,   383,   384,   195,     8,   640,   871,  -601,
+      36,    37,   586,   507,   508,   513,   165,   153,   350,  1060,
+     199,   630,   385,  1070,   333,  1131,   591,   411,   179,    36,
+      37,  1132,  -632,   688,     8,   555,   528,    38,   629,   531,
+     850,    40,   164,   161,  -632,   889,   626,   615,   556,   619,
+     671,   146,   162,   615,   724,   206,    38,   628,   163,     8,
+     166,   164,   195,   213,   214,   851,  -632,   610,   738,   167,
+     147,   739,   168,   610,    36,    37,    30,    31,   208,   169,
+     165,   170,    47,   947,   294,   211,   890,   891,   442,   666,
+     892,   216,    47,    36,    37,    33,    34,   381,   212,   958,
+     959,    38,   337,   341,   355,    40,   347,   442,   454,  1112,
+     537,   540,   258,   524,   689,  1016,   238,   690,   299,   355,
+      38,    36,    37,   559,   166,   347,   335,   808,   215,   218,
+       8,   525,   600,   167,   219,   672,   168,     8,   442,   667,
+     692,   347,   620,   169,     8,   170,    36,    37,    38,   217,
+     364,   410,    40,   227,     6,   697,   347,   230,   886,    47,
+     442,   668,   321,   322,    47,   524,   811,   161,   581,   107,
+     524,   962,   412,   145,   728,     6,   145,   144,   347,   241,
+     736,   800,   416,   525,   310,   164,   347,   136,   525,    47,
+     109,  1187,   750,   378,  1188,   427,   242,   772,   397,    47,
+     874,   108,   164,  1189,   234,   171,   195,   110,    47,   674,
+     398,   713,   808,   195,   679,   757,   137,    36,    37,   174,
+     244,    47,   179,   782,    36,    37,    47,   458,   409,    47,
+     357,    36,    37,    47,   565,   566,   966,   967,  1190,   231,
+     179,  1191,   232,   480,    38,   233,   945,   945,   166,   710,
+    1192,   744,   138,   361,   447,   745,   453,   793,   112,   362,
+     113,   269,   359,   945,   945,   321,   322,   177,   692,   170,
+     606,   742,   251,   607,   250,   842,   716,   116,   195,   401,
+     118,   120,   602,   755,   121,   546,   123,   371,   124,   407,
+     603,   604,   605,   125,   126,   584,   585,   364,   546,   107,
+     413,   127,   610,   145,   610,   128,   773,   144,  1073,   774,
+     129,  1074,   414,   303,   432,   844,   139,   136,   718,   459,
+     109,   615,   724,  1089,   325,  1126,  1090,   845,  1127,   615,
+     107,   108,  1063,   446,   145,  1064,   462,   110,   144,   833,
+     834,   610,    47,    27,    28,    29,   137,   477,   136,   610,
+     943,   109,   478,   145,   591,   141,     6,   866,   615,   481,
+    1032,   251,   108,   250,   981,   171,   428,   860,   110,   604,
+     605,   877,   502,   159,   883,   615,   509,   137,   610,   174,
+      47,   315,   138,   941,   238,   179,   946,   946,   112,   342,
+     113,   878,   824,   515,   510,   610,   861,     1,     2,     3,
+     179,   516,    47,   946,   946,   996,   519,   116,  -632,  1044,
+     118,   120,   793,   138,   121,   541,   123,   252,   124,   112,
+     265,   113,  1199,   125,   126,   267,   497,   498,   499,   941,
+     847,   127,   862,   548,   169,   128,   551,   615,   116,   557,
+     129,   118,   120,  1040,   561,   121,   139,   123,   610,   124,
+     563,   564,   872,   308,   125,   126,  1085,   610,   177,   294,
+     568,   569,   127,   570,   571,   107,   128,   576,   610,   145,
+      47,   129,   577,   144,  1003,   436,   578,   139,     8,   996,
+     579,   583,  1098,   136,   587,   141,   109,  1020,   495,   496,
+     497,   498,   499,   299,   782,   878,   588,   108,   589,   267,
+     593,   595,  1186,   110,  1106,   670,   596,   145,  1193,  1194,
+    1195,   599,   137,   617,   631,   317,   141,   601,   624,   177,
+     970,   411,   632,   639,    47,  1200,   895,   896,   897,   642,
+     505,  1066,   941,  1053,  1068,   662,   663,   436,   614,   682,
+     684,   665,   669,   694,   622,  1046,    68,   702,   138,     8,
+     712,   709,   195,   520,   112,   721,   113,   711,   727,   729,
+     740,   730,   409,   527,   733,    36,    37,   748,   179,   735,
+     741,   752,   761,   116,  1015,   615,   118,   120,   762,   765,
+     121,   766,   123,   769,   124,   670,   758,   770,   775,   125,
+     126,   778,    38,   429,   786,   610,   166,   127,   787,   427,
+     799,   128,   179,    80,    81,    82,   129,   454,    84,   883,
+      86,    87,   139,   883,   803,   804,   818,   170,   805,   806,
+     810,   615,   813,  1094,   782,   941,   878,     8,  1198,   826,
+     878,   325,   827,    47,   828,   830,    36,    37,     8,   832,
+     839,   610,   941,   848,    47,   410,   849,   853,   854,   868,
+     855,   141,   321,   322,    68,   875,   894,    72,   942,   615,
+     597,   952,   807,   953,   333,   992,   412,   955,   960,   961,
+     965,   976,   436,   334,   978,   161,  1017,   857,   982,   610,
+     615,   883,   164,   156,   162,   638,   998,   999,   178,  1012,
+    1018,   179,  1027,   164,  1072,   182,  1026,   941,   878,  1030,
+     610,  1033,   615,  1034,  -203,  1043,  1046,  1183,  1047,    47,
+    1050,    80,    81,    82,    36,    37,    84,   837,    86,    87,
+     615,  1028,   610,  1051,   179,    36,    37,  1052,  1029,   223,
+     226,  1054,  1055,  1061,  1094,   177,   834,  1065,   179,    47,
+     610,    38,   253,  1062,  1078,    40,  1083,   807,  1092,   615,
+    1084,  1099,    38,   858,    47,  -260,   166,  -259,   615,  1118,
+    -261,  1107,   615,   261,  1103,   167,   335,  1108,   168,   610,
+    -258,  1109,   941,   615,  1111,   169,    47,   170,   610,   615,
+     615,   615,   610,  1120,  1113,    47,    47,    47,  1128,  1137,
+    1129,   268,   177,   610,  1136,  1130,   615,     8,  1140,   610,
+     610,   610,   316,   319,  1144,  1142,    47,  1143,   338,   338,
+    1145,   344,   831,  1146,  1151,   177,   610,  1149,   356,  1156,
+     838,  1158,  1162,   975,  1166,  1005,  1157,  1171,  1173,  1179,
+       8,   716,   979,   195,   333,  1163,  1164,  1165,   253,  1180,
+    1181,  1196,   705,   339,   261,  1202,  1203,   743,   859,   870,
+    1161,  1067,   164,   754,   867,  1031,  1182,   342,   864,   865,
+     177,   155,   989,   396,   801,   643,   887,   317,  1141,   768,
+     717,   181,  1007,   718,  1155,  1077,   162,     8,   784,   178,
+    1021,  1022,  1076,  1095,    36,    37,  1153,  1167,   360,   846,
+     430,     0,   177,   431,     0,     0,   438,   338,   338,     0,
+       0,   445,     0,     0,     0,   448,   156,   261,   457,     0,
+       0,    38,     8,     0,   161,    40,     0,    36,    37,     0,
+       0,     0,     0,   162,    27,    28,    29,     0,   977,     0,
+       0,     0,   164,     0,     0,     0,   335,     0,     0,     0,
+     178,     0,     0,   719,    38,     0,     0,     0,   166,   440,
+       0,   506,   319,   319,     0,     0,   514,   256,   438,     0,
+     257,     0,     0,     0,    36,    37,  1059,   169,     0,   170,
+       0,     0,     0,     0,   521,   338,   523,   177,     0,     0,
+     338,     0,     0,     0,   447,     0,   453,     0,     0,     0,
+       0,    38,   338,   338,   338,   166,     0,     0,   338,    36,
+      37,     8,  1080,     0,   167,     0,     0,   168,     0,     8,
+     552,   553,   342,   527,   169,     8,   170,     0,     0,     0,
+     177,     0,     0,  1102,     0,     0,    38,     0,   562,     0,
+      40,   205,     0,     8,     0,     0,     0,     0,   255,     0,
+       0,   574,     0,     0,     0,     0,   440,   162,   225,     0,
+       0,   335,   440,     0,     0,   351,   409,     0,     0,     0,
+       0,   542,    27,    28,    29,     0,  1057,     0,     0,     0,
+     440,     0,     0,     0,     0,   319,   319,   319,     0,   542,
+       0,   598,   486,     0,   338,   338,     0,   338,    36,    37,
+       0,     0,     0,   621,   329,   331,    36,    37,     0,     0,
+       0,     0,    36,    37,   493,   494,   495,   496,   497,   498,
+     499,     0,  1091,     0,     0,    38,     0,     0,     0,   166,
+      36,    37,     0,    38,     0,     0,     0,    40,   256,    38,
+    1102,   257,     0,    40,     0,     0,   443,     0,   169,   444,
+     170,     0,   543,     0,     0,   544,   664,    38,   335,     0,
+    1110,    40,     0,   366,   335,     0,   178,     0,   366,   366,
+     543,   676,     0,   544,     0,   366,     0,   389,   390,     0,
+     366,  1124,   335,     0,     0,     0,   338,     0,     0,   338,
+       0,     0,   338,   338,     0,   338,   402,     0,     8,   366,
+     405,   195,     0,  1138,     0,     0,     0,     0,     0,     0,
+     366,     0,     0,     0,     0,     0,   261,     0,     0,     0,
+     261,  1150,     0,   178,   437,     0,   465,   366,   471,   472,
+     473,   474,   475,   476,   450,   317,     0,     0,   460,     0,
+       0,     0,     0,     8,   162,     0,   178,   261,   338,     0,
+     887,     0,   338,     0,     0,     0,     0,     0,   467,  1175,
+       0,   195,   275,     8,   517,     0,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,     0,     0,     8,     0,
+     317,   785,     0,   974,     0,    36,    37,   530,     0,   162,
+     533,   178,     0,     0,     0,   468,   177,     0,  1117,   436,
+     317,     8,     0,  1058,   469,     0,     0,     0,     0,   162,
+       0,   287,    38,     0,     0,   333,   166,     0,     0,   198,
+       0,     0,     0,   178,   535,   256,     0,     0,   257,   338,
+      36,    37,     0,   164,     0,   169,     0,   170,   333,   338,
+       0,   338,     0,   235,     0,   338,   338,   538,   243,     0,
+      36,    37,     0,     0,     0,     0,   164,    38,     8,     0,
+       0,   166,     0,     0,     0,    36,    37,     0,     0,     0,
+     256,     0,     0,   257,     0,     0,     0,    38,   261,     0,
+     169,   166,   170,     0,     0,     0,     0,     0,    36,    37,
+     256,     0,    38,   257,     0,   317,    40,   340,  1079,     0,
+     169,     0,   170,   856,   162,     0,   354,     0,   178,     0,
+       0,   338,     0,     8,     0,    38,     0,   335,     8,    40,
+     253,   195,   644,   645,   646,   647,   648,   649,   650,   651,
+     652,   653,   654,   655,   656,   657,   658,   659,   660,   661,
+     335,     0,     0,   368,     0,    36,    37,     0,   368,   368,
+     310,   178,     0,     0,     0,   368,   673,     0,     0,     0,
+     368,     0,     0,     0,     0,   681,     0,     0,   164,   338,
+     338,     8,    38,     0,     0,     0,   166,     0,     0,   368,
+       0,     0,     8,     0,   261,   256,   340,     0,   257,   354,
+     368,   422,     0,   261,     0,   169,     0,   170,     0,     0,
+      36,    37,     0,   433,   368,    36,    37,   368,   317,   253,
+       0,  1100,     0,     0,     0,     0,     8,   162,     0,   317,
+       0,   321,   322,     0,   366,     0,     0,    38,   162,     0,
+       0,    40,    38,     0,     0,   366,    40,     0,     0,     0,
+     511,   261,     0,   512,     0,   434,     0,     0,   435,  1023,
+       8,     0,   746,   452,   366,   169,     0,     0,    36,    37,
+       0,     0,   162,   522,     0,     0,     0,     0,   526,    36,
+      37,     0,     0,   788,   789,   651,   654,   661,     0,   797,
+     534,   536,   539,     8,     0,    38,   545,   161,     0,   166,
+       0,  1041,     0,     0,     8,     0,    38,     0,   256,     0,
+     166,   257,     0,    36,    37,   164,     0,     0,   169,   256,
+     170,     8,   257,     0,     0,     0,     0,     0,     0,   169,
+     440,   170,     0,     0,     0,     0,     0,   261,     0,   688,
+      38,   333,     0,     0,   166,     0,     0,    36,    37,     8,
+       0,     0,     0,   256,     0,   261,   257,   261,  1069,   164,
+       0,     0,     0,   169,     0,   170,     0,   162,     0,     0,
+       0,     0,     0,   261,    38,     0,     0,     0,   166,  1088,
+      36,    37,   536,   539,     0,   545,   440,   511,     0,     0,
+     512,    36,    37,     0,   261,   339,     0,     0,     0,   170,
+     493,   494,   495,   496,   497,   498,   499,    38,    36,    37,
+       0,    40,     0,   873,     0,   843,     0,     0,    38,     0,
+     689,     0,    40,   690,     8,     0,     0,   178,     0,     8,
+     621,   511,   335,     0,   512,    38,    36,    37,     0,   166,
+     949,   950,   474,   335,   951,     0,     0,     8,   256,     0,
+       0,   257,   957,     0,     0,     0,  1134,     0,   169,   675,
+     170,   440,     8,    38,     0,     0,   440,    40,     0,     0,
+     535,     0,     0,     0,   686,   538,     0,   687,     0,     0,
+     691,   693,     0,   696,   440,     0,     0,     0,   335,     0,
+    1088,     0,     0,   695,     0,     0,     0,     0,     0,   440,
+       0,   261,     0,     0,     0,   366,   366,     0,   819,     0,
+     701,    36,    37,   366,   368,   707,    36,    37,     0,     0,
+       0,     0,     0,   715,   722,   725,     0,     0,   985,   986,
+     988,    27,    28,    29,    36,    37,   675,     0,    38,     0,
+     691,     0,    40,    38,   368,     0,   722,    40,     0,    36,
+      37,     0,     0,     0,     0,   759,     0,     0,     0,  1011,
+       0,    38,   602,   335,     0,    40,     0,     0,   335,     0,
+     603,   604,   605,     0,     0,     0,    38,     0,   482,   483,
+      40,     0,   486,     0,     0,     0,   335,     0,     0,     0,
+       0,     0,     0,     0,   482,   483,   484,   485,   486,     0,
+       0,   335,  1048,  1049,   493,   494,   495,   496,   497,   498,
+     499,   606,     0,     0,   607,     0,     0,   812,   491,   492,
+     493,   494,   495,   496,   497,   498,   499,   817,     0,   820,
+       0,     0,   274,   821,   822,   195,   275,     0,     0,     0,
+     276,   277,   278,   279,   280,   281,   282,   283,   284,   285,
+       0,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,   195,    21,    22,    23,    24,    25,   286,
+     278,   279,   280,   281,   282,   283,   284,   285,    26,    27,
+      28,    29,    30,    31,     0,   287,   722,  1011,     0,     0,
+       0,     0,     0,     0,   841,     0,   722,     0,     0,   812,
+      32,    33,    34,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    35,     0,     0,    36,
+      37,     0,     0,     0,     0,     0,     0,     8,  1123,     0,
+     195,     0,     0,     0,     0,     0,     0,   278,   279,   280,
+     281,   282,   283,   284,   285,     0,    38,     0,     0,    39,
+      40,     0,     0,  1139,     0,    41,     0,   963,   964,     0,
+       0,     0,   288,     0,     0,   289,   290,     0,     0,   291,
+     292,   293,     0,     0,     0,   900,     0,  -632,    64,     0,
+       0,     0,    65,    66,    67,   368,   368,     0,     0,     0,
+     722,   972,     0,   368,     0,    68,  -632,  -632,  -632,  -632,
+    -632,  -632,  -632,  -632,  -632,  -632,  -632,  -632,     0,  -632,
+    -632,  -632,  -632,  -632,    36,    37,   841,   901,    70,     0,
+       0,  -632,     0,     0,  -632,  -632,  -632,  -632,  -632,     0,
+     321,   322,     0,     0,     0,     0,     0,    72,    73,    74,
+      75,   902,    77,    78,    79,  -632,  -632,  -632,   903,   904,
+     905,     0,    80,   906,    82,     0,    83,    84,    85,    86,
+      87,  -632,  -632,     0,  -632,  -632,    88,     0,     0,     0,
+      92,     0,    94,    95,    96,    97,    98,    99,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,   100,
+       0,  -632,     0,     0,   101,  -632,  -632,     0,   274,     0,
+     907,   195,   275,     0,     0,   633,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,   908,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   286,   722,     0,     0,     0,
+       0,     0,     0,     0,     0,    27,    28,    29,    30,    31,
+       0,   287,     0,     0,   328,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    32,    33,    34,   634,
+       0,     0,   482,   483,   484,   485,   486,     0,   487,     0,
+       0,     0,    35,     0,     0,    36,    37,     0,     0,     0,
+       0,     0,     0,   488,   635,   490,   491,   636,   493,   494,
+     495,   496,   497,   498,   637,     0,     0,     0,     0,     0,
+       0,     0,    38,     0,     0,     0,    40,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,   288,     0,
+     274,   289,   290,   195,   275,   291,   292,   293,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,     0,     9,
+      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+      20,   884,    21,    22,    23,    24,    25,   286,     0,     0,
+       0,    27,    28,    29,     0,     0,   885,    27,    28,    29,
+      30,    31,     0,   287,     0,     0,   529,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    32,    33,
+      34,     0,   602,   482,   483,   484,   485,   486,     0,   487,
+     603,   604,   605,     0,    35,     0,     0,    36,    37,     0,
+       0,     0,     0,     0,   488,   489,   490,   491,   492,   493,
+     494,   495,   496,   497,   498,   499,     0,     0,     0,     0,
+       0,     0,     0,     0,    38,     0,     0,     0,    40,     0,
+       0,   606,     0,     0,   607,     0,     0,     0,     0,     0,
+     288,     0,   274,   289,   290,   195,   275,   291,   292,   293,
+     276,   277,   278,   279,   280,   281,   282,   283,   284,   285,
+       0,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,     0,    21,    22,    23,    24,    25,   286,
+       0,     0,   802,     0,     0,     0,     0,     0,     0,    27,
+      28,    29,    30,    31,     0,   287,     0,     0,   532,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      32,    33,    34,   482,   483,   484,   485,   486,     0,   487,
+       0,   482,   483,   484,   485,   486,    35,     0,     0,    36,
+      37,     0,     0,     0,   488,   489,   490,   491,   492,   493,
+     494,   495,   496,   497,   498,   499,   492,   493,   494,   495,
+     496,   497,   498,   499,     0,     0,    38,     0,     0,     0,
+      40,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   288,     0,   274,   289,   290,   195,   275,   291,
+     292,   293,   276,   277,   278,   279,   280,   281,   282,   283,
+     284,   285,     0,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,     0,    21,    22,    23,    24,
+      25,   286,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    27,    28,    29,    30,    31,     0,   287,     0,     0,
+     680,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    32,    33,    34,   482,   483,   484,   485,   486,
+       0,     0,   482,   483,   484,   485,   486,     0,    35,     0,
+       0,    36,    37,     0,     0,     0,   488,   489,   490,   491,
+     492,   493,   494,   495,   496,   497,   498,   499,   493,   494,
+     495,   496,   497,   498,   499,     0,     0,     0,    38,     0,
+       0,     0,    40,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,   288,     0,   274,   289,   290,   195,
+     275,   291,   292,   293,   276,   277,   278,   279,   280,   281,
+     282,   283,   284,   285,     0,     9,    10,    11,    12,    13,
+      14,    15,    16,    17,    18,    19,    20,     0,    21,    22,
+      23,    24,    25,   286,   790,     0,     0,     0,     0,     0,
+       0,     0,     0,    27,    28,    29,    30,    31,     0,   287,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    32,    33,    34,   482,   483,   484,
+     485,   486,     0,     0,     0,     0,     0,     0,     0,     0,
+      35,     0,     0,    36,    37,     0,     0,     0,     0,   489,
+     490,   491,   492,   493,   494,   495,   496,   497,   498,   499,
+       0,     0,     9,    10,    11,    12,    13,    14,    15,    16,
+      38,    18,     0,    20,    40,     0,    22,    23,    24,    25,
+       0,     0,     0,     0,     0,     0,   288,     0,   274,   289,
+     290,   195,   275,   291,   292,   293,   276,   277,   278,   279,
+     280,   281,   282,   283,   284,   285,     0,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   286,   791,     0,     0,     0,
+       0,     0,     0,     0,     0,    27,    28,    29,    30,    31,
+       0,   287,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    32,    33,    34,   482,
+     483,   484,   485,   486,     0,     0,     0,     0,     0,     0,
+       0,     0,    35,     0,     0,    36,    37,     0,     0,     0,
+       0,     0,   490,   491,   492,   493,   494,   495,   496,   497,
+     498,   499,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    38,     0,     0,     0,    40,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,   288,     0,
+     274,   289,   290,   195,   275,   291,   292,   293,   276,   277,
+     278,   279,   280,   281,   282,   283,   284,   285,     0,     9,
+      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+      20,     0,    21,    22,    23,    24,    25,   286,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    27,    28,    29,
+      30,    31,     0,   287,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    32,    33,
+      34,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    35,     0,     0,    36,    37,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    38,     0,     0,     0,    40,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     288,     0,   274,   289,   290,   195,   275,   291,   292,   293,
+     276,   277,   278,   279,   280,   281,   282,   283,   284,   285,
+       0,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,     0,    21,    22,    23,    24,    25,   286,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    27,
+      28,    29,    30,    31,     0,   287,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      32,    33,    34,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    64,    35,     0,     0,    36,
+      37,    67,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    68,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    38,     0,     0,     0,
+      40,     0,     0,     0,   901,    70,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,   289,   290,     0,     0,   792,
+     292,   293,     0,     0,    72,    73,    74,    75,     0,    77,
+      78,    79,     0,     0,     0,   903,   904,   905,     0,    80,
+     906,    82,     0,    83,    84,    85,    86,    87,     0,     0,
+       0,     0,     0,    88,     0,     0,     0,    92,     0,    94,
+      95,    96,    97,    98,    99,     8,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   100,     0,     0,     0,
+       0,   101,     0,     0,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,     0,    21,    22,    23,
+      24,    25,   310,   908,     0,     0,     0,     0,     0,     0,
+       0,    26,    27,    28,    29,    30,    31,     0,     0,     0,
+     164,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    32,    33,    34,     0,     0,     0,     0,
+       0,     8,     0,     0,     0,     0,     0,     0,     0,    35,
+       0,     0,    36,    37,     0,     0,     0,     0,     0,     0,
+       9,    10,    11,    12,    13,    14,    15,    16,   245,    18,
+     246,    20,     0,   247,    22,    23,    24,    25,     0,    38,
+       0,     0,    39,    40,     8,     0,     0,     0,    41,     0,
+       0,     0,   311,   948,     0,   312,     0,     0,     0,     0,
+       0,     0,   169,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,     0,    21,    22,    23,    24,
+      25,   310,     0,     0,     0,    35,     0,     0,    36,    37,
+      26,    27,    28,    29,    30,    31,     0,     0,     0,   164,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    32,    33,    34,    38,     0,     0,     0,    40,
+     482,   483,   484,   485,   486,     0,   487,     0,    35,     0,
+       0,    36,    37,     0,     0,     0,     0,     0,     0,     0,
+       0,   488,   489,   490,   491,   492,   493,   494,   495,   496,
+     497,   498,   499,     0,     0,     0,     0,     0,    38,     0,
+       0,    39,    40,     8,     0,     0,     0,    41,     0,     0,
+       0,   503,     0,     0,   504,     0,     0,     0,     0,     0,
+       0,   169,     9,    10,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,    20,     0,    21,    22,    23,    24,    25,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    26,
+      27,    28,    29,    30,    31,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    32,    33,    34,     8,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    35,     0,     0,
+      36,    37,     0,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,     0,    21,    22,    23,    24,
+      25,     0,     0,     0,     0,     0,     0,    38,     0,     0,
+      39,    40,     0,     0,    30,    31,    41,     0,     0,     0,
+     434,     0,     0,   435,     0,     0,     0,     0,     0,     0,
+     169,     0,    32,    33,    34,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    35,     0,
+       0,    36,    37,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    -2,    63,     0,
+    -632,    64,     0,     0,     0,    65,    66,    67,    38,     0,
+       0,     0,    40,     0,     0,     0,     0,     0,    68,  -632,
+    -632,  -632,  -632,  -632,  -632,  -632,  -632,  -632,  -632,  -632,
+    -632,   169,  -632,  -632,  -632,  -632,  -632,     0,     0,     0,
+      69,    70,     0,     0,     0,     0,     0,  -632,  -632,  -632,
+    -632,  -632,     0,     0,    71,     0,     0,     0,     0,     0,
+      72,    73,    74,    75,    76,    77,    78,    79,  -632,  -632,
+    -632,     0,     0,     0,     0,    80,    81,    82,     0,    83,
+      84,    85,    86,    87,  -632,  -632,     0,  -632,  -632,    88,
+      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
+      99,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   100,    63,  -632,  -632,    64,   101,  -632,     0,
+      65,    66,    67,   102,   103,     0,     0,     0,     0,     0,
+       0,     0,     0,    68,  -632,  -632,  -632,  -632,  -632,  -632,
+    -632,  -632,  -632,  -632,  -632,  -632,     0,  -632,  -632,  -632,
+    -632,  -632,     0,     0,     0,    69,    70,     0,     0,   732,
+       0,     0,  -632,  -632,  -632,  -632,  -632,     0,     0,    71,
+       0,     0,     0,     0,     0,    72,    73,    74,    75,    76,
+      77,    78,    79,  -632,  -632,  -632,     0,     0,     0,     0,
+      80,    81,    82,     0,    83,    84,    85,    86,    87,  -632,
+    -632,     0,  -632,  -632,    88,    89,    90,    91,    92,    93,
+      94,    95,    96,    97,    98,    99,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   100,    63,  -632,
+    -632,    64,   101,  -632,     0,    65,    66,    67,   102,   103,
+       0,     0,     0,     0,     0,     0,     0,     0,    68,  -632,
+    -632,  -632,  -632,  -632,  -632,  -632,  -632,  -632,  -632,  -632,
+    -632,     0,  -632,  -632,  -632,  -632,  -632,     0,     0,     0,
+      69,    70,     0,     0,   825,     0,     0,  -632,  -632,  -632,
+    -632,  -632,     0,     0,    71,     0,     0,     0,     0,     0,
+      72,    73,    74,    75,    76,    77,    78,    79,  -632,  -632,
+    -632,     0,     0,     0,     0,    80,    81,    82,     0,    83,
+      84,    85,    86,    87,  -632,  -632,     0,  -632,  -632,    88,
+      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
+      99,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   100,    63,  -632,  -632,    64,   101,  -632,     0,
+      65,    66,    67,   102,   103,     0,     0,     0,     0,     0,
+       0,     0,     0,    68,  -632,  -632,  -632,  -632,  -632,  -632,
+    -632,  -632,  -632,  -632,  -632,  -632,     0,  -632,  -632,  -632,
+    -632,  -632,     0,     0,     0,    69,    70,     0,     0,   840,
+       0,     0,  -632,  -632,  -632,  -632,  -632,     0,     0,    71,
+       0,     0,     0,     0,     0,    72,    73,    74,    75,    76,
+      77,    78,    79,  -632,  -632,  -632,     0,     0,     0,     0,
+      80,    81,    82,     0,    83,    84,    85,    86,    87,  -632,
+    -632,     0,  -632,  -632,    88,    89,    90,    91,    92,    93,
+      94,    95,    96,    97,    98,    99,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   100,    63,  -632,
+    -632,    64,   101,  -632,     0,    65,    66,    67,   102,   103,
+       0,     0,     0,     0,     0,     0,     0,     0,    68,  -632,
+    -632,  -632,  -632,  -632,  -632,  -632,  -632,  -632,  -632,  -632,
+    -632,     0,  -632,  -632,  -632,  -632,  -632,     0,     0,     0,
+      69,    70,     0,     0,     0,     0,     0,  -632,  -632,  -632,
+    -632,  -632,     0,     0,    71,     0,     0,     0,   997,     0,
+      72,    73,    74,    75,    76,    77,    78,    79,  -632,  -632,
+    -632,     0,     0,     0,     0,    80,    81,    82,     0,    83,
+      84,    85,    86,    87,  -632,  -632,     0,  -632,  -632,    88,
+      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
+      99,     0,     0,     0,     7,     0,     8,     0,     0,     0,
+       0,     0,   100,     0,  -632,     0,     0,   101,  -632,     0,
+       0,     0,     0,   102,   103,     9,    10,    11,    12,    13,
+      14,    15,    16,    17,    18,    19,    20,     0,    21,    22,
+      23,    24,    25,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    26,    27,    28,    29,    30,    31,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    32,    33,    34,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      35,     0,     0,    36,    37,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    58,
+       0,     8,     0,     0,     0,   954,     0,     0,     0,     0,
+      38,     0,     0,    39,    40,     0,     0,     0,     0,    41,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,     0,    21,    22,    23,    24,    25,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    26,    27,    28,
+      29,    30,    31,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    32,
+      33,    34,   482,   483,   484,   485,   486,     0,   487,     0,
+       0,     0,     0,     0,     0,    35,     0,     0,    36,    37,
+       0,     0,     0,   488,   489,   490,   491,   492,   493,   494,
+     495,   496,   497,   498,   499,     0,     8,     0,     0,     0,
+    1000,     0,     0,     0,     0,    38,     0,     0,    39,    40,
+       0,     0,     0,     0,    41,     9,    10,    11,    12,    13,
+      14,    15,    16,    17,    18,    19,    20,     0,    21,    22,
+      23,    24,    25,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    26,    27,    28,    29,    30,    31,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    32,    33,    34,   482,   483,   484,
+     485,   486,     0,   487,     0,     0,     0,     0,     0,     0,
+      35,     0,     0,    36,    37,     0,     0,     0,   488,   489,
+     490,   491,   492,   493,   494,   495,   496,   497,   498,   499,
+       0,     0,     8,     0,     0,     0,     0,     0,  1160,     0,
+      38,     0,   392,    39,    40,     0,     0,     0,     0,    41,
+     549,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,     0,    21,    22,    23,    24,    25,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    26,    27,
+      28,    29,    30,    31,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      32,    33,    34,   482,   483,   484,   485,   486,     0,   487,
+       0,     0,     0,     0,     0,     0,    35,     0,     0,    36,
+      37,     0,     0,     0,   488,   489,   490,   491,   492,   493,
+     494,   495,   496,   497,   498,   499,     0,     8,     0,     0,
+       0,     0,     0,     0,     0,     0,    38,     0,     0,    39,
+      40,     0,     0,     0,     0,    41,     9,    10,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,     0,    21,
+      22,    23,    24,    25,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    26,    27,    28,    29,    30,    31,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    32,    33,    34,     0,     0,
+       0,     0,   202,     0,     8,     0,     0,     0,     0,     0,
+       0,    35,     0,     0,    36,    37,     0,     0,     0,     0,
+       0,     0,     0,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,     0,    21,    22,    23,    24,
+      25,    38,     0,     0,    39,    40,     0,     0,     0,     0,
+      41,    27,    28,    29,    30,    31,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    32,    33,    34,     0,     8,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    35,     0,
+       0,    36,    37,     0,     0,     9,    10,    11,    12,    13,
+      14,    15,    16,    17,    18,    19,    20,     0,    21,    22,
+      23,    24,    25,     0,     0,     0,     0,     0,    38,     0,
+       0,     0,    40,    27,    28,    29,    30,    31,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    32,    33,    34,     0,     0,     8,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      35,   994,     0,    36,    37,     0,     0,     0,     9,    10,
+      11,    12,    13,    14,    15,    16,  1036,    18,  1037,    20,
+       0,  1038,    22,    23,    24,    25,     0,     0,     0,     0,
+      38,     0,     0,     0,    40,   995,    27,    28,    29,    30,
+      31,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    32,    33,    34,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    35,   264,     0,    36,    37,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,   274,     0,    38,   195,   275,     0,    40,   995,   276,
+     277,   278,   279,   280,   281,   282,   283,   284,   285,     0,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,     0,    21,    22,    23,    24,    25,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    27,    28,
+      29,    30,    31,     0,   287,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    32,
+      33,    34,     0,     0,     8,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    35,     0,     0,    36,    37,
+       0,     0,     0,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,     0,    21,    22,    23,    24,
+      25,     0,     0,     0,     0,    38,     0,     0,     0,    40,
+      26,    27,    28,    29,    30,    31,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    32,    33,    34,     0,     8,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    35,     0,
+       0,    36,    37,     0,     0,     9,    10,    11,    12,    13,
+      14,    15,    16,    17,    18,    19,    20,     0,    21,    22,
+      23,    24,    25,   236,     0,     0,     0,     0,    38,     0,
+       0,    39,    40,    27,    28,    29,    30,    31,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    32,    33,    34,     0,     8,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      35,     0,     0,    36,    37,     0,     0,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,     0,     0,     0,     0,     0,
+      38,     0,     0,     0,    40,    27,    28,    29,    30,    31,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    32,    33,    34,     0,
+       8,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    35,   264,     0,    36,    37,     0,     0,     9,
+      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+      20,     0,    21,    22,    23,    24,    25,     0,     0,     0,
+       0,     0,    38,     0,     0,     0,    40,    27,    28,    29,
+      30,    31,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    32,    33,
+      34,     8,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    35,     0,     0,    36,    37,     0,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,     0,    21,    22,    23,    24,    25,     0,     0,
+       0,     0,     0,     0,    38,     0,     0,     0,    40,     0,
+       0,    30,    31,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    32,
+      33,    34,     8,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    35,     0,     0,    36,    37,
+       0,     9,    10,    11,    12,    13,    14,    15,    16,   245,
+      18,   246,    20,     0,   247,    22,    23,    24,    25,     0,
+       0,     0,     0,     0,     0,    38,     0,     0,     0,    40,
+       0,     0,    30,    31,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    33,    34,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    35,     0,     0,    36,
+      37,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     8,   248,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    38,     0,     0,     0,
+      40,     9,    10,    11,    12,    13,    14,    15,    16,   245,
+      18,   246,    20,     0,   247,    22,    23,    24,    25,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    30,    31,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    33,    34,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    35,     0,     0,    36,
+      37,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     8,   993,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    38,     0,     0,     0,
+      40,     9,    10,    11,    12,    13,    14,    15,    16,   245,
+      18,   246,    20,     0,   247,    22,    23,    24,    25,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,   518,    30,    31,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    33,    34,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,   683,     0,    35,     0,     0,    36,
+      37,     0,     0,     0,     0,     0,   685,     0,     0,     0,
+     482,   483,   484,   485,   486,     0,   487,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    38,     0,     0,     0,
+      40,   488,   489,   490,   491,   492,   493,   494,   495,   496,
+     497,   498,   499,   482,   483,   484,   485,   486,   809,   487,
+       0,     0,     0,     0,     0,   482,   483,   484,   485,   486,
+     814,   487,     0,     0,   488,   489,   490,   491,   492,   493,
+     494,   495,   496,   497,   498,   499,   488,   489,   490,   491,
+     492,   493,   494,   495,   496,   497,   498,   499,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   482,   483,   484,
+     485,   486,     0,   487,     0,     0,     0,     0,     0,   482,
+     483,   484,   485,   486,     0,   487,     0,     0,   488,   489,
+     490,   491,   492,   493,   494,   495,   496,   497,   498,   499,
+     488,   489,   490,   491,   492,   493,   494,   495,   496,   497,
+     498,   499
+};
+
+static const yytype_int16 yycheck[] =
+{
+       0,     5,   163,   151,   101,     5,   101,     1,     2,     5,
+     380,    72,    47,   153,    95,   572,   161,   608,    40,     5,
+     556,   248,     5,   399,   144,    45,    47,   603,   197,   587,
+     566,   272,   829,     5,    95,    96,   184,   185,   566,     5,
+     230,     1,     2,   286,   287,   726,   407,    47,     5,   682,
+     640,   684,     1,   550,     6,  1013,     3,    21,  1002,    40,
+     101,    46,     3,     6,     6,   255,    46,    42,    48,    40,
+      43,    71,  1150,    42,     3,    46,    76,    77,    41,    49,
+    1169,    41,   194,   144,     5,     4,     0,     6,   200,     0,
+       5,    40,     5,   238,   206,    48,    50,    51,    52,   211,
+     197,    61,   197,   144,    46,  1183,    41,    55,  1197,     5,
+      49,   152,     5,     5,   114,  1071,     5,     3,     5,   360,
+       5,     3,    86,  1081,    43,     5,     5,    46,   113,   241,
+     105,   104,    43,     5,    86,   932,     3,     5,   173,     3,
+     175,   162,     5,    86,   166,     3,   258,  1091,     5,    90,
+      91,    61,   133,   153,    40,   118,   197,   104,   127,   153,
+     113,    90,    91,    49,     6,   310,   167,   168,   120,   727,
+     118,    48,    58,   173,    76,   175,   177,  1133,   554,   159,
+    1124,    40,   203,   118,   775,   126,   140,     5,   333,   169,
+      40,   191,   121,   153,  1138,   828,  1152,   116,     3,   575,
+     697,   161,    63,  1159,    90,    91,   144,   207,    90,    91,
+     800,    40,   114,   104,    41,   848,   577,   238,    60,   380,
+      55,     3,   127,    90,    91,   468,    90,    91,  1025,    93,
+       3,   117,    90,    91,    55,   121,   113,     3,   238,   121,
+     240,   241,    77,     3,   130,  1042,    55,   133,   248,    50,
+      51,    52,   212,   117,   248,   215,   142,   121,    40,   117,
+      46,    90,    91,   121,   299,   265,   127,   267,    50,    51,
+      52,   130,   130,   831,   133,   133,   236,     4,   299,     6,
+      40,   140,   140,   104,   244,    90,    91,     6,   248,    49,
+     311,   312,   973,    44,   315,   104,   832,   297,   874,   299,
+    1097,   104,   212,   130,   832,   215,   133,     4,    90,    91,
+     311,   312,   117,    43,   315,   119,   121,    90,    91,    46,
+     106,   107,     4,     3,    90,    91,   236,    78,    42,   130,
+      90,    91,   133,   414,   244,   117,    55,   398,   478,   121,
+     144,    55,     3,   378,   117,    43,   407,    77,   121,    46,
+     310,   352,   353,   414,   120,   121,    43,   117,    43,    46,
+     142,   121,   589,    77,    46,   555,    46,   140,   362,   104,
+     515,     6,     6,   333,    40,  1172,    43,   357,   378,    40,
+     756,    42,   142,   118,   119,   122,   346,     3,    49,   349,
+      77,   105,    58,   428,    55,   585,    40,    58,    43,   399,
+      40,    46,   362,    53,    54,     6,     3,   468,    43,   144,
+      90,    91,    46,   434,   435,   436,    77,   104,    58,   977,
+      40,   462,    72,   999,    40,    40,   426,   572,   428,    90,
+      91,    46,    77,    49,     3,    42,   346,   117,   460,   349,
+     119,   121,    58,    40,   105,     1,    91,   447,    55,   449,
+     595,    53,    49,   453,   566,    40,   117,   457,    55,     3,
+     121,    58,     6,    85,    86,   144,   127,   447,    43,   130,
+      72,    46,   133,   453,    90,    91,    53,    54,    40,   140,
+      77,   142,   442,   787,   478,    40,    42,    43,    40,    41,
+      46,    85,   452,    90,    91,    72,    73,    41,    40,   803,
+     804,   117,   503,   504,   505,   121,    58,    40,    77,  1066,
+     511,   512,   122,    40,   130,   885,   577,   133,   478,   520,
+     117,    90,    91,    40,   121,    58,   142,   672,    40,    78,
+       3,    58,   442,   130,    83,   515,   133,     3,    40,    41,
+     541,    58,   452,   140,     3,   142,    90,    91,   117,    40,
+     550,   572,   121,    40,   554,   549,    58,    40,  1149,   519,
+      40,    41,   106,   107,   524,    40,    41,    40,    40,   573,
+      40,    41,   572,   573,   568,   575,   576,   573,    58,    40,
+     576,   642,   582,    58,    40,    58,    58,   573,    58,   549,
+     573,    43,   586,   203,    46,   589,    40,   617,    43,   559,
+     769,   573,    58,    55,     4,   640,     6,   573,   568,   519,
+      55,     4,   757,     6,   524,   595,   573,    90,    91,   640,
+      40,   581,   622,   623,    90,    91,   586,   627,   238,   589,
+     118,    90,    91,   593,    41,    42,   826,   827,    43,    40,
+     640,    46,    43,   643,   117,    46,   786,   787,   121,   559,
+      55,   117,   573,    41,   264,   121,   266,   637,   573,    42,
+     573,   120,   121,   803,   804,   106,   107,    47,   669,   142,
+     130,   581,   769,   133,   769,   736,     4,   573,     6,    46,
+     573,   573,    81,   593,   573,   665,   573,     6,   573,    46,
+      89,    90,    91,   573,   573,    41,    42,   697,   678,   703,
+      43,   573,   682,   703,   684,   573,    43,   703,    40,    46,
+     573,    43,    42,   853,   133,    43,   573,   703,    46,    41,
+     703,   721,   834,    43,   885,    43,    46,    55,    46,   729,
+     734,   703,   985,   118,   734,   988,   105,   703,   734,    41,
+      42,   721,   702,    50,    51,    52,   703,   105,   734,   729,
+     785,   734,    42,   753,   754,   573,   756,   753,   758,    40,
+     908,   858,   734,   858,   845,   800,   993,   753,   734,    90,
+      91,   771,     7,   793,   774,   775,    41,   734,   758,   800,
+     740,   161,   703,   783,   845,   785,   786,   787,   703,   169,
+     703,   774,   702,   118,    41,   775,   753,   123,   124,   125,
+     800,    58,   762,   803,   804,   866,    40,   703,    41,    42,
+     703,   703,   792,   734,   703,   118,   703,   858,   703,   734,
+     940,   734,  1192,   703,   703,   866,   138,   139,   140,   829,
+     740,   703,   753,    43,   140,   703,    41,   837,   734,    41,
+     703,   734,   734,   940,    41,   734,   703,   734,   828,   734,
+      41,    55,   762,   853,   734,   734,  1017,   837,   238,   853,
+      42,    41,   734,    41,    43,   869,   734,    41,   848,   869,
+     830,   734,    41,   869,   874,   255,    41,   734,     3,   940,
+      41,    41,  1030,   869,    41,   703,   869,   887,   136,   137,
+     138,   139,   140,   853,   894,   878,   105,   869,    42,   940,
+      40,   118,  1173,   869,  1044,   515,    41,   907,  1179,  1180,
+    1181,    43,   869,    77,     3,    40,   734,   118,    46,   299,
+     830,  1066,     3,   104,   884,  1196,    74,    75,    76,    40,
+     310,   992,   932,   968,   995,     3,     3,   317,   447,    41,
+      41,   118,   118,    49,   453,   945,    21,    40,   869,     3,
+      46,    43,     6,   333,   869,   565,   869,    43,    41,   569,
+      40,    46,   572,   343,    43,    90,    91,    43,   968,    44,
+      47,    92,    41,   869,   884,   975,   869,   869,    40,    91,
+     869,    90,   869,   113,   869,   595,   596,    58,    41,   869,
+     869,    79,   117,   993,    40,   975,   121,   869,    40,   993,
+      41,   869,  1002,    78,    79,    80,   869,    77,    83,  1009,
+      85,    86,   869,  1013,    40,    40,    49,   142,    41,    41,
+      41,  1021,    41,  1023,  1024,  1025,  1009,     3,  1189,    42,
+    1013,  1192,    42,   993,    41,    40,    90,    91,     3,    55,
+      43,  1021,  1042,    41,  1004,  1066,   144,   104,    41,    41,
+      47,   869,   106,   107,    21,   104,    42,    63,    46,  1059,
+     440,    41,   672,    41,    40,    55,  1066,    41,    41,    41,
+      41,    41,   452,    49,    43,    40,    55,    44,    41,  1059,
+    1080,  1081,    58,    42,    49,   465,    43,    41,    47,    47,
+      77,  1091,    77,    58,  1004,    54,    46,  1097,  1081,   142,
+    1080,    47,  1102,   127,    47,    41,  1106,  1168,    41,  1069,
+      41,    78,    79,    80,    90,    91,    83,   727,    85,    86,
+    1120,    77,  1102,    41,  1124,    90,    91,    41,    77,    88,
+      89,    47,    41,    43,  1134,   515,    42,   105,  1138,  1099,
+    1120,   117,   101,    43,    55,   121,    41,   757,    49,  1149,
+      43,    40,   117,   120,  1114,    77,   121,    77,  1158,  1069,
+      77,    43,  1162,   122,    77,   130,   142,    43,   133,  1149,
+      77,    43,  1172,  1173,    43,   140,  1136,   142,  1158,  1179,
+    1180,  1181,  1162,    41,   105,  1145,  1146,  1147,    43,  1099,
+      42,   150,   572,  1173,    40,    49,  1196,     3,    47,  1179,
+    1180,  1181,   161,   162,  1114,    43,  1166,    43,   167,   168,
+      40,   170,   721,    40,    43,   595,  1196,    41,   177,    47,
+     729,    41,    41,   833,    40,    46,  1136,    49,    41,    41,
+       3,     4,   842,     6,    40,  1145,  1146,  1147,   197,    41,
+      41,    41,   556,    49,   203,    43,    43,   582,   753,   758,
+    1140,   993,    58,   589,   754,   907,  1166,   637,   753,   753,
+     640,    41,   853,   222,   643,   478,   775,    40,  1106,   610,
+      43,    52,   878,    46,  1134,  1009,    49,     3,   627,   238,
+     890,   894,  1008,  1024,    90,    91,  1129,  1149,   185,   737,
+     249,    -1,   672,   252,    -1,    -1,   255,   256,   257,    -1,
+      -1,   260,    -1,    -1,    -1,   264,   265,   266,   267,    -1,
+      -1,   117,     3,    -1,    40,   121,    -1,    90,    91,    -1,
+      -1,    -1,    -1,    49,    50,    51,    52,    -1,   837,    -1,
+      -1,    -1,    58,    -1,    -1,    -1,   142,    -1,    -1,    -1,
+     299,    -1,    -1,   116,   117,    -1,    -1,    -1,   121,    40,
+      -1,   310,   311,   312,    -1,    -1,   315,   130,   317,    -1,
+     133,    -1,    -1,    -1,    90,    91,   976,   140,    -1,   142,
+      -1,    -1,    -1,    -1,   333,   334,   335,   757,    -1,    -1,
+     339,    -1,    -1,    -1,   994,    -1,   996,    -1,    -1,    -1,
+      -1,   117,   351,   352,   353,   121,    -1,    -1,   357,    90,
+      91,     3,  1012,    -1,   130,    -1,    -1,   133,    -1,     3,
+     369,   370,   792,   793,   140,     3,   142,    -1,    -1,    -1,
+     800,    -1,    -1,  1033,    -1,    -1,   117,    -1,   387,    -1,
+     121,    72,    -1,     3,    -1,    -1,    -1,    -1,    40,    -1,
+      -1,   400,    -1,    -1,    -1,    -1,    40,    49,    89,    -1,
+      -1,   142,    40,    -1,    -1,    49,  1066,    -1,    -1,    -1,
+      -1,    49,    50,    51,    52,    -1,   975,    -1,    -1,    -1,
+      40,    -1,    -1,    -1,    -1,   434,   435,   436,    -1,    49,
+      -1,   440,   112,    -1,   443,   444,    -1,   446,    90,    91,
+      -1,    -1,    -1,   452,   164,   165,    90,    91,    -1,    -1,
+      -1,    -1,    90,    91,   134,   135,   136,   137,   138,   139,
+     140,    -1,  1021,    -1,    -1,   117,    -1,    -1,    -1,   121,
+      90,    91,    -1,   117,    -1,    -1,    -1,   121,   130,   117,
+    1140,   133,    -1,   121,    -1,    -1,   130,    -1,   140,   133,
+     142,    -1,   130,    -1,    -1,   133,   505,   117,   142,    -1,
+    1059,   121,    -1,   194,   142,    -1,   515,    -1,   199,   200,
+     130,   520,    -1,   133,    -1,   206,    -1,   208,   209,    -1,
+     211,  1080,   142,    -1,    -1,    -1,   535,    -1,    -1,   538,
+      -1,    -1,   541,   542,    -1,   544,   227,    -1,     3,   230,
+     231,     6,    -1,  1102,    -1,    -1,    -1,    -1,    -1,    -1,
+     241,    -1,    -1,    -1,    -1,    -1,   565,    -1,    -1,    -1,
+     569,  1120,    -1,   572,   255,    -1,   286,   258,   288,   289,
+     290,   291,   292,   293,   265,    40,    -1,    -1,   269,    -1,
+      -1,    -1,    -1,     3,    49,    -1,   595,   596,   597,    -1,
+    1149,    -1,   601,    -1,    -1,    -1,    -1,    -1,     3,  1158,
+      -1,     6,     7,     3,   324,    -1,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    -1,    -1,     3,    -1,
+      40,   630,    -1,    43,    -1,    90,    91,   347,    -1,    49,
+     350,   640,    -1,    -1,    -1,    40,  1066,    -1,  1068,  1069,
+      40,     3,    -1,    43,    49,    -1,    -1,    -1,    -1,    49,
+      -1,    56,   117,    -1,    -1,    40,   121,    -1,    -1,    70,
+      -1,    -1,    -1,   672,    49,   130,    -1,    -1,   133,   678,
+      90,    91,    -1,    58,    -1,   140,    -1,   142,    40,   688,
+      -1,   690,    -1,    94,    -1,   694,   695,    49,    99,    -1,
+      90,    91,    -1,    -1,    -1,    -1,    58,   117,     3,    -1,
+      -1,   121,    -1,    -1,    -1,    90,    91,    -1,    -1,    -1,
+     130,    -1,    -1,   133,    -1,    -1,    -1,   117,   727,    -1,
+     140,   121,   142,    -1,    -1,    -1,    -1,    -1,    90,    91,
+     130,    -1,   117,   133,    -1,    40,   121,   168,    43,    -1,
+     140,    -1,   142,   752,    49,    -1,   177,    -1,   757,    -1,
+      -1,   760,    -1,     3,    -1,   117,    -1,   142,     3,   121,
+     769,     6,   482,   483,   484,   485,   486,   487,   488,   489,
+     490,   491,   492,   493,   494,   495,   496,   497,   498,   499,
+     142,    -1,    -1,   194,    -1,    90,    91,    -1,   199,   200,
+      40,   800,    -1,    -1,    -1,   206,   516,    -1,    -1,    -1,
+     211,    -1,    -1,    -1,    -1,   525,    -1,    -1,    58,   818,
+     819,     3,   117,    -1,    -1,    -1,   121,    -1,    -1,   230,
+      -1,    -1,     3,    -1,   833,   130,   257,    -1,   133,   260,
+     241,   242,    -1,   842,    -1,   140,    -1,   142,    -1,    -1,
+      90,    91,    -1,   254,   255,    90,    91,   258,    40,   858,
+      -1,    43,    -1,    -1,    -1,    -1,     3,    49,    -1,    40,
+      -1,   106,   107,    -1,   555,    -1,    -1,   117,    49,    -1,
+      -1,   121,   117,    -1,    -1,   566,   121,    -1,    -1,    -1,
+     130,   890,    -1,   133,    -1,   130,    -1,    -1,   133,   898,
+       3,    -1,   583,    40,   585,   140,    -1,    -1,    90,    91,
+      -1,    -1,    49,   334,    -1,    -1,    -1,    -1,   339,    90,
+      91,    -1,    -1,   633,   634,   635,   636,   637,    -1,   639,
+     351,   352,   353,     3,    -1,   117,   357,    40,    -1,   121,
+      -1,   940,    -1,    -1,     3,    -1,   117,    -1,   130,    -1,
+     121,   133,    -1,    90,    91,    58,    -1,    -1,   140,   130,
+     142,     3,   133,    -1,    -1,    -1,    -1,    -1,    -1,   140,
+      40,   142,    -1,    -1,    -1,    -1,    -1,   976,    -1,    49,
+     117,    40,    -1,    -1,   121,    -1,    -1,    90,    91,     3,
+      -1,    -1,    -1,   130,    -1,   994,   133,   996,    40,    58,
+      -1,    -1,    -1,   140,    -1,   142,    -1,    49,    -1,    -1,
+      -1,    -1,    -1,  1012,   117,    -1,    -1,    -1,   121,  1018,
+      90,    91,   443,   444,    -1,   446,    40,   130,    -1,    -1,
+     133,    90,    91,    -1,  1033,    49,    -1,    -1,    -1,   142,
+     134,   135,   136,   137,   138,   139,   140,   117,    90,    91,
+      -1,   121,    -1,   763,    -1,   736,    -1,    -1,   117,    -1,
+     130,    -1,   121,   133,     3,    -1,    -1,  1066,    -1,     3,
+    1069,   130,   142,    -1,   133,   117,    90,    91,    -1,   121,
+     790,   791,   792,   142,   794,    -1,    -1,     3,   130,    -1,
+      -1,   133,   802,    -1,    -1,    -1,  1095,    -1,   140,   520,
+     142,    40,     3,   117,    -1,    -1,    40,   121,    -1,    -1,
+      49,    -1,    -1,    -1,   535,    49,    -1,   538,    -1,    -1,
+     541,   542,    -1,   544,    40,    -1,    -1,    -1,   142,    -1,
+    1129,    -1,    -1,    49,    -1,    -1,    -1,    -1,    -1,    40,
+      -1,  1140,    -1,    -1,    -1,   826,   827,    -1,    49,    -1,
+     551,    90,    91,   834,   555,   556,    90,    91,    -1,    -1,
+      -1,    -1,    -1,   564,   565,   566,    -1,    -1,   849,   850,
+     851,    50,    51,    52,    90,    91,   597,    -1,   117,    -1,
+     601,    -1,   121,   117,   585,    -1,   587,   121,    -1,    90,
+      91,    -1,    -1,    -1,    -1,   596,    -1,    -1,    -1,   880,
+      -1,   117,    81,   142,    -1,   121,    -1,    -1,   142,    -1,
+      89,    90,    91,    -1,    -1,    -1,   117,    -1,   108,   109,
+     121,    -1,   112,    -1,    -1,    -1,   142,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   108,   109,   110,   111,   112,    -1,
+      -1,   142,   952,   953,   134,   135,   136,   137,   138,   139,
+     140,   130,    -1,    -1,   133,    -1,    -1,   678,   132,   133,
+     134,   135,   136,   137,   138,   139,   140,   688,    -1,   690,
+      -1,    -1,     3,   694,   695,     6,     7,    -1,    -1,    -1,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      -1,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,     6,    35,    36,    37,    38,    39,    40,
+      13,    14,    15,    16,    17,    18,    19,    20,    49,    50,
+      51,    52,    53,    54,    -1,    56,   727,  1008,    -1,    -1,
+      -1,    -1,    -1,    -1,   735,    -1,   737,    -1,    -1,   760,
+      71,    72,    73,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
+      91,    -1,    -1,    -1,    -1,    -1,    -1,     3,  1078,    -1,
+       6,    -1,    -1,    -1,    -1,    -1,    -1,    13,    14,    15,
+      16,    17,    18,    19,    20,    -1,   117,    -1,    -1,   120,
+     121,    -1,    -1,  1103,    -1,   126,    -1,   818,   819,    -1,
+      -1,    -1,   133,    -1,    -1,   136,   137,    -1,    -1,   140,
+     141,   142,    -1,    -1,    -1,     1,    -1,     3,     4,    -1,
+      -1,    -1,     8,     9,    10,   826,   827,    -1,    -1,    -1,
+     831,   832,    -1,   834,    -1,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    -1,    35,
+      36,    37,    38,    39,    90,    91,   857,    43,    44,    -1,
+      -1,    47,    -1,    -1,    50,    51,    52,    53,    54,    -1,
+     106,   107,    -1,    -1,    -1,    -1,    -1,    63,    64,    65,
+      66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
+      76,    -1,    78,    79,    80,    -1,    82,    83,    84,    85,
+      86,    87,    88,    -1,    90,    91,    92,    -1,    -1,    -1,
+      96,    -1,    98,    99,   100,   101,   102,   103,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   115,
+      -1,   117,    -1,    -1,   120,   121,   122,    -1,     3,    -1,
+     126,     6,     7,    -1,    -1,    41,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,   142,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,   977,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    50,    51,    52,    53,    54,
+      -1,    56,    -1,    -1,    59,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    71,    72,    73,   105,
+      -1,    -1,   108,   109,   110,   111,   112,    -1,   114,    -1,
+      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    -1,    -1,
+      -1,    -1,    -1,   129,   130,   131,   132,   133,   134,   135,
+     136,   137,   138,   139,   140,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   117,    -1,    -1,    -1,   121,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   133,    -1,
+       3,   136,   137,     6,     7,   140,   141,   142,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    -1,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    40,    35,    36,    37,    38,    39,    40,    -1,    -1,
+      -1,    50,    51,    52,    -1,    -1,    55,    50,    51,    52,
+      53,    54,    -1,    56,    -1,    -1,    59,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,    72,
+      73,    -1,    81,   108,   109,   110,   111,   112,    -1,   114,
+      89,    90,    91,    -1,    87,    -1,    -1,    90,    91,    -1,
+      -1,    -1,    -1,    -1,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138,   139,   140,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   117,    -1,    -1,    -1,   121,    -1,
+      -1,   130,    -1,    -1,   133,    -1,    -1,    -1,    -1,    -1,
+     133,    -1,     3,   136,   137,     6,     7,   140,   141,   142,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      -1,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    -1,    35,    36,    37,    38,    39,    40,
+      -1,    -1,    77,    -1,    -1,    -1,    -1,    -1,    -1,    50,
+      51,    52,    53,    54,    -1,    56,    -1,    -1,    59,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      71,    72,    73,   108,   109,   110,   111,   112,    -1,   114,
+      -1,   108,   109,   110,   111,   112,    87,    -1,    -1,    90,
+      91,    -1,    -1,    -1,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138,   139,   140,   133,   134,   135,   136,
+     137,   138,   139,   140,    -1,    -1,   117,    -1,    -1,    -1,
+     121,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   133,    -1,     3,   136,   137,     6,     7,   140,
+     141,   142,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,    -1,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    -1,    35,    36,    37,    38,
+      39,    40,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    50,    51,    52,    53,    54,    -1,    56,    -1,    -1,
+      59,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    71,    72,    73,   108,   109,   110,   111,   112,
+      -1,    -1,   108,   109,   110,   111,   112,    -1,    87,    -1,
+      -1,    90,    91,    -1,    -1,    -1,   129,   130,   131,   132,
+     133,   134,   135,   136,   137,   138,   139,   140,   134,   135,
+     136,   137,   138,   139,   140,    -1,    -1,    -1,   117,    -1,
+      -1,    -1,   121,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   133,    -1,     3,   136,   137,     6,
+       7,   140,   141,   142,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,    20,    -1,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    -1,    35,    36,
+      37,    38,    39,    40,    41,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    50,    51,    52,    53,    54,    -1,    56,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    71,    72,    73,   108,   109,   110,
+     111,   112,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      87,    -1,    -1,    90,    91,    -1,    -1,    -1,    -1,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,   139,   140,
+      -1,    -1,    22,    23,    24,    25,    26,    27,    28,    29,
+     117,    31,    -1,    33,   121,    -1,    36,    37,    38,    39,
+      -1,    -1,    -1,    -1,    -1,    -1,   133,    -1,     3,   136,
+     137,     6,     7,   140,   141,   142,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    -1,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,    41,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    50,    51,    52,    53,    54,
+      -1,    56,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    71,    72,    73,   108,
+     109,   110,   111,   112,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    -1,    -1,
+      -1,    -1,   131,   132,   133,   134,   135,   136,   137,   138,
+     139,   140,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   117,    -1,    -1,    -1,   121,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   133,    -1,
+       3,   136,   137,     6,     7,   140,   141,   142,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    -1,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    -1,    35,    36,    37,    38,    39,    40,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    50,    51,    52,
+      53,    54,    -1,    56,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,    72,
+      73,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   117,    -1,    -1,    -1,   121,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+     133,    -1,     3,   136,   137,     6,     7,   140,   141,   142,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      -1,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    -1,    35,    36,    37,    38,    39,    40,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    50,
+      51,    52,    53,    54,    -1,    56,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      71,    72,    73,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,     4,    87,    -1,    -1,    90,
+      91,    10,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    21,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   117,    -1,    -1,    -1,
+     121,    -1,    -1,    -1,    43,    44,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,   136,   137,    -1,    -1,   140,
+     141,   142,    -1,    -1,    63,    64,    65,    66,    -1,    68,
+      69,    70,    -1,    -1,    -1,    74,    75,    76,    -1,    78,
+      79,    80,    -1,    82,    83,    84,    85,    86,    -1,    -1,
+      -1,    -1,    -1,    92,    -1,    -1,    -1,    96,    -1,    98,
+      99,   100,   101,   102,   103,     3,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   115,    -1,    -1,    -1,
+      -1,   120,    -1,    -1,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    31,    32,    33,    -1,    35,    36,    37,
+      38,    39,    40,   142,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    49,    50,    51,    52,    53,    54,    -1,    -1,    -1,
+      58,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    71,    72,    73,    -1,    -1,    -1,    -1,
+      -1,     3,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,
+      -1,    -1,    90,    91,    -1,    -1,    -1,    -1,    -1,    -1,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    -1,    35,    36,    37,    38,    39,    -1,   117,
+      -1,    -1,   120,   121,     3,    -1,    -1,    -1,   126,    -1,
+      -1,    -1,   130,    41,    -1,   133,    -1,    -1,    -1,    -1,
+      -1,    -1,   140,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    -1,    35,    36,    37,    38,
+      39,    40,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,
+      49,    50,    51,    52,    53,    54,    -1,    -1,    -1,    58,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    71,    72,    73,   117,    -1,    -1,    -1,   121,
+     108,   109,   110,   111,   112,    -1,   114,    -1,    87,    -1,
+      -1,    90,    91,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,   129,   130,   131,   132,   133,   134,   135,   136,   137,
+     138,   139,   140,    -1,    -1,    -1,    -1,    -1,   117,    -1,
+      -1,   120,   121,     3,    -1,    -1,    -1,   126,    -1,    -1,
+      -1,   130,    -1,    -1,   133,    -1,    -1,    -1,    -1,    -1,
+      -1,   140,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    -1,    35,    36,    37,    38,    39,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    49,
+      50,    51,    52,    53,    54,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    71,    72,    73,     3,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,
+      90,    91,    -1,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    -1,    35,    36,    37,    38,
+      39,    -1,    -1,    -1,    -1,    -1,    -1,   117,    -1,    -1,
+     120,   121,    -1,    -1,    53,    54,   126,    -1,    -1,    -1,
+     130,    -1,    -1,   133,    -1,    -1,    -1,    -1,    -1,    -1,
+     140,    -1,    71,    72,    73,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,
+      -1,    90,    91,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,     0,     1,    -1,
+       3,     4,    -1,    -1,    -1,     8,     9,    10,   117,    -1,
+      -1,    -1,   121,    -1,    -1,    -1,    -1,    -1,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,   140,    35,    36,    37,    38,    39,    -1,    -1,    -1,
+      43,    44,    -1,    -1,    -1,    -1,    -1,    50,    51,    52,
+      53,    54,    -1,    -1,    57,    -1,    -1,    -1,    -1,    -1,
+      63,    64,    65,    66,    67,    68,    69,    70,    71,    72,
+      73,    -1,    -1,    -1,    -1,    78,    79,    80,    -1,    82,
+      83,    84,    85,    86,    87,    88,    -1,    90,    91,    92,
+      93,    94,    95,    96,    97,    98,    99,   100,   101,   102,
+     103,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   115,     1,   117,     3,     4,   120,   121,    -1,
+       8,     9,    10,   126,   127,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    31,    32,    33,    -1,    35,    36,    37,
+      38,    39,    -1,    -1,    -1,    43,    44,    -1,    -1,    47,
+      -1,    -1,    50,    51,    52,    53,    54,    -1,    -1,    57,
+      -1,    -1,    -1,    -1,    -1,    63,    64,    65,    66,    67,
+      68,    69,    70,    71,    72,    73,    -1,    -1,    -1,    -1,
+      78,    79,    80,    -1,    82,    83,    84,    85,    86,    87,
+      88,    -1,    90,    91,    92,    93,    94,    95,    96,    97,
+      98,    99,   100,   101,   102,   103,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,   115,     1,   117,
+       3,     4,   120,   121,    -1,     8,     9,    10,   126,   127,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    -1,    35,    36,    37,    38,    39,    -1,    -1,    -1,
+      43,    44,    -1,    -1,    47,    -1,    -1,    50,    51,    52,
+      53,    54,    -1,    -1,    57,    -1,    -1,    -1,    -1,    -1,
+      63,    64,    65,    66,    67,    68,    69,    70,    71,    72,
+      73,    -1,    -1,    -1,    -1,    78,    79,    80,    -1,    82,
+      83,    84,    85,    86,    87,    88,    -1,    90,    91,    92,
+      93,    94,    95,    96,    97,    98,    99,   100,   101,   102,
+     103,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   115,     1,   117,     3,     4,   120,   121,    -1,
+       8,     9,    10,   126,   127,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    31,    32,    33,    -1,    35,    36,    37,
+      38,    39,    -1,    -1,    -1,    43,    44,    -1,    -1,    47,
+      -1,    -1,    50,    51,    52,    53,    54,    -1,    -1,    57,
+      -1,    -1,    -1,    -1,    -1,    63,    64,    65,    66,    67,
+      68,    69,    70,    71,    72,    73,    -1,    -1,    -1,    -1,
+      78,    79,    80,    -1,    82,    83,    84,    85,    86,    87,
+      88,    -1,    90,    91,    92,    93,    94,    95,    96,    97,
+      98,    99,   100,   101,   102,   103,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,   115,     1,   117,
+       3,     4,   120,   121,    -1,     8,     9,    10,   126,   127,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    -1,    35,    36,    37,    38,    39,    -1,    -1,    -1,
+      43,    44,    -1,    -1,    -1,    -1,    -1,    50,    51,    52,
+      53,    54,    -1,    -1,    57,    -1,    -1,    -1,    61,    -1,
+      63,    64,    65,    66,    67,    68,    69,    70,    71,    72,
+      73,    -1,    -1,    -1,    -1,    78,    79,    80,    -1,    82,
+      83,    84,    85,    86,    87,    88,    -1,    90,    91,    92,
+      93,    94,    95,    96,    97,    98,    99,   100,   101,   102,
+     103,    -1,    -1,    -1,     1,    -1,     3,    -1,    -1,    -1,
+      -1,    -1,   115,    -1,   117,    -1,    -1,   120,   121,    -1,
+      -1,    -1,    -1,   126,   127,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    -1,    35,    36,
+      37,    38,    39,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    49,    50,    51,    52,    53,    54,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    71,    72,    73,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      87,    -1,    -1,    90,    91,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     1,
+      -1,     3,    -1,    -1,    -1,    41,    -1,    -1,    -1,    -1,
+     117,    -1,    -1,   120,   121,    -1,    -1,    -1,    -1,   126,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    -1,    35,    36,    37,    38,    39,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    49,    50,    51,
+      52,    53,    54,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,
+      72,    73,   108,   109,   110,   111,   112,    -1,   114,    -1,
+      -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,
+      -1,    -1,    -1,   129,   130,   131,   132,   133,   134,   135,
+     136,   137,   138,   139,   140,    -1,     3,    -1,    -1,    -1,
+      41,    -1,    -1,    -1,    -1,   117,    -1,    -1,   120,   121,
+      -1,    -1,    -1,    -1,   126,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    -1,    35,    36,
+      37,    38,    39,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    49,    50,    51,    52,    53,    54,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    71,    72,    73,   108,   109,   110,
+     111,   112,    -1,   114,    -1,    -1,    -1,    -1,    -1,    -1,
+      87,    -1,    -1,    90,    91,    -1,    -1,    -1,   129,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,   139,   140,
+      -1,    -1,     3,    -1,    -1,    -1,    -1,    -1,    43,    -1,
+     117,    -1,    13,   120,   121,    -1,    -1,    -1,    -1,   126,
+     127,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    -1,    35,    36,    37,    38,    39,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    49,    50,
+      51,    52,    53,    54,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      71,    72,    73,   108,   109,   110,   111,   112,    -1,   114,
+      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
+      91,    -1,    -1,    -1,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138,   139,   140,    -1,     3,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   117,    -1,    -1,   120,
+     121,    -1,    -1,    -1,    -1,   126,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    -1,    35,
+      36,    37,    38,    39,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    49,    50,    51,    52,    53,    54,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    71,    72,    73,    -1,    -1,
+      -1,    -1,     1,    -1,     3,    -1,    -1,    -1,    -1,    -1,
+      -1,    87,    -1,    -1,    90,    91,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    -1,    35,    36,    37,    38,
+      39,   117,    -1,    -1,   120,   121,    -1,    -1,    -1,    -1,
+     126,    50,    51,    52,    53,    54,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    71,    72,    73,    -1,     3,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,
+      -1,    90,    91,    -1,    -1,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    -1,    35,    36,
+      37,    38,    39,    -1,    -1,    -1,    -1,    -1,   117,    -1,
+      -1,    -1,   121,    50,    51,    52,    53,    54,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    71,    72,    73,    -1,    -1,     3,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      87,    88,    -1,    90,    91,    -1,    -1,    -1,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      -1,    35,    36,    37,    38,    39,    -1,    -1,    -1,    -1,
+     117,    -1,    -1,    -1,   121,   122,    50,    51,    52,    53,
+      54,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,    72,    73,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    87,    88,    -1,    90,    91,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,     3,    -1,   117,     6,     7,    -1,   121,   122,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,    -1,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    -1,    35,    36,    37,    38,    39,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    50,    51,
+      52,    53,    54,    -1,    56,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,
+      72,    73,    -1,    -1,     3,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,
+      -1,    -1,    -1,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    -1,    35,    36,    37,    38,
+      39,    -1,    -1,    -1,    -1,   117,    -1,    -1,    -1,   121,
+      49,    50,    51,    52,    53,    54,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    71,    72,    73,    -1,     3,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,
+      -1,    90,    91,    -1,    -1,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    -1,    35,    36,
+      37,    38,    39,    40,    -1,    -1,    -1,    -1,   117,    -1,
+      -1,   120,   121,    50,    51,    52,    53,    54,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    71,    72,    73,    -1,     3,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      87,    -1,    -1,    90,    91,    -1,    -1,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    -1,    -1,    -1,    -1,    -1,
+     117,    -1,    -1,    -1,   121,    50,    51,    52,    53,    54,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    71,    72,    73,    -1,
+       3,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    87,    88,    -1,    90,    91,    -1,    -1,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    -1,    35,    36,    37,    38,    39,    -1,    -1,    -1,
+      -1,    -1,   117,    -1,    -1,    -1,   121,    50,    51,    52,
+      53,    54,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,    72,
+      73,     3,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,    -1,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    -1,    35,    36,    37,    38,    39,    -1,    -1,
+      -1,    -1,    -1,    -1,   117,    -1,    -1,    -1,   121,    -1,
+      -1,    53,    54,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,
+      72,    73,     3,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,
+      -1,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    -1,    35,    36,    37,    38,    39,    -1,
+      -1,    -1,    -1,    -1,    -1,   117,    -1,    -1,    -1,   121,
+      -1,    -1,    53,    54,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    72,    73,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
+      91,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,     3,   104,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   117,    -1,    -1,    -1,
+     121,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    -1,    35,    36,    37,    38,    39,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    53,    54,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    72,    73,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
+      91,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,     3,   104,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   117,    -1,    -1,    -1,
+     121,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    -1,    35,    36,    37,    38,    39,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    59,    53,    54,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    72,    73,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    59,    -1,    87,    -1,    -1,    90,
+      91,    -1,    -1,    -1,    -1,    -1,    59,    -1,    -1,    -1,
+     108,   109,   110,   111,   112,    -1,   114,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   117,    -1,    -1,    -1,
+     121,   129,   130,   131,   132,   133,   134,   135,   136,   137,
+     138,   139,   140,   108,   109,   110,   111,   112,    59,   114,
+      -1,    -1,    -1,    -1,    -1,   108,   109,   110,   111,   112,
+      59,   114,    -1,    -1,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138,   139,   140,   129,   130,   131,   132,
+     133,   134,   135,   136,   137,   138,   139,   140,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,   108,   109,   110,
+     111,   112,    -1,   114,    -1,    -1,    -1,    -1,    -1,   108,
+     109,   110,   111,   112,    -1,   114,    -1,    -1,   129,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,   139,   140,
+     129,   130,   131,   132,   133,   134,   135,   136,   137,   138,
+     139,   140
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint16 yystos[] =
+{
+       0,   123,   124,   125,   146,   147,   329,     1,     3,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    35,    36,    37,    38,    39,    49,    50,    51,    52,
+      53,    54,    71,    72,    73,    87,    90,    91,   117,   120,
+     121,   126,   198,   242,   243,   261,   262,   264,   265,   266,
+     267,   268,   269,   298,   299,   314,   317,   319,     1,   243,
+       1,    40,     0,     1,     4,     8,     9,    10,    21,    43,
+      44,    57,    63,    64,    65,    66,    67,    68,    69,    70,
+      78,    79,    80,    82,    83,    84,    85,    86,    92,    93,
+      94,    95,    96,    97,    98,    99,   100,   101,   102,   103,
+     115,   120,   126,   127,   148,   149,   150,   152,   153,   154,
+     155,   156,   159,   160,   162,   163,   164,   165,   166,   167,
+     168,   171,   172,   173,   176,   178,   183,   184,   185,   186,
+     188,   192,   200,   201,   202,   203,   204,   208,   209,   216,
+     217,   229,   230,   237,   238,   329,    53,    72,    49,    49,
+      40,   144,   104,   104,   313,   242,   317,   127,    43,   265,
+     261,    40,    49,    55,    58,    77,   121,   130,   133,   140,
+     142,   250,   251,   253,   255,   256,   257,   258,   317,   329,
+     261,   268,   317,   313,   119,   144,   318,    43,    43,   239,
+     240,   243,   329,   122,    40,     6,    86,   120,   323,    40,
+     326,   329,     1,   263,   264,   314,    40,   326,    40,   170,
+     329,    40,    40,    85,    86,    40,    85,    40,    78,    83,
+      44,    78,    93,   317,    46,   314,   317,    40,     4,    46,
+      40,    40,    43,    46,     4,   323,    40,   182,   263,   180,
+     182,    40,    40,   323,    40,    30,    32,    35,   104,   191,
+     266,   267,   299,   317,   326,    40,   130,   133,   253,   255,
+     258,   317,    21,    86,    88,   198,   263,   299,   317,   120,
+     121,   319,   320,   299,     3,     7,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    40,    56,   133,   136,
+     137,   140,   141,   142,   243,   244,   245,   247,   263,   264,
+     283,   284,   285,   286,   287,   288,   323,   324,   329,   261,
+      40,   130,   133,   239,   256,   258,   317,    40,   255,   317,
+      46,   106,   107,   270,   271,   272,   273,   274,    59,   283,
+     286,   283,     3,    40,    49,   142,   254,   257,   317,    49,
+     254,   257,   258,   261,   317,   250,    40,    58,   250,    40,
+      58,    49,   130,   133,   254,   257,   317,   118,   319,   121,
+     320,    41,    42,   241,   329,   272,   314,   315,   323,   191,
+     299,     6,    46,   315,   327,   315,     0,    43,   253,   255,
+      55,    41,   315,    53,    54,    72,   300,   301,   329,   314,
+     314,   315,    13,   177,   239,   239,   317,    43,    55,   219,
+      55,    46,   314,   179,   327,   314,   239,    46,   252,   253,
+     255,   256,   329,    43,    42,   181,   329,   315,   316,   329,
+     157,   158,   323,   239,   212,   213,   214,   243,   298,   329,
+     317,   317,   133,   323,   130,   133,   258,   314,   317,   327,
+      40,   315,    40,   130,   133,   317,   118,   253,   317,   275,
+     314,   329,    40,   253,    77,   290,   291,   317,   329,    41,
+     314,   318,   105,    48,   113,   283,   285,     3,    40,    49,
+     285,   283,   283,   283,   283,   283,   283,   105,    42,   246,
+     329,    40,   108,   109,   110,   111,   112,   114,   129,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,   139,   140,
+      48,   113,     7,   130,   133,   258,   317,   255,   255,    41,
+      41,   130,   133,   255,   317,   118,    58,   283,    59,    40,
+     258,   317,   254,   317,    40,    58,   254,   258,   239,    59,
+     283,   239,    59,   283,   254,    49,   254,   257,    49,   254,
+     257,   118,    49,   130,   133,   254,   261,   318,    43,   127,
+     243,    41,   317,   317,   187,    42,    55,    41,   250,    40,
+     270,    41,   317,    41,    55,    41,    42,   175,    42,    41,
+      41,    43,   263,   147,   317,   218,    41,    41,    41,    41,
+     180,    40,   182,    41,    41,    42,    46,    41,   105,    42,
+     215,   329,   250,    40,    60,   118,    41,   258,   317,    43,
+     239,   118,    81,    89,    90,    91,   130,   133,   259,   260,
+     261,   303,   306,   307,   308,   329,    55,    77,   199,   329,
+     239,   317,   308,   292,    46,    43,    91,   305,   329,   313,
+     299,     3,     3,    41,   105,   130,   133,   140,   258,   104,
+     263,   285,    40,   247,   283,   283,   283,   283,   283,   283,
+     283,   283,   283,   283,   283,   283,   283,   283,   283,   283,
+     283,   283,     3,     3,   317,   118,    41,    41,    41,   118,
+     253,   256,   261,   283,   239,   254,   317,    41,   118,   239,
+      59,   283,    41,    59,    41,    59,   254,   254,    49,   130,
+     133,   254,   257,   254,    49,    49,   254,   243,   241,     4,
+      46,   323,    40,   147,   327,   157,   287,   323,   328,    43,
+     239,    43,    46,     4,   169,   323,     4,    43,    46,   116,
+     174,   253,   323,   325,   315,   323,   328,    41,   243,   253,
+      46,   252,    47,    43,   147,    44,   238,   180,    43,    46,
+      40,    47,   239,   181,   117,   121,   314,   321,    43,   327,
+     243,   174,    92,   210,   214,   239,   161,   261,   253,   323,
+     118,    41,    40,    40,   303,    91,    90,   306,   260,   113,
+      58,   193,   265,    43,    46,    41,   190,   250,    79,   293,
+     294,   302,   329,   206,   290,   317,    40,    40,   283,   283,
+      41,    41,   140,   261,    41,   130,   133,   283,   251,    41,
+     263,   246,    77,    40,    40,    41,    41,   253,   256,    59,
+      41,    41,   254,    41,    59,   259,   259,   254,    49,    49,
+     254,   254,   254,   241,   239,    47,    42,    42,    41,   151,
+      40,   308,    55,    41,    42,   175,   174,   253,   308,    43,
+      47,   323,   263,   314,    43,    55,   325,   239,    41,   144,
+     119,   144,   322,   104,    41,    47,   317,    44,   120,   188,
+     204,   208,   209,   211,   226,   228,   238,   215,    41,   147,
+     308,    43,   239,   283,   191,   104,   194,   329,   154,   276,
+     277,   278,   279,   329,    40,    55,   306,   308,   309,     1,
+      42,    43,    46,   189,    42,    74,    75,    76,   295,   297,
+       1,    43,    67,    74,    75,    76,    79,   126,   142,   152,
+     153,   154,   155,   159,   160,   164,   166,   168,   171,   173,
+     176,   178,   183,   184,   185,   186,   204,   208,   209,   216,
+     220,   224,   225,   226,   227,   228,   229,   231,   232,   235,
+     238,   329,    46,   250,   248,   286,   329,   248,    41,   283,
+     283,   283,    41,    41,    41,    41,   251,   283,   248,   248,
+      41,    41,    41,   254,   254,    41,   327,   327,   259,   220,
+     239,   174,   323,   328,    43,   253,    41,   308,    43,   253,
+      43,   182,    41,   259,   121,   314,   314,   121,   314,   244,
+       4,    46,    55,   104,    88,   122,   263,    61,    43,    41,
+      41,   303,   304,   329,    40,    46,   195,   276,   126,   280,
+     281,   314,    47,    42,   127,   239,   270,    55,    77,   310,
+     329,   253,   294,   317,   296,   223,    46,    77,    77,    77,
+     142,   224,   319,    47,   127,   220,    30,    32,    35,   236,
+     267,   317,   205,    41,    42,   249,   329,    41,   283,   283,
+      41,    41,    41,   250,    47,    41,   175,   308,    43,   253,
+     174,    43,    43,   322,   322,   105,   263,   212,   263,    40,
+     303,   190,   239,    40,    43,   196,   281,   277,    55,    43,
+     253,   127,   278,    41,    43,   272,   311,   312,   317,    43,
+      46,   308,    49,   289,   329,   302,   220,   221,   319,    40,
+      43,   207,   253,    77,    43,   220,   286,    43,    43,    43,
+     308,    43,   252,   105,    40,   130,   133,   258,   239,   189,
+      41,   197,   282,   283,   308,   278,    43,    46,    43,    42,
+      49,    40,    46,   190,   317,   220,    40,   239,   308,   283,
+      47,   249,    43,    43,   239,    40,    40,    40,   133,    41,
+     308,    43,   190,   312,   189,   289,    47,   239,    41,   190,
+      43,   207,    41,   239,   239,   239,    40,   309,   113,   195,
+     189,    49,   222,    41,   233,   308,   189,   234,   308,    41,
+      41,    41,   239,   263,   196,   220,   234,    43,    46,    55,
+      43,    46,    55,   234,   234,   234,    41,   195,   272,   270,
+     234,   196,    43,    43
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 1730 "parser.y"
+    {
+                   if (!classes) classes = NewHash();
+		   Setattr((yyvsp[(1) - (1)].node),"classes",classes); 
+		   Setattr((yyvsp[(1) - (1)].node),"name",ModuleName);
+		   
+		   if ((!module_node) && ModuleName) {
+		     module_node = new_node("module");
+		     Setattr(module_node,"name",ModuleName);
+		   }
+		   Setattr((yyvsp[(1) - (1)].node),"module",module_node);
+	           top = (yyvsp[(1) - (1)].node);
+               ;}
+    break;
+
+  case 3:
+#line 1742 "parser.y"
+    {
+                 top = Copy(Getattr((yyvsp[(2) - (3)].p),"type"));
+		 Delete((yyvsp[(2) - (3)].p));
+               ;}
+    break;
+
+  case 4:
+#line 1746 "parser.y"
+    {
+                 top = 0;
+               ;}
+    break;
+
+  case 5:
+#line 1749 "parser.y"
+    {
+                 top = (yyvsp[(2) - (3)].p);
+               ;}
+    break;
+
+  case 6:
+#line 1752 "parser.y"
+    {
+                 top = 0;
+               ;}
+    break;
+
+  case 7:
+#line 1755 "parser.y"
+    {
+                 top = (yyvsp[(3) - (5)].pl);
+               ;}
+    break;
+
+  case 8:
+#line 1758 "parser.y"
+    {
+                 top = 0;
+               ;}
+    break;
+
+  case 9:
+#line 1763 "parser.y"
+    {  
+                   /* add declaration to end of linked list (the declaration isn't always a single declaration, sometimes it is a linked list itself) */
+                   if (currentDeclComment != NULL) {
+		     set_comment((yyvsp[(2) - (2)].node), currentDeclComment);
+		     currentDeclComment = NULL;
+                   }                                      
+                   appendChild((yyvsp[(1) - (2)].node),(yyvsp[(2) - (2)].node));
+                   (yyval.node) = (yyvsp[(1) - (2)].node);
+               ;}
+    break;
+
+  case 10:
+#line 1772 "parser.y"
+    {
+                   currentDeclComment = (yyvsp[(2) - (2)].str); 
+                   (yyval.node) = (yyvsp[(1) - (2)].node);
+               ;}
+    break;
+
+  case 11:
+#line 1776 "parser.y"
+    {
+                   Node *node = lastChild((yyvsp[(1) - (2)].node));
+                   if (node) {
+                     set_comment(node, (yyvsp[(2) - (2)].str));
+                   }
+                   (yyval.node) = (yyvsp[(1) - (2)].node);
+               ;}
+    break;
+
+  case 12:
+#line 1783 "parser.y"
+    {
+                   (yyval.node) = new_node("top");
+               ;}
+    break;
+
+  case 13:
+#line 1788 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 14:
+#line 1789 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 15:
+#line 1790 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 16:
+#line 1791 "parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 17:
+#line 1792 "parser.y"
+    {
+                  (yyval.node) = 0;
+		  if (cparse_unknown_directive) {
+		      Swig_error(cparse_file, cparse_line, "Unknown directive '%s'.\n", cparse_unknown_directive);
+		  } else {
+		      Swig_error(cparse_file, cparse_line, "Syntax error in input(1).\n");
+		  }
+		  Exit(EXIT_FAILURE);
+               ;}
+    break;
+
+  case 18:
+#line 1802 "parser.y"
+    { 
+                  if ((yyval.node)) {
+   		      add_symbols((yyval.node));
+                  }
+                  (yyval.node) = (yyvsp[(1) - (1)].node); 
+	       ;}
+    break;
+
+  case 19:
+#line 1818 "parser.y"
+    {
+                  (yyval.node) = 0;
+                  skip_decl();
+               ;}
+    break;
+
+  case 20:
+#line 1828 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 21:
+#line 1829 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 22:
+#line 1830 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 23:
+#line 1831 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 24:
+#line 1832 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 25:
+#line 1833 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 26:
+#line 1834 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 27:
+#line 1835 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 28:
+#line 1836 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 29:
+#line 1837 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 30:
+#line 1838 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 31:
+#line 1839 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 32:
+#line 1840 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 33:
+#line 1841 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 34:
+#line 1842 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 35:
+#line 1843 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 36:
+#line 1844 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 37:
+#line 1845 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 38:
+#line 1846 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 39:
+#line 1847 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 40:
+#line 1848 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 41:
+#line 1855 "parser.y"
+    {
+               Node *cls;
+	       String *clsname;
+	       extendmode = 1;
+	       cplus_mode = CPLUS_PUBLIC;
+	       if (!classes) classes = NewHash();
+	       if (!classes_typedefs) classes_typedefs = NewHash();
+	       clsname = make_class_name((yyvsp[(4) - (5)].str));
+	       cls = Getattr(classes,clsname);
+	       if (!cls) {
+	         cls = Getattr(classes_typedefs, clsname);
+		 if (!cls) {
+		   /* No previous definition. Create a new scope */
+		   Node *am = Getattr(Swig_extend_hash(),clsname);
+		   if (!am) {
+		     Swig_symbol_newscope();
+		     Swig_symbol_setscopename((yyvsp[(4) - (5)].str));
+		     prev_symtab = 0;
+		   } else {
+		     prev_symtab = Swig_symbol_setscope(Getattr(am,"symtab"));
+		   }
+		   current_class = 0;
+		 } else {
+		   /* Previous typedef class definition.  Use its symbol table.
+		      Deprecated, just the real name should be used. 
+		      Note that %extend before the class typedef never worked, only %extend after the class typedef. */
+		   prev_symtab = Swig_symbol_setscope(Getattr(cls, "symtab"));
+		   current_class = cls;
+		   SWIG_WARN_NODE_BEGIN(cls);
+		   Swig_warning(WARN_PARSE_EXTEND_NAME, cparse_file, cparse_line, "Deprecated %%extend name used - the %s name '%s' should be used instead of the typedef name '%s'.\n", Getattr(cls, "kind"), SwigType_namestr(Getattr(cls, "name")), (yyvsp[(4) - (5)].str));
+		   SWIG_WARN_NODE_END(cls);
+		 }
+	       } else {
+		 /* Previous class definition.  Use its symbol table */
+		 prev_symtab = Swig_symbol_setscope(Getattr(cls,"symtab"));
+		 current_class = cls;
+	       }
+	       Classprefix = NewString((yyvsp[(4) - (5)].str));
+	       Namespaceprefix= Swig_symbol_qualifiedscopename(0);
+	       Delete(clsname);
+	     ;}
+    break;
+
+  case 42:
+#line 1895 "parser.y"
+    {
+               String *clsname;
+	       extendmode = 0;
+               (yyval.node) = new_node("extend");
+	       Setattr((yyval.node),"symtab",Swig_symbol_popscope());
+	       if (prev_symtab) {
+		 Swig_symbol_setscope(prev_symtab);
+	       }
+	       Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+               clsname = make_class_name((yyvsp[(4) - (8)].str));
+	       Setattr((yyval.node),"name",clsname);
+
+	       mark_nodes_as_extend((yyvsp[(7) - (8)].node));
+	       if (current_class) {
+		 /* We add the extension to the previously defined class */
+		 appendChild((yyval.node), (yyvsp[(7) - (8)].node));
+		 appendChild(current_class,(yyval.node));
+	       } else {
+		 /* We store the extensions in the extensions hash */
+		 Node *am = Getattr(Swig_extend_hash(),clsname);
+		 if (am) {
+		   /* Append the members to the previous extend methods */
+		   appendChild(am, (yyvsp[(7) - (8)].node));
+		 } else {
+		   appendChild((yyval.node), (yyvsp[(7) - (8)].node));
+		   Setattr(Swig_extend_hash(),clsname,(yyval.node));
+		 }
+	       }
+	       current_class = 0;
+	       Delete(Classprefix);
+	       Delete(clsname);
+	       Classprefix = 0;
+	       prev_symtab = 0;
+	       (yyval.node) = 0;
+
+	     ;}
+    break;
+
+  case 43:
+#line 1937 "parser.y"
+    {
+                    (yyval.node) = new_node("apply");
+                    Setattr((yyval.node),"pattern",Getattr((yyvsp[(2) - (5)].p),"pattern"));
+		    appendChild((yyval.node),(yyvsp[(4) - (5)].p));
+               ;}
+    break;
+
+  case 44:
+#line 1947 "parser.y"
+    {
+		 (yyval.node) = new_node("clear");
+		 appendChild((yyval.node),(yyvsp[(2) - (3)].p));
+               ;}
+    break;
+
+  case 45:
+#line 1961 "parser.y"
+    {
+		   if (((yyvsp[(4) - (5)].dtype).type != T_ERROR) && ((yyvsp[(4) - (5)].dtype).type != T_SYMBOL)) {
+		     SwigType *type = NewSwigType((yyvsp[(4) - (5)].dtype).type);
+		     (yyval.node) = new_node("constant");
+		     Setattr((yyval.node),"name",(yyvsp[(2) - (5)].id));
+		     Setattr((yyval.node),"type",type);
+		     Setattr((yyval.node),"value",(yyvsp[(4) - (5)].dtype).val);
+		     if ((yyvsp[(4) - (5)].dtype).rawval) Setattr((yyval.node),"rawval", (yyvsp[(4) - (5)].dtype).rawval);
+		     Setattr((yyval.node),"storage","%constant");
+		     SetFlag((yyval.node),"feature:immutable");
+		     add_symbols((yyval.node));
+		     Delete(type);
+		   } else {
+		     if ((yyvsp[(4) - (5)].dtype).type == T_ERROR) {
+		       Swig_warning(WARN_PARSE_UNSUPPORTED_VALUE,cparse_file,cparse_line,"Unsupported constant value (ignored)\n");
+		     }
+		     (yyval.node) = 0;
+		   }
+
+	       ;}
+    break;
+
+  case 46:
+#line 1981 "parser.y"
+    {
+		 if (((yyvsp[(4) - (5)].dtype).type != T_ERROR) && ((yyvsp[(4) - (5)].dtype).type != T_SYMBOL)) {
+		   SwigType_push((yyvsp[(2) - (5)].type),(yyvsp[(3) - (5)].decl).type);
+		   /* Sneaky callback function trick */
+		   if (SwigType_isfunction((yyvsp[(2) - (5)].type))) {
+		     SwigType_add_pointer((yyvsp[(2) - (5)].type));
+		   }
+		   (yyval.node) = new_node("constant");
+		   Setattr((yyval.node),"name",(yyvsp[(3) - (5)].decl).id);
+		   Setattr((yyval.node),"type",(yyvsp[(2) - (5)].type));
+		   Setattr((yyval.node),"value",(yyvsp[(4) - (5)].dtype).val);
+		   if ((yyvsp[(4) - (5)].dtype).rawval) Setattr((yyval.node),"rawval", (yyvsp[(4) - (5)].dtype).rawval);
+		   Setattr((yyval.node),"storage","%constant");
+		   SetFlag((yyval.node),"feature:immutable");
+		   add_symbols((yyval.node));
+		 } else {
+		   if ((yyvsp[(4) - (5)].dtype).type == T_ERROR) {
+		     Swig_warning(WARN_PARSE_UNSUPPORTED_VALUE,cparse_file,cparse_line, "Unsupported constant value\n");
+		   }
+		   (yyval.node) = 0;
+		 }
+               ;}
+    break;
+
+  case 47:
+#line 2005 "parser.y"
+    {
+		 if (((yyvsp[(8) - (9)].dtype).type != T_ERROR) && ((yyvsp[(8) - (9)].dtype).type != T_SYMBOL)) {
+		   SwigType_add_function((yyvsp[(2) - (9)].type), (yyvsp[(5) - (9)].pl));
+		   SwigType_push((yyvsp[(2) - (9)].type), (yyvsp[(7) - (9)].dtype).qualifier);
+		   SwigType_push((yyvsp[(2) - (9)].type), (yyvsp[(3) - (9)].decl).type);
+		   /* Sneaky callback function trick */
+		   if (SwigType_isfunction((yyvsp[(2) - (9)].type))) {
+		     SwigType_add_pointer((yyvsp[(2) - (9)].type));
+		   }
+		   (yyval.node) = new_node("constant");
+		   Setattr((yyval.node), "name", (yyvsp[(3) - (9)].decl).id);
+		   Setattr((yyval.node), "type", (yyvsp[(2) - (9)].type));
+		   Setattr((yyval.node), "value", (yyvsp[(8) - (9)].dtype).val);
+		   if ((yyvsp[(8) - (9)].dtype).rawval) Setattr((yyval.node), "rawval", (yyvsp[(8) - (9)].dtype).rawval);
+		   Setattr((yyval.node), "storage", "%constant");
+		   SetFlag((yyval.node), "feature:immutable");
+		   add_symbols((yyval.node));
+		 } else {
+		   if ((yyvsp[(8) - (9)].dtype).type == T_ERROR) {
+		     Swig_warning(WARN_PARSE_UNSUPPORTED_VALUE,cparse_file,cparse_line, "Unsupported constant value\n");
+		   }
+		   (yyval.node) = 0;
+		 }
+	       ;}
+    break;
+
+  case 48:
+#line 2029 "parser.y"
+    {
+		 Swig_warning(WARN_PARSE_BAD_VALUE,cparse_file,cparse_line,"Bad constant value (ignored).\n");
+		 (yyval.node) = 0;
+	       ;}
+    break;
+
+  case 49:
+#line 2033 "parser.y"
+    {
+		 Swig_error(cparse_file,cparse_line,"Missing semicolon (';') after %%constant.\n");
+		 Exit(EXIT_FAILURE);
+	       ;}
+    break;
+
+  case 50:
+#line 2044 "parser.y"
+    {
+		 char temp[64];
+		 Replace((yyvsp[(2) - (2)].str),"$file",cparse_file, DOH_REPLACE_ANY);
+		 sprintf(temp,"%d", cparse_line);
+		 Replace((yyvsp[(2) - (2)].str),"$line",temp,DOH_REPLACE_ANY);
+		 Printf(stderr,"%s\n", (yyvsp[(2) - (2)].str));
+		 Delete((yyvsp[(2) - (2)].str));
+                 (yyval.node) = 0;
+	       ;}
+    break;
+
+  case 51:
+#line 2053 "parser.y"
+    {
+		 char temp[64];
+		 String *s = (yyvsp[(2) - (2)].str);
+		 Replace(s,"$file",cparse_file, DOH_REPLACE_ANY);
+		 sprintf(temp,"%d", cparse_line);
+		 Replace(s,"$line",temp,DOH_REPLACE_ANY);
+		 Printf(stderr,"%s\n", s);
+		 Delete(s);
+                 (yyval.node) = 0;
+               ;}
+    break;
+
+  case 52:
+#line 2072 "parser.y"
+    {
+                    skip_balanced('{','}');
+		    (yyval.node) = 0;
+		    Swig_warning(WARN_DEPRECATED_EXCEPT,cparse_file, cparse_line, "%%except is deprecated.  Use %%exception instead.\n");
+	       ;}
+    break;
+
+  case 53:
+#line 2078 "parser.y"
+    {
+                    skip_balanced('{','}');
+		    (yyval.node) = 0;
+		    Swig_warning(WARN_DEPRECATED_EXCEPT,cparse_file, cparse_line, "%%except is deprecated.  Use %%exception instead.\n");
+               ;}
+    break;
+
+  case 54:
+#line 2084 "parser.y"
+    {
+		 (yyval.node) = 0;
+		 Swig_warning(WARN_DEPRECATED_EXCEPT,cparse_file, cparse_line, "%%except is deprecated.  Use %%exception instead.\n");
+               ;}
+    break;
+
+  case 55:
+#line 2089 "parser.y"
+    {
+		 (yyval.node) = 0;
+		 Swig_warning(WARN_DEPRECATED_EXCEPT,cparse_file, cparse_line, "%%except is deprecated.  Use %%exception instead.\n");
+	       ;}
+    break;
+
+  case 56:
+#line 2096 "parser.y"
+    {		 
+                 (yyval.node) = NewHash();
+                 Setattr((yyval.node),"value",(yyvsp[(1) - (4)].str));
+		 Setattr((yyval.node),"type",Getattr((yyvsp[(3) - (4)].p),"type"));
+               ;}
+    break;
+
+  case 57:
+#line 2103 "parser.y"
+    {
+                 (yyval.node) = NewHash();
+                 Setattr((yyval.node),"value",(yyvsp[(1) - (1)].str));
+              ;}
+    break;
+
+  case 58:
+#line 2107 "parser.y"
+    {
+                (yyval.node) = (yyvsp[(1) - (1)].node);
+              ;}
+    break;
+
+  case 59:
+#line 2120 "parser.y"
+    {
+                   Hash *p = (yyvsp[(5) - (7)].node);
+		   (yyval.node) = new_node("fragment");
+		   Setattr((yyval.node),"value",Getattr((yyvsp[(3) - (7)].node),"value"));
+		   Setattr((yyval.node),"type",Getattr((yyvsp[(3) - (7)].node),"type"));
+		   Setattr((yyval.node),"section",Getattr(p,"name"));
+		   Setattr((yyval.node),"kwargs",nextSibling(p));
+		   Setattr((yyval.node),"code",(yyvsp[(7) - (7)].str));
+                 ;}
+    break;
+
+  case 60:
+#line 2129 "parser.y"
+    {
+		   Hash *p = (yyvsp[(5) - (7)].node);
+		   String *code;
+                   skip_balanced('{','}');
+		   (yyval.node) = new_node("fragment");
+		   Setattr((yyval.node),"value",Getattr((yyvsp[(3) - (7)].node),"value"));
+		   Setattr((yyval.node),"type",Getattr((yyvsp[(3) - (7)].node),"type"));
+		   Setattr((yyval.node),"section",Getattr(p,"name"));
+		   Setattr((yyval.node),"kwargs",nextSibling(p));
+		   Delitem(scanner_ccode,0);
+		   Delitem(scanner_ccode,DOH_END);
+		   code = Copy(scanner_ccode);
+		   Setattr((yyval.node),"code",code);
+		   Delete(code);
+                 ;}
+    break;
+
+  case 61:
+#line 2144 "parser.y"
+    {
+		   (yyval.node) = new_node("fragment");
+		   Setattr((yyval.node),"value",Getattr((yyvsp[(3) - (5)].node),"value"));
+		   Setattr((yyval.node),"type",Getattr((yyvsp[(3) - (5)].node),"type"));
+		   Setattr((yyval.node),"emitonly","1");
+		 ;}
+    break;
+
+  case 62:
+#line 2157 "parser.y"
+    {
+                     (yyvsp[(1) - (4)].loc).filename = Copy(cparse_file);
+		     (yyvsp[(1) - (4)].loc).line = cparse_line;
+		     scanner_set_location((yyvsp[(3) - (4)].str),1);
+                     if ((yyvsp[(2) - (4)].node)) { 
+		       String *maininput = Getattr((yyvsp[(2) - (4)].node), "maininput");
+		       if (maininput)
+		         scanner_set_main_input_file(NewString(maininput));
+		     }
+               ;}
+    break;
+
+  case 63:
+#line 2166 "parser.y"
+    {
+                     String *mname = 0;
+                     (yyval.node) = (yyvsp[(6) - (7)].node);
+		     scanner_set_location((yyvsp[(1) - (7)].loc).filename,(yyvsp[(1) - (7)].loc).line+1);
+		     if (strcmp((yyvsp[(1) - (7)].loc).type,"include") == 0) set_nodeType((yyval.node),"include");
+		     if (strcmp((yyvsp[(1) - (7)].loc).type,"import") == 0) {
+		       mname = (yyvsp[(2) - (7)].node) ? Getattr((yyvsp[(2) - (7)].node),"module") : 0;
+		       set_nodeType((yyval.node),"import");
+		       if (import_mode) --import_mode;
+		     }
+		     
+		     Setattr((yyval.node),"name",(yyvsp[(3) - (7)].str));
+		     /* Search for the module (if any) */
+		     {
+			 Node *n = firstChild((yyval.node));
+			 while (n) {
+			     if (Strcmp(nodeType(n),"module") == 0) {
+			         if (mname) {
+				   Setattr(n,"name", mname);
+				   mname = 0;
+				 }
+				 Setattr((yyval.node),"module",Getattr(n,"name"));
+				 break;
+			     }
+			     n = nextSibling(n);
+			 }
+			 if (mname) {
+			   /* There is no module node in the import
+			      node, ie, you imported a .h file
+			      directly.  We are forced then to create
+			      a new import node with a module node.
+			   */			      
+			   Node *nint = new_node("import");
+			   Node *mnode = new_node("module");
+			   Setattr(mnode,"name", mname);
+                           Setattr(mnode,"options",(yyvsp[(2) - (7)].node));
+			   appendChild(nint,mnode);
+			   Delete(mnode);
+			   appendChild(nint,firstChild((yyval.node)));
+			   (yyval.node) = nint;
+			   Setattr((yyval.node),"module",mname);
+			 }
+		     }
+		     Setattr((yyval.node),"options",(yyvsp[(2) - (7)].node));
+               ;}
+    break;
+
+  case 64:
+#line 2213 "parser.y"
+    { (yyval.loc).type = "include"; ;}
+    break;
+
+  case 65:
+#line 2214 "parser.y"
+    { (yyval.loc).type = "import"; ++import_mode;;}
+    break;
+
+  case 66:
+#line 2221 "parser.y"
+    {
+                 String *cpps;
+		 if (Namespaceprefix) {
+		   Swig_error(cparse_file, cparse_start_line, "%%inline directive inside a namespace is disallowed.\n");
+		   (yyval.node) = 0;
+		 } else {
+		   (yyval.node) = new_node("insert");
+		   Setattr((yyval.node),"code",(yyvsp[(2) - (2)].str));
+		   /* Need to run through the preprocessor */
+		   Seek((yyvsp[(2) - (2)].str),0,SEEK_SET);
+		   Setline((yyvsp[(2) - (2)].str),cparse_start_line);
+		   Setfile((yyvsp[(2) - (2)].str),cparse_file);
+		   cpps = Preprocessor_parse((yyvsp[(2) - (2)].str));
+		   start_inline(Char(cpps), cparse_start_line);
+		   Delete((yyvsp[(2) - (2)].str));
+		   Delete(cpps);
+		 }
+		 
+	       ;}
+    break;
+
+  case 67:
+#line 2240 "parser.y"
+    {
+                 String *cpps;
+		 int start_line = cparse_line;
+		 skip_balanced('{','}');
+		 if (Namespaceprefix) {
+		   Swig_error(cparse_file, cparse_start_line, "%%inline directive inside a namespace is disallowed.\n");
+		   
+		   (yyval.node) = 0;
+		 } else {
+		   String *code;
+                   (yyval.node) = new_node("insert");
+		   Delitem(scanner_ccode,0);
+		   Delitem(scanner_ccode,DOH_END);
+		   code = Copy(scanner_ccode);
+		   Setattr((yyval.node),"code", code);
+		   Delete(code);		   
+		   cpps=Copy(scanner_ccode);
+		   start_inline(Char(cpps), start_line);
+		   Delete(cpps);
+		 }
+               ;}
+    break;
+
+  case 68:
+#line 2271 "parser.y"
+    {
+                 (yyval.node) = new_node("insert");
+		 Setattr((yyval.node),"code",(yyvsp[(1) - (1)].str));
+	       ;}
+    break;
+
+  case 69:
+#line 2275 "parser.y"
+    {
+		 String *code = NewStringEmpty();
+		 (yyval.node) = new_node("insert");
+		 Setattr((yyval.node),"section",(yyvsp[(3) - (5)].id));
+		 Setattr((yyval.node),"code",code);
+		 if (Swig_insert_file((yyvsp[(5) - (5)].str),code) < 0) {
+		   Swig_error(cparse_file, cparse_line, "Couldn't find '%s'.\n", (yyvsp[(5) - (5)].str));
+		   (yyval.node) = 0;
+		 } 
+               ;}
+    break;
+
+  case 70:
+#line 2285 "parser.y"
+    {
+		 (yyval.node) = new_node("insert");
+		 Setattr((yyval.node),"section",(yyvsp[(3) - (5)].id));
+		 Setattr((yyval.node),"code",(yyvsp[(5) - (5)].str));
+               ;}
+    break;
+
+  case 71:
+#line 2290 "parser.y"
+    {
+		 String *code;
+                 skip_balanced('{','}');
+		 (yyval.node) = new_node("insert");
+		 Setattr((yyval.node),"section",(yyvsp[(3) - (5)].id));
+		 Delitem(scanner_ccode,0);
+		 Delitem(scanner_ccode,DOH_END);
+		 code = Copy(scanner_ccode);
+		 Setattr((yyval.node),"code", code);
+		 Delete(code);
+	       ;}
+    break;
+
+  case 72:
+#line 2308 "parser.y"
+    {
+                 (yyval.node) = new_node("module");
+		 if ((yyvsp[(2) - (3)].node)) {
+		   Setattr((yyval.node),"options",(yyvsp[(2) - (3)].node));
+		   if (Getattr((yyvsp[(2) - (3)].node),"directors")) {
+		     Wrapper_director_mode_set(1);
+		     if (!cparse_cplusplus) {
+		       Swig_error(cparse_file, cparse_line, "Directors are not supported for C code and require the -c++ option\n");
+		     }
+		   } 
+		   if (Getattr((yyvsp[(2) - (3)].node),"dirprot")) {
+		     Wrapper_director_protected_mode_set(1);
+		   } 
+		   if (Getattr((yyvsp[(2) - (3)].node),"allprotected")) {
+		     Wrapper_all_protected_mode_set(1);
+		   } 
+		   if (Getattr((yyvsp[(2) - (3)].node),"templatereduce")) {
+		     template_reduce = 1;
+		   }
+		   if (Getattr((yyvsp[(2) - (3)].node),"notemplatereduce")) {
+		     template_reduce = 0;
+		   }
+		 }
+		 if (!ModuleName) ModuleName = NewString((yyvsp[(3) - (3)].id));
+		 if (!import_mode) {
+		   /* first module included, we apply global
+		      ModuleName, which can be modify by -module */
+		   String *mname = Copy(ModuleName);
+		   Setattr((yyval.node),"name",mname);
+		   Delete(mname);
+		 } else { 
+		   /* import mode, we just pass the idstring */
+		   Setattr((yyval.node),"name",(yyvsp[(3) - (3)].id));   
+		 }		 
+		 if (!module_node) module_node = (yyval.node);
+	       ;}
+    break;
+
+  case 73:
+#line 2351 "parser.y"
+    {
+                 Swig_warning(WARN_DEPRECATED_NAME,cparse_file,cparse_line, "%%name is deprecated.  Use %%rename instead.\n");
+		 Delete(yyrename);
+                 yyrename = NewString((yyvsp[(3) - (4)].id));
+		 (yyval.node) = 0;
+               ;}
+    break;
+
+  case 74:
+#line 2357 "parser.y"
+    {
+		 Swig_warning(WARN_DEPRECATED_NAME,cparse_file,cparse_line, "%%name is deprecated.  Use %%rename instead.\n");
+		 (yyval.node) = 0;
+		 Swig_error(cparse_file,cparse_line,"Missing argument to %%name directive.\n");
+	       ;}
+    break;
+
+  case 75:
+#line 2370 "parser.y"
+    {
+                 (yyval.node) = new_node("native");
+		 Setattr((yyval.node),"name",(yyvsp[(3) - (7)].id));
+		 Setattr((yyval.node),"wrap:name",(yyvsp[(6) - (7)].id));
+	         add_symbols((yyval.node));
+	       ;}
+    break;
+
+  case 76:
+#line 2376 "parser.y"
+    {
+		 if (!SwigType_isfunction((yyvsp[(7) - (8)].decl).type)) {
+		   Swig_error(cparse_file,cparse_line,"%%native declaration '%s' is not a function.\n", (yyvsp[(7) - (8)].decl).id);
+		   (yyval.node) = 0;
+		 } else {
+		     Delete(SwigType_pop_function((yyvsp[(7) - (8)].decl).type));
+		     /* Need check for function here */
+		     SwigType_push((yyvsp[(6) - (8)].type),(yyvsp[(7) - (8)].decl).type);
+		     (yyval.node) = new_node("native");
+	             Setattr((yyval.node),"name",(yyvsp[(3) - (8)].id));
+		     Setattr((yyval.node),"wrap:name",(yyvsp[(7) - (8)].decl).id);
+		     Setattr((yyval.node),"type",(yyvsp[(6) - (8)].type));
+		     Setattr((yyval.node),"parms",(yyvsp[(7) - (8)].decl).parms);
+		     Setattr((yyval.node),"decl",(yyvsp[(7) - (8)].decl).type);
+		 }
+	         add_symbols((yyval.node));
+	       ;}
+    break;
+
+  case 77:
+#line 2402 "parser.y"
+    {
+                 (yyval.node) = new_node("pragma");
+		 Setattr((yyval.node),"lang",(yyvsp[(2) - (5)].id));
+		 Setattr((yyval.node),"name",(yyvsp[(3) - (5)].id));
+		 Setattr((yyval.node),"value",(yyvsp[(5) - (5)].str));
+	       ;}
+    break;
+
+  case 78:
+#line 2408 "parser.y"
+    {
+		(yyval.node) = new_node("pragma");
+		Setattr((yyval.node),"lang",(yyvsp[(2) - (3)].id));
+		Setattr((yyval.node),"name",(yyvsp[(3) - (3)].id));
+	      ;}
+    break;
+
+  case 79:
+#line 2415 "parser.y"
+    { (yyval.str) = (yyvsp[(1) - (1)].str); ;}
+    break;
+
+  case 80:
+#line 2416 "parser.y"
+    { (yyval.str) = (yyvsp[(1) - (1)].str); ;}
+    break;
+
+  case 81:
+#line 2419 "parser.y"
+    { (yyval.id) = (yyvsp[(2) - (3)].id); ;}
+    break;
+
+  case 82:
+#line 2420 "parser.y"
+    { (yyval.id) = (char *) "swig"; ;}
+    break;
+
+  case 83:
+#line 2427 "parser.y"
+    {
+                SwigType *t = (yyvsp[(2) - (4)].decl).type;
+		Hash *kws = NewHash();
+		String *fixname;
+		fixname = feature_identifier_fix((yyvsp[(2) - (4)].decl).id);
+		Setattr(kws,"name",(yyvsp[(3) - (4)].id));
+		if (!Len(t)) t = 0;
+		/* Special declarator check */
+		if (t) {
+		  if (SwigType_isfunction(t)) {
+		    SwigType *decl = SwigType_pop_function(t);
+		    if (SwigType_ispointer(t)) {
+		      String *nname = NewStringf("*%s",fixname);
+		      if ((yyvsp[(1) - (4)].intvalue)) {
+			Swig_name_rename_add(Namespaceprefix, nname,decl,kws,(yyvsp[(2) - (4)].decl).parms);
+		      } else {
+			Swig_name_namewarn_add(Namespaceprefix,nname,decl,kws);
+		      }
+		      Delete(nname);
+		    } else {
+		      if ((yyvsp[(1) - (4)].intvalue)) {
+			Swig_name_rename_add(Namespaceprefix,(fixname),decl,kws,(yyvsp[(2) - (4)].decl).parms);
+		      } else {
+			Swig_name_namewarn_add(Namespaceprefix,(fixname),decl,kws);
+		      }
+		    }
+		    Delete(decl);
+		  } else if (SwigType_ispointer(t)) {
+		    String *nname = NewStringf("*%s",fixname);
+		    if ((yyvsp[(1) - (4)].intvalue)) {
+		      Swig_name_rename_add(Namespaceprefix,(nname),0,kws,(yyvsp[(2) - (4)].decl).parms);
+		    } else {
+		      Swig_name_namewarn_add(Namespaceprefix,(nname),0,kws);
+		    }
+		    Delete(nname);
+		  }
+		} else {
+		  if ((yyvsp[(1) - (4)].intvalue)) {
+		    Swig_name_rename_add(Namespaceprefix,(fixname),0,kws,(yyvsp[(2) - (4)].decl).parms);
+		  } else {
+		    Swig_name_namewarn_add(Namespaceprefix,(fixname),0,kws);
+		  }
+		}
+                (yyval.node) = 0;
+		scanner_clear_rename();
+              ;}
+    break;
+
+  case 84:
+#line 2473 "parser.y"
+    {
+		String *fixname;
+		Hash *kws = (yyvsp[(3) - (7)].node);
+		SwigType *t = (yyvsp[(5) - (7)].decl).type;
+		fixname = feature_identifier_fix((yyvsp[(5) - (7)].decl).id);
+		if (!Len(t)) t = 0;
+		/* Special declarator check */
+		if (t) {
+		  if ((yyvsp[(6) - (7)].dtype).qualifier) SwigType_push(t,(yyvsp[(6) - (7)].dtype).qualifier);
+		  if (SwigType_isfunction(t)) {
+		    SwigType *decl = SwigType_pop_function(t);
+		    if (SwigType_ispointer(t)) {
+		      String *nname = NewStringf("*%s",fixname);
+		      if ((yyvsp[(1) - (7)].intvalue)) {
+			Swig_name_rename_add(Namespaceprefix, nname,decl,kws,(yyvsp[(5) - (7)].decl).parms);
+		      } else {
+			Swig_name_namewarn_add(Namespaceprefix,nname,decl,kws);
+		      }
+		      Delete(nname);
+		    } else {
+		      if ((yyvsp[(1) - (7)].intvalue)) {
+			Swig_name_rename_add(Namespaceprefix,(fixname),decl,kws,(yyvsp[(5) - (7)].decl).parms);
+		      } else {
+			Swig_name_namewarn_add(Namespaceprefix,(fixname),decl,kws);
+		      }
+		    }
+		    Delete(decl);
+		  } else if (SwigType_ispointer(t)) {
+		    String *nname = NewStringf("*%s",fixname);
+		    if ((yyvsp[(1) - (7)].intvalue)) {
+		      Swig_name_rename_add(Namespaceprefix,(nname),0,kws,(yyvsp[(5) - (7)].decl).parms);
+		    } else {
+		      Swig_name_namewarn_add(Namespaceprefix,(nname),0,kws);
+		    }
+		    Delete(nname);
+		  }
+		} else {
+		  if ((yyvsp[(1) - (7)].intvalue)) {
+		    Swig_name_rename_add(Namespaceprefix,(fixname),0,kws,(yyvsp[(5) - (7)].decl).parms);
+		  } else {
+		    Swig_name_namewarn_add(Namespaceprefix,(fixname),0,kws);
+		  }
+		}
+                (yyval.node) = 0;
+		scanner_clear_rename();
+              ;}
+    break;
+
+  case 85:
+#line 2519 "parser.y"
+    {
+		if ((yyvsp[(1) - (6)].intvalue)) {
+		  Swig_name_rename_add(Namespaceprefix,(yyvsp[(5) - (6)].str),0,(yyvsp[(3) - (6)].node),0);
+		} else {
+		  Swig_name_namewarn_add(Namespaceprefix,(yyvsp[(5) - (6)].str),0,(yyvsp[(3) - (6)].node));
+		}
+		(yyval.node) = 0;
+		scanner_clear_rename();
+              ;}
+    break;
+
+  case 86:
+#line 2530 "parser.y"
+    {
+		    (yyval.intvalue) = 1;
+                ;}
+    break;
+
+  case 87:
+#line 2533 "parser.y"
+    {
+                    (yyval.intvalue) = 0;
+                ;}
+    break;
+
+  case 88:
+#line 2560 "parser.y"
+    {
+                    String *val = (yyvsp[(7) - (7)].str) ? NewString((yyvsp[(7) - (7)].str)) : NewString("1");
+                    new_feature((yyvsp[(3) - (7)].id), val, 0, (yyvsp[(5) - (7)].decl).id, (yyvsp[(5) - (7)].decl).type, (yyvsp[(5) - (7)].decl).parms, (yyvsp[(6) - (7)].dtype).qualifier);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 89:
+#line 2566 "parser.y"
+    {
+                    String *val = Len((yyvsp[(5) - (9)].str)) ? (yyvsp[(5) - (9)].str) : 0;
+                    new_feature((yyvsp[(3) - (9)].id), val, 0, (yyvsp[(7) - (9)].decl).id, (yyvsp[(7) - (9)].decl).type, (yyvsp[(7) - (9)].decl).parms, (yyvsp[(8) - (9)].dtype).qualifier);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 90:
+#line 2572 "parser.y"
+    {
+                    String *val = (yyvsp[(8) - (8)].str) ? NewString((yyvsp[(8) - (8)].str)) : NewString("1");
+                    new_feature((yyvsp[(3) - (8)].id), val, (yyvsp[(4) - (8)].node), (yyvsp[(6) - (8)].decl).id, (yyvsp[(6) - (8)].decl).type, (yyvsp[(6) - (8)].decl).parms, (yyvsp[(7) - (8)].dtype).qualifier);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 91:
+#line 2578 "parser.y"
+    {
+                    String *val = Len((yyvsp[(5) - (10)].str)) ? (yyvsp[(5) - (10)].str) : 0;
+                    new_feature((yyvsp[(3) - (10)].id), val, (yyvsp[(6) - (10)].node), (yyvsp[(8) - (10)].decl).id, (yyvsp[(8) - (10)].decl).type, (yyvsp[(8) - (10)].decl).parms, (yyvsp[(9) - (10)].dtype).qualifier);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 92:
+#line 2586 "parser.y"
+    {
+                    String *val = (yyvsp[(5) - (5)].str) ? NewString((yyvsp[(5) - (5)].str)) : NewString("1");
+                    new_feature((yyvsp[(3) - (5)].id), val, 0, 0, 0, 0, 0);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 93:
+#line 2592 "parser.y"
+    {
+                    String *val = Len((yyvsp[(5) - (7)].str)) ? (yyvsp[(5) - (7)].str) : 0;
+                    new_feature((yyvsp[(3) - (7)].id), val, 0, 0, 0, 0, 0);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 94:
+#line 2598 "parser.y"
+    {
+                    String *val = (yyvsp[(6) - (6)].str) ? NewString((yyvsp[(6) - (6)].str)) : NewString("1");
+                    new_feature((yyvsp[(3) - (6)].id), val, (yyvsp[(4) - (6)].node), 0, 0, 0, 0);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 95:
+#line 2604 "parser.y"
+    {
+                    String *val = Len((yyvsp[(5) - (8)].str)) ? (yyvsp[(5) - (8)].str) : 0;
+                    new_feature((yyvsp[(3) - (8)].id), val, (yyvsp[(6) - (8)].node), 0, 0, 0, 0);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 96:
+#line 2612 "parser.y"
+    { (yyval.str) = (yyvsp[(1) - (1)].str); ;}
+    break;
+
+  case 97:
+#line 2613 "parser.y"
+    { (yyval.str) = 0; ;}
+    break;
+
+  case 98:
+#line 2614 "parser.y"
+    { (yyval.str) = (yyvsp[(3) - (5)].pl); ;}
+    break;
+
+  case 99:
+#line 2617 "parser.y"
+    {
+		  (yyval.node) = NewHash();
+		  Setattr((yyval.node),"name",(yyvsp[(2) - (4)].id));
+		  Setattr((yyval.node),"value",(yyvsp[(4) - (4)].str));
+                ;}
+    break;
+
+  case 100:
+#line 2622 "parser.y"
+    {
+		  (yyval.node) = NewHash();
+		  Setattr((yyval.node),"name",(yyvsp[(2) - (5)].id));
+		  Setattr((yyval.node),"value",(yyvsp[(4) - (5)].str));
+                  set_nextSibling((yyval.node),(yyvsp[(5) - (5)].node));
+                ;}
+    break;
+
+  case 101:
+#line 2632 "parser.y"
+    {
+                 Parm *val;
+		 String *name;
+		 SwigType *t;
+		 if (Namespaceprefix) name = NewStringf("%s::%s", Namespaceprefix, (yyvsp[(5) - (7)].decl).id);
+		 else name = NewString((yyvsp[(5) - (7)].decl).id);
+		 val = (yyvsp[(3) - (7)].pl);
+		 if ((yyvsp[(5) - (7)].decl).parms) {
+		   Setmeta(val,"parms",(yyvsp[(5) - (7)].decl).parms);
+		 }
+		 t = (yyvsp[(5) - (7)].decl).type;
+		 if (!Len(t)) t = 0;
+		 if (t) {
+		   if ((yyvsp[(6) - (7)].dtype).qualifier) SwigType_push(t,(yyvsp[(6) - (7)].dtype).qualifier);
+		   if (SwigType_isfunction(t)) {
+		     SwigType *decl = SwigType_pop_function(t);
+		     if (SwigType_ispointer(t)) {
+		       String *nname = NewStringf("*%s",name);
+		       Swig_feature_set(Swig_cparse_features(), nname, decl, "feature:varargs", val, 0);
+		       Delete(nname);
+		     } else {
+		       Swig_feature_set(Swig_cparse_features(), name, decl, "feature:varargs", val, 0);
+		     }
+		     Delete(decl);
+		   } else if (SwigType_ispointer(t)) {
+		     String *nname = NewStringf("*%s",name);
+		     Swig_feature_set(Swig_cparse_features(),nname,0,"feature:varargs",val, 0);
+		     Delete(nname);
+		   }
+		 } else {
+		   Swig_feature_set(Swig_cparse_features(),name,0,"feature:varargs",val, 0);
+		 }
+		 Delete(name);
+		 (yyval.node) = 0;
+              ;}
+    break;
+
+  case 102:
+#line 2668 "parser.y"
+    { (yyval.pl) = (yyvsp[(1) - (1)].pl); ;}
+    break;
+
+  case 103:
+#line 2669 "parser.y"
+    { 
+		  int i;
+		  int n;
+		  Parm *p;
+		  n = atoi(Char((yyvsp[(1) - (3)].dtype).val));
+		  if (n <= 0) {
+		    Swig_error(cparse_file, cparse_line,"Argument count in %%varargs must be positive.\n");
+		    (yyval.pl) = 0;
+		  } else {
+		    String *name = Getattr((yyvsp[(3) - (3)].p), "name");
+		    (yyval.pl) = Copy((yyvsp[(3) - (3)].p));
+		    if (name)
+		      Setattr((yyval.pl), "name", NewStringf("%s%d", name, n));
+		    for (i = 1; i < n; i++) {
+		      p = Copy((yyvsp[(3) - (3)].p));
+		      name = Getattr(p, "name");
+		      if (name)
+		        Setattr(p, "name", NewStringf("%s%d", name, n-i));
+		      set_nextSibling(p,(yyval.pl));
+		      Delete((yyval.pl));
+		      (yyval.pl) = p;
+		    }
+		  }
+                ;}
+    break;
+
+  case 104:
+#line 2704 "parser.y"
+    {
+		   (yyval.node) = 0;
+		   if ((yyvsp[(3) - (6)].tmap).method) {
+		     String *code = 0;
+		     (yyval.node) = new_node("typemap");
+		     Setattr((yyval.node),"method",(yyvsp[(3) - (6)].tmap).method);
+		     if ((yyvsp[(3) - (6)].tmap).kwargs) {
+		       ParmList *kw = (yyvsp[(3) - (6)].tmap).kwargs;
+                       code = remove_block(kw, (yyvsp[(6) - (6)].str));
+		       Setattr((yyval.node),"kwargs", (yyvsp[(3) - (6)].tmap).kwargs);
+		     }
+		     code = code ? code : NewString((yyvsp[(6) - (6)].str));
+		     Setattr((yyval.node),"code", code);
+		     Delete(code);
+		     appendChild((yyval.node),(yyvsp[(5) - (6)].p));
+		   }
+	       ;}
+    break;
+
+  case 105:
+#line 2721 "parser.y"
+    {
+		 (yyval.node) = 0;
+		 if ((yyvsp[(3) - (6)].tmap).method) {
+		   (yyval.node) = new_node("typemap");
+		   Setattr((yyval.node),"method",(yyvsp[(3) - (6)].tmap).method);
+		   appendChild((yyval.node),(yyvsp[(5) - (6)].p));
+		 }
+	       ;}
+    break;
+
+  case 106:
+#line 2729 "parser.y"
+    {
+		   (yyval.node) = 0;
+		   if ((yyvsp[(3) - (8)].tmap).method) {
+		     (yyval.node) = new_node("typemapcopy");
+		     Setattr((yyval.node),"method",(yyvsp[(3) - (8)].tmap).method);
+		     Setattr((yyval.node),"pattern", Getattr((yyvsp[(7) - (8)].p),"pattern"));
+		     appendChild((yyval.node),(yyvsp[(5) - (8)].p));
+		   }
+	       ;}
+    break;
+
+  case 107:
+#line 2742 "parser.y"
+    {
+		 String *name = Getattr((yyvsp[(1) - (1)].node), "name");
+		 Hash *p = nextSibling((yyvsp[(1) - (1)].node));
+		 (yyval.tmap).method = name;
+		 (yyval.tmap).kwargs = p;
+		 if (Getattr((yyvsp[(1) - (1)].node), "value")) {
+		   Swig_error(cparse_file, cparse_line,
+			      "%%typemap method shouldn't have a value specified.\n");
+		 }
+		 while (p) {
+		   if (!Getattr(p, "value")) {
+		     Swig_error(cparse_file, cparse_line,
+				"%%typemap attribute '%s' is missing its value.  If this is specifying the target language, that's no longer supported: use #ifdef SWIG<LANG> instead.\n",
+				Getattr(p, "name"));
+		     /* Set to empty value to avoid segfaults later. */
+		     Setattr(p, "value", NewStringEmpty());
+		   }
+		   p = nextSibling(p);
+		 }
+                ;}
+    break;
+
+  case 108:
+#line 2764 "parser.y"
+    {
+                 (yyval.p) = (yyvsp[(1) - (2)].p);
+		 set_nextSibling((yyval.p),(yyvsp[(2) - (2)].p));
+		;}
+    break;
+
+  case 109:
+#line 2770 "parser.y"
+    {
+                 (yyval.p) = (yyvsp[(2) - (3)].p);
+		 set_nextSibling((yyval.p),(yyvsp[(3) - (3)].p));
+                ;}
+    break;
+
+  case 110:
+#line 2774 "parser.y"
+    { (yyval.p) = 0;;}
+    break;
+
+  case 111:
+#line 2777 "parser.y"
+    {
+                  Parm *parm;
+		  SwigType_push((yyvsp[(1) - (2)].type),(yyvsp[(2) - (2)].decl).type);
+		  (yyval.p) = new_node("typemapitem");
+		  parm = NewParmWithoutFileLineInfo((yyvsp[(1) - (2)].type),(yyvsp[(2) - (2)].decl).id);
+		  Setattr((yyval.p),"pattern",parm);
+		  Setattr((yyval.p),"parms", (yyvsp[(2) - (2)].decl).parms);
+		  Delete(parm);
+		  /*		  $$ = NewParmWithoutFileLineInfo($1,$2.id);
+				  Setattr($$,"parms",$2.parms); */
+                ;}
+    break;
+
+  case 112:
+#line 2788 "parser.y"
+    {
+                  (yyval.p) = new_node("typemapitem");
+		  Setattr((yyval.p),"pattern",(yyvsp[(2) - (3)].pl));
+		  /*		  Setattr($$,"multitype",$2); */
+               ;}
+    break;
+
+  case 113:
+#line 2793 "parser.y"
+    {
+		 (yyval.p) = new_node("typemapitem");
+		 Setattr((yyval.p),"pattern", (yyvsp[(2) - (6)].pl));
+		 /*                 Setattr($$,"multitype",$2); */
+		 Setattr((yyval.p),"parms",(yyvsp[(5) - (6)].pl));
+               ;}
+    break;
+
+  case 114:
+#line 2806 "parser.y"
+    {
+                   (yyval.node) = new_node("types");
+		   Setattr((yyval.node),"parms",(yyvsp[(3) - (5)].pl));
+                   if ((yyvsp[(5) - (5)].str))
+		     Setattr((yyval.node),"convcode",NewString((yyvsp[(5) - (5)].str)));
+               ;}
+    break;
+
+  case 115:
+#line 2818 "parser.y"
+    {
+                  Parm *p, *tp;
+		  Node *n;
+		  Node *outer_class = currentOuterClass;
+		  Symtab *tscope = 0;
+		  int     specialized = 0;
+		  int     variadic = 0;
+
+		  (yyval.node) = 0;
+
+		  tscope = Swig_symbol_current();          /* Get the current scope */
+
+		  /* If the class name is qualified, we need to create or lookup namespace entries */
+		  (yyvsp[(5) - (9)].str) = resolve_create_node_scope((yyvsp[(5) - (9)].str), 0);
+
+		  if (nscope_inner && Strcmp(nodeType(nscope_inner), "class") == 0) {
+		    outer_class	= nscope_inner;
+		  }
+
+		  /*
+		    We use the new namespace entry 'nscope' only to
+		    emit the template node. The template parameters are
+		    resolved in the current 'tscope'.
+
+		    This is closer to the C++ (typedef) behavior.
+		  */
+		  n = Swig_cparse_template_locate((yyvsp[(5) - (9)].str),(yyvsp[(7) - (9)].p),tscope);
+
+		  /* Patch the argument types to respect namespaces */
+		  p = (yyvsp[(7) - (9)].p);
+		  while (p) {
+		    SwigType *value = Getattr(p,"value");
+		    if (!value) {
+		      SwigType *ty = Getattr(p,"type");
+		      if (ty) {
+			SwigType *rty = 0;
+			int reduce = template_reduce;
+			if (reduce || !SwigType_ispointer(ty)) {
+			  rty = Swig_symbol_typedef_reduce(ty,tscope);
+			  if (!reduce) reduce = SwigType_ispointer(rty);
+			}
+			ty = reduce ? Swig_symbol_type_qualify(rty,tscope) : Swig_symbol_type_qualify(ty,tscope);
+			Setattr(p,"type",ty);
+			Delete(ty);
+			Delete(rty);
+		      }
+		    } else {
+		      value = Swig_symbol_type_qualify(value,tscope);
+		      Setattr(p,"value",value);
+		      Delete(value);
+		    }
+
+		    p = nextSibling(p);
+		  }
+
+		  /* Look for the template */
+		  {
+                    Node *nn = n;
+                    Node *linklistend = 0;
+                    Node *linkliststart = 0;
+                    while (nn) {
+                      Node *templnode = 0;
+                      if (Strcmp(nodeType(nn),"template") == 0) {
+                        int nnisclass = (Strcmp(Getattr(nn,"templatetype"),"class") == 0); /* if not a templated class it is a templated function */
+                        Parm *tparms = Getattr(nn,"templateparms");
+                        if (!tparms) {
+                          specialized = 1;
+                        } else if (Getattr(tparms,"variadic") && strncmp(Char(Getattr(tparms,"variadic")), "1", 1)==0) {
+                          variadic = 1;
+                        }
+                        if (nnisclass && !variadic && !specialized && (ParmList_len((yyvsp[(7) - (9)].p)) > ParmList_len(tparms))) {
+                          Swig_error(cparse_file, cparse_line, "Too many template parameters. Maximum of %d.\n", ParmList_len(tparms));
+                        } else if (nnisclass && !specialized && ((ParmList_len((yyvsp[(7) - (9)].p)) < (ParmList_numrequired(tparms) - (variadic?1:0))))) { /* Variadic parameter is optional */
+                          Swig_error(cparse_file, cparse_line, "Not enough template parameters specified. %d required.\n", (ParmList_numrequired(tparms)-(variadic?1:0)) );
+                        } else if (!nnisclass && ((ParmList_len((yyvsp[(7) - (9)].p)) != ParmList_len(tparms)))) {
+                          /* must be an overloaded templated method - ignore it as it is overloaded with a different number of template parameters */
+                          nn = Getattr(nn,"sym:nextSibling"); /* repeat for overloaded templated functions */
+                          continue;
+                        } else {
+			  String *tname = Copy((yyvsp[(5) - (9)].str));
+                          int def_supplied = 0;
+                          /* Expand the template */
+			  Node *templ = Swig_symbol_clookup((yyvsp[(5) - (9)].str),0);
+			  Parm *targs = templ ? Getattr(templ,"templateparms") : 0;
+
+                          ParmList *temparms;
+                          if (specialized) temparms = CopyParmList((yyvsp[(7) - (9)].p));
+                          else temparms = CopyParmList(tparms);
+
+                          /* Create typedef's and arguments */
+                          p = (yyvsp[(7) - (9)].p);
+                          tp = temparms;
+                          if (!p && ParmList_len(p) != ParmList_len(temparms)) {
+                            /* we have no template parameters supplied in %template for a template that has default args*/
+                            p = tp;
+                            def_supplied = 1;
+                          }
+
+                          while (p) {
+                            String *value = Getattr(p,"value");
+                            if (def_supplied) {
+                              Setattr(p,"default","1");
+                            }
+                            if (value) {
+                              Setattr(tp,"value",value);
+                            } else {
+                              SwigType *ty = Getattr(p,"type");
+                              if (ty) {
+                                Setattr(tp,"type",ty);
+                              }
+                              Delattr(tp,"value");
+                            }
+			    /* fix default arg values */
+			    if (targs) {
+			      Parm *pi = temparms;
+			      Parm *ti = targs;
+			      String *tv = Getattr(tp,"value");
+			      if (!tv) tv = Getattr(tp,"type");
+			      while(pi != tp && ti && pi) {
+				String *name = Getattr(ti,"name");
+				String *value = Getattr(pi,"value");
+				if (!value) value = Getattr(pi,"type");
+				Replaceid(tv, name, value);
+				pi = nextSibling(pi);
+				ti = nextSibling(ti);
+			      }
+			    }
+                            p = nextSibling(p);
+                            tp = nextSibling(tp);
+                            if (!p && tp) {
+                              p = tp;
+                              def_supplied = 1;
+                            } else if (p && !tp) { /* Variadic template - tp < p */
+			      SWIG_WARN_NODE_BEGIN(nn);
+                              Swig_warning(WARN_CPP11_VARIADIC_TEMPLATE,cparse_file, cparse_line,"Only the first variadic template argument is currently supported.\n");
+			      SWIG_WARN_NODE_END(nn);
+                              break;
+                            }
+                          }
+
+                          templnode = copy_node(nn);
+			  update_nested_classes(templnode); /* update classes nested within template */
+                          /* We need to set the node name based on name used to instantiate */
+                          Setattr(templnode,"name",tname);
+			  Delete(tname);
+                          if (!specialized) {
+                            Delattr(templnode,"sym:typename");
+                          } else {
+                            Setattr(templnode,"sym:typename","1");
+                          }
+			  /* for now, nested %template is allowed only in the same scope as the template declaration */
+                          if ((yyvsp[(3) - (9)].id) && !(nnisclass && ((outer_class && (outer_class != Getattr(nn, "nested:outer")))
+			    ||(extendmode && current_class && (current_class != Getattr(nn, "nested:outer")))))) {
+			    /*
+			       Comment this out for 1.3.28. We need to
+			       re-enable it later but first we need to
+			       move %ignore from using %rename to use
+			       %feature(ignore).
+
+			       String *symname = Swig_name_make(templnode,0,$3,0,0);
+			    */
+			    String *symname = NewString((yyvsp[(3) - (9)].id));
+                            Swig_cparse_template_expand(templnode,symname,temparms,tscope);
+                            Setattr(templnode,"sym:name",symname);
+                          } else {
+                            static int cnt = 0;
+                            String *nname = NewStringf("__dummy_%d__", cnt++);
+                            Swig_cparse_template_expand(templnode,nname,temparms,tscope);
+                            Setattr(templnode,"sym:name",nname);
+                            SetFlag(templnode,"hidden");
+			    Delete(nname);
+                            Setattr(templnode,"feature:onlychildren", "typemap,typemapitem,typemapcopy,typedef,types,fragment,apply");
+			    if ((yyvsp[(3) - (9)].id)) {
+			      Swig_warning(WARN_PARSE_NESTED_TEMPLATE, cparse_file, cparse_line, "Named nested template instantiations not supported. Processing as if no name was given to %%template().\n");
+			    }
+                          }
+                          Delattr(templnode,"templatetype");
+                          Setattr(templnode,"template",nn);
+                          Setfile(templnode,cparse_file);
+                          Setline(templnode,cparse_line);
+                          Delete(temparms);
+			  if (outer_class && nnisclass) {
+			    SetFlag(templnode, "nested");
+			    Setattr(templnode, "nested:outer", outer_class);
+			  }
+                          add_symbols_copy(templnode);
+
+                          if (Strcmp(nodeType(templnode),"class") == 0) {
+
+                            /* Identify pure abstract methods */
+                            Setattr(templnode,"abstracts", pure_abstracts(firstChild(templnode)));
+
+                            /* Set up inheritance in symbol table */
+                            {
+                              Symtab  *csyms;
+                              List *baselist = Getattr(templnode,"baselist");
+                              csyms = Swig_symbol_current();
+                              Swig_symbol_setscope(Getattr(templnode,"symtab"));
+                              if (baselist) {
+                                List *bases = Swig_make_inherit_list(Getattr(templnode,"name"),baselist, Namespaceprefix);
+                                if (bases) {
+                                  Iterator s;
+                                  for (s = First(bases); s.item; s = Next(s)) {
+                                    Symtab *st = Getattr(s.item,"symtab");
+                                    if (st) {
+				      Setfile(st,Getfile(s.item));
+				      Setline(st,Getline(s.item));
+                                      Swig_symbol_inherit(st);
+                                    }
+                                  }
+				  Delete(bases);
+                                }
+                              }
+                              Swig_symbol_setscope(csyms);
+                            }
+
+                            /* Merge in %extend methods for this class.
+			       This only merges methods within %extend for a template specialized class such as
+			         template<typename T> class K {}; %extend K<int> { ... }
+			       The copy_node() call above has already added in the generic %extend methods such as
+			         template<typename T> class K {}; %extend K { ... } */
+
+			    /* !!! This may be broken.  We may have to add the
+			       %extend methods at the beginning of the class */
+                            {
+                              String *stmp = 0;
+                              String *clsname;
+                              Node *am;
+                              if (Namespaceprefix) {
+                                clsname = stmp = NewStringf("%s::%s", Namespaceprefix, Getattr(templnode,"name"));
+                              } else {
+                                clsname = Getattr(templnode,"name");
+                              }
+                              am = Getattr(Swig_extend_hash(),clsname);
+                              if (am) {
+                                Symtab *st = Swig_symbol_current();
+                                Swig_symbol_setscope(Getattr(templnode,"symtab"));
+                                /*			    Printf(stdout,"%s: %s %p %p\n", Getattr(templnode,"name"), clsname, Swig_symbol_current(), Getattr(templnode,"symtab")); */
+                                Swig_extend_merge(templnode,am);
+                                Swig_symbol_setscope(st);
+				Swig_extend_append_previous(templnode,am);
+                                Delattr(Swig_extend_hash(),clsname);
+                              }
+			      if (stmp) Delete(stmp);
+                            }
+
+                            /* Add to classes hash */
+			    if (!classes)
+			      classes = NewHash();
+
+			    if (Namespaceprefix) {
+			      String *temp = NewStringf("%s::%s", Namespaceprefix, Getattr(templnode,"name"));
+			      Setattr(classes,temp,templnode);
+			      Delete(temp);
+			    } else {
+			      String *qs = Swig_symbol_qualifiedscopename(templnode);
+			      Setattr(classes, qs,templnode);
+			      Delete(qs);
+			    }
+                          }
+                        }
+
+                        /* all the overloaded templated functions are added into a linked list */
+                        if (!linkliststart)
+                          linkliststart = templnode;
+                        if (nscope_inner) {
+                          /* non-global namespace */
+                          if (templnode) {
+                            appendChild(nscope_inner,templnode);
+			    Delete(templnode);
+                            if (nscope) (yyval.node) = nscope;
+                          }
+                        } else {
+                          /* global namespace */
+                          if (!linklistend) {
+                            (yyval.node) = templnode;
+                          } else {
+                            set_nextSibling(linklistend,templnode);
+			    Delete(templnode);
+                          }
+                          linklistend = templnode;
+                        }
+                      }
+                      nn = Getattr(nn,"sym:nextSibling"); /* repeat for overloaded templated functions. If a templated class there will never be a sibling. */
+                    }
+                    update_defaultargs(linkliststart);
+                    update_abstracts(linkliststart);
+		  }
+	          Swig_symbol_setscope(tscope);
+		  Delete(Namespaceprefix);
+		  Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+                ;}
+    break;
+
+  case 116:
+#line 3117 "parser.y"
+    {
+		  Swig_warning(0,cparse_file, cparse_line,"%s\n", (yyvsp[(2) - (2)].str));
+		  (yyval.node) = 0;
+               ;}
+    break;
+
+  case 117:
+#line 3127 "parser.y"
+    {
+                    (yyval.node) = (yyvsp[(1) - (1)].node); 
+                    if ((yyval.node)) {
+   		      add_symbols((yyval.node));
+                      default_arguments((yyval.node));
+   	            }
+                ;}
+    break;
+
+  case 118:
+#line 3134 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 119:
+#line 3135 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 120:
+#line 3139 "parser.y"
+    {
+		  if (Strcmp((yyvsp[(2) - (3)].str),"C") == 0) {
+		    cparse_externc = 1;
+		  }
+		;}
+    break;
+
+  case 121:
+#line 3143 "parser.y"
+    {
+		  cparse_externc = 0;
+		  if (Strcmp((yyvsp[(2) - (6)].str),"C") == 0) {
+		    Node *n = firstChild((yyvsp[(5) - (6)].node));
+		    (yyval.node) = new_node("extern");
+		    Setattr((yyval.node),"name",(yyvsp[(2) - (6)].str));
+		    appendChild((yyval.node),n);
+		    while (n) {
+		      String *s = Getattr(n, "storage");
+		      if (s) {
+			if (Strstr(s, "thread_local")) {
+			  Insert(s,0,"externc ");
+			} else if (!Equal(s, "typedef")) {
+			  Setattr(n,"storage","externc");
+			}
+		      } else {
+			Setattr(n,"storage","externc");
+		      }
+		      n = nextSibling(n);
+		    }
+		  } else {
+		    if (!Equal((yyvsp[(2) - (6)].str),"C++")) {
+		      Swig_warning(WARN_PARSE_UNDEFINED_EXTERN,cparse_file, cparse_line,"Unrecognized extern type \"%s\".\n", (yyvsp[(2) - (6)].str));
+		    }
+		    (yyval.node) = new_node("extern");
+		    Setattr((yyval.node),"name",(yyvsp[(2) - (6)].str));
+		    appendChild((yyval.node),firstChild((yyvsp[(5) - (6)].node)));
+		  }
+                ;}
+    break;
+
+  case 122:
+#line 3172 "parser.y"
+    {
+		  (yyval.node) = (yyvsp[(1) - (1)].node);
+		  SWIG_WARN_NODE_BEGIN((yyval.node));
+		  Swig_warning(WARN_CPP11_LAMBDA, cparse_file, cparse_line, "Lambda expressions and closures are not fully supported yet.\n");
+		  SWIG_WARN_NODE_END((yyval.node));
+		;}
+    break;
+
+  case 123:
+#line 3178 "parser.y"
+    {
+		  /* Convert using statement to a typedef statement */
+		  (yyval.node) = new_node("cdecl");
+		  Setattr((yyval.node),"type",(yyvsp[(4) - (6)].type));
+		  Setattr((yyval.node),"storage","typedef");
+		  Setattr((yyval.node),"name",(yyvsp[(2) - (6)].str));
+		  Setattr((yyval.node),"decl",(yyvsp[(5) - (6)].decl).type);
+		  SetFlag((yyval.node),"typealias");
+		  add_symbols((yyval.node));
+		;}
+    break;
+
+  case 124:
+#line 3188 "parser.y"
+    {
+		  /* Convert alias template to a "template" typedef statement */
+		  (yyval.node) = new_node("template");
+		  Setattr((yyval.node),"type",(yyvsp[(8) - (10)].type));
+		  Setattr((yyval.node),"storage","typedef");
+		  Setattr((yyval.node),"name",(yyvsp[(6) - (10)].str));
+		  Setattr((yyval.node),"decl",(yyvsp[(9) - (10)].decl).type);
+		  Setattr((yyval.node),"templateparms",(yyvsp[(3) - (10)].tparms));
+		  Setattr((yyval.node),"templatetype","cdecl");
+		  SetFlag((yyval.node),"aliastemplate");
+		  add_symbols((yyval.node));
+		;}
+    break;
+
+  case 125:
+#line 3200 "parser.y"
+    {
+                   (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 126:
+#line 3209 "parser.y"
+    {
+	      String *decl = (yyvsp[(3) - (6)].decl).type;
+              (yyval.node) = new_node("cdecl");
+	      if ((yyvsp[(4) - (6)].dtype).qualifier)
+	        decl = add_qualifier_to_declarator((yyvsp[(3) - (6)].decl).type, (yyvsp[(4) - (6)].dtype).qualifier);
+	      Setattr((yyval.node),"refqualifier",(yyvsp[(4) - (6)].dtype).refqualifier);
+	      Setattr((yyval.node),"type",(yyvsp[(2) - (6)].type));
+	      Setattr((yyval.node),"storage",(yyvsp[(1) - (6)].id));
+	      Setattr((yyval.node),"name",(yyvsp[(3) - (6)].decl).id);
+	      Setattr((yyval.node),"decl",decl);
+	      Setattr((yyval.node),"parms",(yyvsp[(3) - (6)].decl).parms);
+	      Setattr((yyval.node),"value",(yyvsp[(5) - (6)].dtype).val);
+	      Setattr((yyval.node),"throws",(yyvsp[(4) - (6)].dtype).throws);
+	      Setattr((yyval.node),"throw",(yyvsp[(4) - (6)].dtype).throwf);
+	      Setattr((yyval.node),"noexcept",(yyvsp[(4) - (6)].dtype).nexcept);
+	      Setattr((yyval.node),"final",(yyvsp[(4) - (6)].dtype).final);
+	      if ((yyvsp[(5) - (6)].dtype).val && (yyvsp[(5) - (6)].dtype).type) {
+		/* store initializer type as it might be different to the declared type */
+		SwigType *valuetype = NewSwigType((yyvsp[(5) - (6)].dtype).type);
+		if (Len(valuetype) > 0)
+		  Setattr((yyval.node),"valuetype",valuetype);
+		else
+		  Delete(valuetype);
+	      }
+	      if (!(yyvsp[(6) - (6)].node)) {
+		if (Len(scanner_ccode)) {
+		  String *code = Copy(scanner_ccode);
+		  Setattr((yyval.node),"code",code);
+		  Delete(code);
+		}
+	      } else {
+		Node *n = (yyvsp[(6) - (6)].node);
+		/* Inherit attributes */
+		while (n) {
+		  String *type = Copy((yyvsp[(2) - (6)].type));
+		  Setattr(n,"type",type);
+		  Setattr(n,"storage",(yyvsp[(1) - (6)].id));
+		  n = nextSibling(n);
+		  Delete(type);
+		}
+	      }
+	      if ((yyvsp[(5) - (6)].dtype).bitfield) {
+		Setattr((yyval.node),"bitfield", (yyvsp[(5) - (6)].dtype).bitfield);
+	      }
+
+	      if ((yyvsp[(3) - (6)].decl).id) {
+		/* Look for "::" declarations (ignored) */
+		if (Strstr((yyvsp[(3) - (6)].decl).id, "::")) {
+		  /* This is a special case. If the scope name of the declaration exactly
+		     matches that of the declaration, then we will allow it. Otherwise, delete. */
+		  String *p = Swig_scopename_prefix((yyvsp[(3) - (6)].decl).id);
+		  if (p) {
+		    if ((Namespaceprefix && Strcmp(p, Namespaceprefix) == 0) ||
+			(Classprefix && Strcmp(p, Classprefix) == 0)) {
+		      String *lstr = Swig_scopename_last((yyvsp[(3) - (6)].decl).id);
+		      Setattr((yyval.node), "name", lstr);
+		      Delete(lstr);
+		      set_nextSibling((yyval.node), (yyvsp[(6) - (6)].node));
+		    } else {
+		      Delete((yyval.node));
+		      (yyval.node) = (yyvsp[(6) - (6)].node);
+		    }
+		    Delete(p);
+		  } else {
+		    Delete((yyval.node));
+		    (yyval.node) = (yyvsp[(6) - (6)].node);
+		  }
+		} else {
+		  set_nextSibling((yyval.node), (yyvsp[(6) - (6)].node));
+		}
+	      } else {
+		Swig_error(cparse_file, cparse_line, "Missing symbol name for global declaration\n");
+		(yyval.node) = 0;
+	      }
+
+	      if ((yyvsp[(4) - (6)].dtype).qualifier && (yyvsp[(1) - (6)].id) && Strstr((yyvsp[(1) - (6)].id), "static"))
+		Swig_error(cparse_file, cparse_line, "Static function %s cannot have a qualifier.\n", Swig_name_decl((yyval.node)));
+           ;}
+    break;
+
+  case 127:
+#line 3289 "parser.y"
+    {
+              (yyval.node) = new_node("cdecl");
+	      if ((yyvsp[(4) - (9)].dtype).qualifier) SwigType_push((yyvsp[(3) - (9)].decl).type, (yyvsp[(4) - (9)].dtype).qualifier);
+	      Setattr((yyval.node),"refqualifier",(yyvsp[(4) - (9)].dtype).refqualifier);
+	      Setattr((yyval.node),"type",(yyvsp[(6) - (9)].node));
+	      Setattr((yyval.node),"storage",(yyvsp[(1) - (9)].id));
+	      Setattr((yyval.node),"name",(yyvsp[(3) - (9)].decl).id);
+	      Setattr((yyval.node),"decl",(yyvsp[(3) - (9)].decl).type);
+	      Setattr((yyval.node),"parms",(yyvsp[(3) - (9)].decl).parms);
+	      Setattr((yyval.node),"value",(yyvsp[(4) - (9)].dtype).val);
+	      Setattr((yyval.node),"throws",(yyvsp[(4) - (9)].dtype).throws);
+	      Setattr((yyval.node),"throw",(yyvsp[(4) - (9)].dtype).throwf);
+	      Setattr((yyval.node),"noexcept",(yyvsp[(4) - (9)].dtype).nexcept);
+	      Setattr((yyval.node),"final",(yyvsp[(4) - (9)].dtype).final);
+	      if (!(yyvsp[(9) - (9)].node)) {
+		if (Len(scanner_ccode)) {
+		  String *code = Copy(scanner_ccode);
+		  Setattr((yyval.node),"code",code);
+		  Delete(code);
+		}
+	      } else {
+		Node *n = (yyvsp[(9) - (9)].node);
+		while (n) {
+		  String *type = Copy((yyvsp[(6) - (9)].node));
+		  Setattr(n,"type",type);
+		  Setattr(n,"storage",(yyvsp[(1) - (9)].id));
+		  n = nextSibling(n);
+		  Delete(type);
+		}
+	      }
+	      if ((yyvsp[(4) - (9)].dtype).bitfield) {
+		Setattr((yyval.node),"bitfield", (yyvsp[(4) - (9)].dtype).bitfield);
+	      }
+
+	      if (Strstr((yyvsp[(3) - (9)].decl).id,"::")) {
+                String *p = Swig_scopename_prefix((yyvsp[(3) - (9)].decl).id);
+		if (p) {
+		  if ((Namespaceprefix && Strcmp(p, Namespaceprefix) == 0) ||
+		      (Classprefix && Strcmp(p, Classprefix) == 0)) {
+		    String *lstr = Swig_scopename_last((yyvsp[(3) - (9)].decl).id);
+		    Setattr((yyval.node),"name",lstr);
+		    Delete(lstr);
+		    set_nextSibling((yyval.node), (yyvsp[(9) - (9)].node));
+		  } else {
+		    Delete((yyval.node));
+		    (yyval.node) = (yyvsp[(9) - (9)].node);
+		  }
+		  Delete(p);
+		} else {
+		  Delete((yyval.node));
+		  (yyval.node) = (yyvsp[(9) - (9)].node);
+		}
+	      } else {
+		set_nextSibling((yyval.node), (yyvsp[(9) - (9)].node));
+	      }
+
+	      if ((yyvsp[(4) - (9)].dtype).qualifier && (yyvsp[(1) - (9)].id) && Strstr((yyvsp[(1) - (9)].id), "static"))
+		Swig_error(cparse_file, cparse_line, "Static function %s cannot have a qualifier.\n", Swig_name_decl((yyval.node)));
+           ;}
+    break;
+
+  case 128:
+#line 3352 "parser.y"
+    { 
+                   (yyval.node) = 0;
+                   Clear(scanner_ccode); 
+               ;}
+    break;
+
+  case 129:
+#line 3356 "parser.y"
+    {
+		 (yyval.node) = new_node("cdecl");
+		 if ((yyvsp[(3) - (5)].dtype).qualifier) SwigType_push((yyvsp[(2) - (5)].decl).type,(yyvsp[(3) - (5)].dtype).qualifier);
+		 Setattr((yyval.node),"refqualifier",(yyvsp[(3) - (5)].dtype).refqualifier);
+		 Setattr((yyval.node),"name",(yyvsp[(2) - (5)].decl).id);
+		 Setattr((yyval.node),"decl",(yyvsp[(2) - (5)].decl).type);
+		 Setattr((yyval.node),"parms",(yyvsp[(2) - (5)].decl).parms);
+		 Setattr((yyval.node),"value",(yyvsp[(4) - (5)].dtype).val);
+		 Setattr((yyval.node),"throws",(yyvsp[(3) - (5)].dtype).throws);
+		 Setattr((yyval.node),"throw",(yyvsp[(3) - (5)].dtype).throwf);
+		 Setattr((yyval.node),"noexcept",(yyvsp[(3) - (5)].dtype).nexcept);
+		 Setattr((yyval.node),"final",(yyvsp[(3) - (5)].dtype).final);
+		 if ((yyvsp[(4) - (5)].dtype).bitfield) {
+		   Setattr((yyval.node),"bitfield", (yyvsp[(4) - (5)].dtype).bitfield);
+		 }
+		 if (!(yyvsp[(5) - (5)].node)) {
+		   if (Len(scanner_ccode)) {
+		     String *code = Copy(scanner_ccode);
+		     Setattr((yyval.node),"code",code);
+		     Delete(code);
+		   }
+		 } else {
+		   set_nextSibling((yyval.node), (yyvsp[(5) - (5)].node));
+		 }
+	       ;}
+    break;
+
+  case 130:
+#line 3381 "parser.y"
+    { 
+                   skip_balanced('{','}');
+                   (yyval.node) = 0;
+               ;}
+    break;
+
+  case 131:
+#line 3385 "parser.y"
+    {
+		   (yyval.node) = 0;
+		   if (yychar == RPAREN) {
+		       Swig_error(cparse_file, cparse_line, "Unexpected closing parenthesis (')').\n");
+		   } else {
+		       Swig_error(cparse_file, cparse_line, "Syntax error - possibly a missing semicolon (';').\n");
+		   }
+		   Exit(EXIT_FAILURE);
+               ;}
+    break;
+
+  case 132:
+#line 3396 "parser.y"
+    {
+                   (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+              ;}
+    break;
+
+  case 133:
+#line 3401 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 134:
+#line 3402 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 135:
+#line 3403 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 136:
+#line 3407 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 137:
+#line 3408 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].str); ;}
+    break;
+
+  case 138:
+#line 3409 "parser.y"
+    {
+                (yyval.node) = (yyvsp[(1) - (2)].str);
+                SwigType_add_reference((yyval.node));
+              ;}
+    break;
+
+  case 139:
+#line 3413 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 140:
+#line 3424 "parser.y"
+    {
+		  (yyval.node) = new_node("lambda");
+		  Setattr((yyval.node),"name",(yyvsp[(3) - (12)].str));
+		  add_symbols((yyval.node));
+	        ;}
+    break;
+
+  case 141:
+#line 3429 "parser.y"
+    {
+		  (yyval.node) = new_node("lambda");
+		  Setattr((yyval.node),"name",(yyvsp[(3) - (14)].str));
+		  add_symbols((yyval.node));
+		;}
+    break;
+
+  case 142:
+#line 3434 "parser.y"
+    {
+		  (yyval.node) = new_node("lambda");
+		  Setattr((yyval.node),"name",(yyvsp[(3) - (8)].str));
+		  add_symbols((yyval.node));
+		;}
+    break;
+
+  case 143:
+#line 3441 "parser.y"
+    {
+		  skip_balanced('[',']');
+		  (yyval.node) = 0;
+	        ;}
+    break;
+
+  case 144:
+#line 3447 "parser.y"
+    {
+		  skip_balanced('<','>');
+		  (yyval.node) = 0;
+		;}
+    break;
+
+  case 145:
+#line 3451 "parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 146:
+#line 3454 "parser.y"
+    {
+		  skip_balanced('{','}');
+		  (yyval.node) = 0;
+		;}
+    break;
+
+  case 147:
+#line 3459 "parser.y"
+    {
+		  (yyval.pl) = 0;
+		;}
+    break;
+
+  case 148:
+#line 3462 "parser.y"
+    {
+		  skip_balanced('(',')');
+		;}
+    break;
+
+  case 149:
+#line 3464 "parser.y"
+    {
+		  (yyval.pl) = 0;
+		;}
+    break;
+
+  case 150:
+#line 3475 "parser.y"
+    {
+		   (yyval.node) = (char *)"enum";
+	      ;}
+    break;
+
+  case 151:
+#line 3478 "parser.y"
+    {
+		   (yyval.node) = (char *)"enum class";
+	      ;}
+    break;
+
+  case 152:
+#line 3481 "parser.y"
+    {
+		   (yyval.node) = (char *)"enum struct";
+	      ;}
+    break;
+
+  case 153:
+#line 3490 "parser.y"
+    {
+                   (yyval.node) = (yyvsp[(2) - (2)].type);
+              ;}
+    break;
+
+  case 154:
+#line 3493 "parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 155:
+#line 3500 "parser.y"
+    {
+		   SwigType *ty = 0;
+		   int scopedenum = (yyvsp[(3) - (5)].id) && !Equal((yyvsp[(2) - (5)].node), "enum");
+		   (yyval.node) = new_node("enumforward");
+		   ty = NewStringf("enum %s", (yyvsp[(3) - (5)].id));
+		   Setattr((yyval.node),"enumkey",(yyvsp[(2) - (5)].node));
+		   if (scopedenum)
+		     SetFlag((yyval.node), "scopedenum");
+		   Setattr((yyval.node),"name",(yyvsp[(3) - (5)].id));
+		   Setattr((yyval.node),"inherit",(yyvsp[(4) - (5)].node));
+		   Setattr((yyval.node),"type",ty);
+		   Setattr((yyval.node),"sym:weak", "1");
+		   add_symbols((yyval.node));
+	      ;}
+    break;
+
+  case 156:
+#line 3522 "parser.y"
+    {
+		  SwigType *ty = 0;
+		  int scopedenum = (yyvsp[(3) - (8)].id) && !Equal((yyvsp[(2) - (8)].node), "enum");
+                  (yyval.node) = new_node("enum");
+		  ty = NewStringf("enum %s", (yyvsp[(3) - (8)].id));
+		  Setattr((yyval.node),"enumkey",(yyvsp[(2) - (8)].node));
+		  if (scopedenum)
+		    SetFlag((yyval.node), "scopedenum");
+		  Setattr((yyval.node),"name",(yyvsp[(3) - (8)].id));
+		  Setattr((yyval.node),"inherit",(yyvsp[(4) - (8)].node));
+		  Setattr((yyval.node),"type",ty);
+		  appendChild((yyval.node),(yyvsp[(6) - (8)].node));
+		  add_symbols((yyval.node));      /* Add to tag space */
+
+		  if (scopedenum) {
+		    Swig_symbol_newscope();
+		    Swig_symbol_setscopename((yyvsp[(3) - (8)].id));
+		    Delete(Namespaceprefix);
+		    Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		  }
+
+		  add_symbols((yyvsp[(6) - (8)].node));      /* Add enum values to appropriate enum or enum class scope */
+
+		  if (scopedenum) {
+		    Setattr((yyval.node),"symtab", Swig_symbol_popscope());
+		    Delete(Namespaceprefix);
+		    Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		  }
+               ;}
+    break;
+
+  case 157:
+#line 3551 "parser.y"
+    {
+		 Node *n;
+		 SwigType *ty = 0;
+		 String   *unnamed = 0;
+		 int       unnamedinstance = 0;
+		 int scopedenum = (yyvsp[(3) - (11)].id) && !Equal((yyvsp[(2) - (11)].node), "enum");
+
+		 (yyval.node) = new_node("enum");
+		 Setattr((yyval.node),"enumkey",(yyvsp[(2) - (11)].node));
+		 if (scopedenum)
+		   SetFlag((yyval.node), "scopedenum");
+		 Setattr((yyval.node),"inherit",(yyvsp[(4) - (11)].node));
+		 if ((yyvsp[(3) - (11)].id)) {
+		   Setattr((yyval.node),"name",(yyvsp[(3) - (11)].id));
+		   ty = NewStringf("enum %s", (yyvsp[(3) - (11)].id));
+		 } else if ((yyvsp[(8) - (11)].decl).id) {
+		   unnamed = make_unnamed();
+		   ty = NewStringf("enum %s", unnamed);
+		   Setattr((yyval.node),"unnamed",unnamed);
+                   /* name is not set for unnamed enum instances, e.g. enum { foo } Instance; */
+		   if ((yyvsp[(1) - (11)].id) && Cmp((yyvsp[(1) - (11)].id),"typedef") == 0) {
+		     Setattr((yyval.node),"name",(yyvsp[(8) - (11)].decl).id);
+                   } else {
+                     unnamedinstance = 1;
+                   }
+		   Setattr((yyval.node),"storage",(yyvsp[(1) - (11)].id));
+		 }
+		 if ((yyvsp[(8) - (11)].decl).id && Cmp((yyvsp[(1) - (11)].id),"typedef") == 0) {
+		   Setattr((yyval.node),"tdname",(yyvsp[(8) - (11)].decl).id);
+                   Setattr((yyval.node),"allows_typedef","1");
+                 }
+		 appendChild((yyval.node),(yyvsp[(6) - (11)].node));
+		 n = new_node("cdecl");
+		 Setattr(n,"type",ty);
+		 Setattr(n,"name",(yyvsp[(8) - (11)].decl).id);
+		 Setattr(n,"storage",(yyvsp[(1) - (11)].id));
+		 Setattr(n,"decl",(yyvsp[(8) - (11)].decl).type);
+		 Setattr(n,"parms",(yyvsp[(8) - (11)].decl).parms);
+		 Setattr(n,"unnamed",unnamed);
+
+                 if (unnamedinstance) {
+		   SwigType *cty = NewString("enum ");
+		   Setattr((yyval.node),"type",cty);
+		   SetFlag((yyval.node),"unnamedinstance");
+		   SetFlag(n,"unnamedinstance");
+		   Delete(cty);
+                 }
+		 if ((yyvsp[(11) - (11)].node)) {
+		   Node *p = (yyvsp[(11) - (11)].node);
+		   set_nextSibling(n,p);
+		   while (p) {
+		     SwigType *cty = Copy(ty);
+		     Setattr(p,"type",cty);
+		     Setattr(p,"unnamed",unnamed);
+		     Setattr(p,"storage",(yyvsp[(1) - (11)].id));
+		     Delete(cty);
+		     p = nextSibling(p);
+		   }
+		 } else {
+		   if (Len(scanner_ccode)) {
+		     String *code = Copy(scanner_ccode);
+		     Setattr(n,"code",code);
+		     Delete(code);
+		   }
+		 }
+
+                 /* Ensure that typedef enum ABC {foo} XYZ; uses XYZ for sym:name, like structs.
+                  * Note that class_rename/yyrename are bit of a mess so used this simple approach to change the name. */
+                 if ((yyvsp[(8) - (11)].decl).id && (yyvsp[(3) - (11)].id) && Cmp((yyvsp[(1) - (11)].id),"typedef") == 0) {
+		   String *name = NewString((yyvsp[(8) - (11)].decl).id);
+                   Setattr((yyval.node), "parser:makename", name);
+		   Delete(name);
+                 }
+
+		 add_symbols((yyval.node));       /* Add enum to tag space */
+		 set_nextSibling((yyval.node),n);
+		 Delete(n);
+
+		 if (scopedenum) {
+		   Swig_symbol_newscope();
+		   Swig_symbol_setscopename((yyvsp[(3) - (11)].id));
+		   Delete(Namespaceprefix);
+		   Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		 }
+
+		 add_symbols((yyvsp[(6) - (11)].node));      /* Add enum values to appropriate enum or enum class scope */
+
+		 if (scopedenum) {
+		   Setattr((yyval.node),"symtab", Swig_symbol_popscope());
+		   Delete(Namespaceprefix);
+		   Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		 }
+
+	         add_symbols(n);
+		 Delete(unnamed);
+	       ;}
+    break;
+
+  case 158:
+#line 3649 "parser.y"
+    {
+                   /* This is a sick hack.  If the ctor_end has parameters,
+                      and the parms parameter only has 1 parameter, this
+                      could be a declaration of the form:
+
+                         type (id)(parms)
+
+			 Otherwise it's an error. */
+                    int err = 0;
+                    (yyval.node) = 0;
+
+		    if ((ParmList_len((yyvsp[(4) - (6)].pl)) == 1) && (!Swig_scopename_check((yyvsp[(2) - (6)].type)))) {
+		      SwigType *ty = Getattr((yyvsp[(4) - (6)].pl),"type");
+		      String *name = Getattr((yyvsp[(4) - (6)].pl),"name");
+		      err = 1;
+		      if (!name) {
+			(yyval.node) = new_node("cdecl");
+			Setattr((yyval.node),"type",(yyvsp[(2) - (6)].type));
+			Setattr((yyval.node),"storage",(yyvsp[(1) - (6)].id));
+			Setattr((yyval.node),"name",ty);
+
+			if ((yyvsp[(6) - (6)].decl).have_parms) {
+			  SwigType *decl = NewStringEmpty();
+			  SwigType_add_function(decl,(yyvsp[(6) - (6)].decl).parms);
+			  Setattr((yyval.node),"decl",decl);
+			  Setattr((yyval.node),"parms",(yyvsp[(6) - (6)].decl).parms);
+			  if (Len(scanner_ccode)) {
+			    String *code = Copy(scanner_ccode);
+			    Setattr((yyval.node),"code",code);
+			    Delete(code);
+			  }
+			}
+			if ((yyvsp[(6) - (6)].decl).defarg) {
+			  Setattr((yyval.node),"value",(yyvsp[(6) - (6)].decl).defarg);
+			}
+			Setattr((yyval.node),"throws",(yyvsp[(6) - (6)].decl).throws);
+			Setattr((yyval.node),"throw",(yyvsp[(6) - (6)].decl).throwf);
+			Setattr((yyval.node),"noexcept",(yyvsp[(6) - (6)].decl).nexcept);
+			Setattr((yyval.node),"final",(yyvsp[(6) - (6)].decl).final);
+			err = 0;
+		      }
+		    }
+		    if (err) {
+		      Swig_error(cparse_file,cparse_line,"Syntax error in input(2).\n");
+		      Exit(EXIT_FAILURE);
+		    }
+                ;}
+    break;
+
+  case 159:
+#line 3702 "parser.y"
+    {  (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 160:
+#line 3703 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 161:
+#line 3704 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 162:
+#line 3705 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 163:
+#line 3706 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 164:
+#line 3707 "parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 165:
+#line 3716 "parser.y"
+    {
+                   String *prefix;
+                   List *bases = 0;
+		   Node *scope = 0;
+		   String *code;
+		   (yyval.node) = new_node("class");
+		   Setline((yyval.node),cparse_start_line);
+		   Setattr((yyval.node),"kind",(yyvsp[(2) - (6)].id));
+		   if ((yyvsp[(5) - (6)].bases)) {
+		     Setattr((yyval.node),"baselist", Getattr((yyvsp[(5) - (6)].bases),"public"));
+		     Setattr((yyval.node),"protectedbaselist", Getattr((yyvsp[(5) - (6)].bases),"protected"));
+		     Setattr((yyval.node),"privatebaselist", Getattr((yyvsp[(5) - (6)].bases),"private"));
+		   }
+		   Setattr((yyval.node),"allows_typedef","1");
+
+		   /* preserve the current scope */
+		   Setattr((yyval.node),"prev_symtab",Swig_symbol_current());
+		  
+		   /* If the class name is qualified.  We need to create or lookup namespace/scope entries */
+		   scope = resolve_create_node_scope((yyvsp[(3) - (6)].str), 1);
+		   /* save nscope_inner to the class - it may be overwritten in nested classes*/
+		   Setattr((yyval.node), "nested:innerscope", nscope_inner);
+		   Setattr((yyval.node), "nested:nscope", nscope);
+		   Setfile(scope,cparse_file);
+		   Setline(scope,cparse_line);
+		   (yyvsp[(3) - (6)].str) = scope;
+		   Setattr((yyval.node),"name",(yyvsp[(3) - (6)].str));
+
+		   if (currentOuterClass) {
+		     SetFlag((yyval.node), "nested");
+		     Setattr((yyval.node), "nested:outer", currentOuterClass);
+		     set_access_mode((yyval.node));
+		   }
+		   Swig_features_get(Swig_cparse_features(), Namespaceprefix, Getattr((yyval.node), "name"), 0, (yyval.node));
+		   /* save yyrename to the class attribute, to be used later in add_symbols()*/
+		   Setattr((yyval.node), "class_rename", make_name((yyval.node), (yyvsp[(3) - (6)].str), 0));
+		   Setattr((yyval.node), "Classprefix", (yyvsp[(3) - (6)].str));
+		   Classprefix = NewString((yyvsp[(3) - (6)].str));
+		   /* Deal with inheritance  */
+		   if ((yyvsp[(5) - (6)].bases))
+		     bases = Swig_make_inherit_list((yyvsp[(3) - (6)].str),Getattr((yyvsp[(5) - (6)].bases),"public"),Namespaceprefix);
+		   prefix = SwigType_istemplate_templateprefix((yyvsp[(3) - (6)].str));
+		   if (prefix) {
+		     String *fbase, *tbase;
+		     if (Namespaceprefix) {
+		       fbase = NewStringf("%s::%s", Namespaceprefix,(yyvsp[(3) - (6)].str));
+		       tbase = NewStringf("%s::%s", Namespaceprefix, prefix);
+		     } else {
+		       fbase = Copy((yyvsp[(3) - (6)].str));
+		       tbase = Copy(prefix);
+		     }
+		     Swig_name_inherit(tbase,fbase);
+		     Delete(fbase);
+		     Delete(tbase);
+		   }
+                   if (strcmp((yyvsp[(2) - (6)].id),"class") == 0) {
+		     cplus_mode = CPLUS_PRIVATE;
+		   } else {
+		     cplus_mode = CPLUS_PUBLIC;
+		   }
+		   if (!cparse_cplusplus) {
+		     set_scope_to_global();
+		   }
+		   Swig_symbol_newscope();
+		   Swig_symbol_setscopename((yyvsp[(3) - (6)].str));
+		   Swig_inherit_base_symbols(bases);
+		   Delete(Namespaceprefix);
+		   Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		   cparse_start_line = cparse_line;
+
+		   /* If there are active template parameters, we need to make sure they are
+                      placed in the class symbol table so we can catch shadows */
+
+		   if (template_parameters) {
+		     Parm *tp = template_parameters;
+		     while(tp) {
+		       String *tpname = Copy(Getattr(tp,"name"));
+		       Node *tn = new_node("templateparm");
+		       Setattr(tn,"name",tpname);
+		       Swig_symbol_cadd(tpname,tn);
+		       tp = nextSibling(tp);
+		       Delete(tpname);
+		     }
+		   }
+		   Delete(prefix);
+		   inclass = 1;
+		   currentOuterClass = (yyval.node);
+		   if (cparse_cplusplusout) {
+		     /* save the structure declaration to declare it in global scope for C++ to see */
+		     code = get_raw_text_balanced('{', '}');
+		     Setattr((yyval.node), "code", code);
+		     Delete(code);
+		   }
+               ;}
+    break;
+
+  case 166:
+#line 3809 "parser.y"
+    {
+		   Node *p;
+		   SwigType *ty;
+		   Symtab *cscope;
+		   Node *am = 0;
+		   String *scpname = 0;
+		   (void) (yyvsp[(6) - (10)].node);
+		   (yyval.node) = currentOuterClass;
+		   currentOuterClass = Getattr((yyval.node), "nested:outer");
+		   nscope_inner = Getattr((yyval.node), "nested:innerscope");
+		   nscope = Getattr((yyval.node), "nested:nscope");
+		   Delattr((yyval.node), "nested:innerscope");
+		   Delattr((yyval.node), "nested:nscope");
+		   if (nscope_inner && Strcmp(nodeType(nscope_inner), "class") == 0) { /* actual parent class for this class */
+		     Node* forward_declaration = Swig_symbol_clookup_no_inherit(Getattr((yyval.node),"name"), Getattr(nscope_inner, "symtab"));
+		     if (forward_declaration) {
+		       Setattr((yyval.node), "access", Getattr(forward_declaration, "access"));
+		     }
+		     Setattr((yyval.node), "nested:outer", nscope_inner);
+		     SetFlag((yyval.node), "nested");
+                   }
+		   if (!currentOuterClass)
+		     inclass = 0;
+		   cscope = Getattr((yyval.node), "prev_symtab");
+		   Delattr((yyval.node), "prev_symtab");
+		   
+		   /* Check for pure-abstract class */
+		   Setattr((yyval.node),"abstracts", pure_abstracts((yyvsp[(8) - (10)].node)));
+		   
+		   /* This bit of code merges in a previously defined %extend directive (if any) */
+		   {
+		     String *clsname = Swig_symbol_qualifiedscopename(0);
+		     am = Getattr(Swig_extend_hash(), clsname);
+		     if (am) {
+		       Swig_extend_merge((yyval.node), am);
+		       Delattr(Swig_extend_hash(), clsname);
+		     }
+		     Delete(clsname);
+		   }
+		   if (!classes) classes = NewHash();
+		   scpname = Swig_symbol_qualifiedscopename(0);
+		   Setattr(classes, scpname, (yyval.node));
+
+		   appendChild((yyval.node), (yyvsp[(8) - (10)].node));
+		   
+		   if (am) 
+		     Swig_extend_append_previous((yyval.node), am);
+
+		   p = (yyvsp[(10) - (10)].node);
+		   if (p && !nscope_inner) {
+		     if (!cparse_cplusplus && currentOuterClass)
+		       appendChild(currentOuterClass, p);
+		     else
+		      appendSibling((yyval.node), p);
+		   }
+		   
+		   if (nscope_inner) {
+		     ty = NewString(scpname); /* if the class is declared out of scope, let the declarator use fully qualified type*/
+		   } else if (cparse_cplusplus && !cparse_externc) {
+		     ty = NewString((yyvsp[(3) - (10)].str));
+		   } else {
+		     ty = NewStringf("%s %s", (yyvsp[(2) - (10)].id), (yyvsp[(3) - (10)].str));
+		   }
+		   while (p) {
+		     Setattr(p, "storage", (yyvsp[(1) - (10)].id));
+		     Setattr(p, "type" ,ty);
+		     if (!cparse_cplusplus && currentOuterClass && (!Getattr(currentOuterClass, "name"))) {
+		       SetFlag(p, "hasconsttype");
+		       SetFlag(p, "feature:immutable");
+		     }
+		     p = nextSibling(p);
+		   }
+		   if ((yyvsp[(10) - (10)].node) && Cmp((yyvsp[(1) - (10)].id),"typedef") == 0)
+		     add_typedef_name((yyval.node), (yyvsp[(10) - (10)].node), (yyvsp[(3) - (10)].str), cscope, scpname);
+		   Delete(scpname);
+
+		   if (cplus_mode != CPLUS_PUBLIC) {
+		   /* we 'open' the class at the end, to allow %template
+		      to add new members */
+		     Node *pa = new_node("access");
+		     Setattr(pa, "kind", "public");
+		     cplus_mode = CPLUS_PUBLIC;
+		     appendChild((yyval.node), pa);
+		     Delete(pa);
+		   }
+		   if (currentOuterClass)
+		     restore_access_mode((yyval.node));
+		   Setattr((yyval.node), "symtab", Swig_symbol_popscope());
+		   Classprefix = Getattr((yyval.node), "Classprefix");
+		   Delattr((yyval.node), "Classprefix");
+		   Delete(Namespaceprefix);
+		   Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		   if (cplus_mode == CPLUS_PRIVATE) {
+		     (yyval.node) = 0; /* skip private nested classes */
+		   } else if (cparse_cplusplus && currentOuterClass && ignore_nested_classes && !GetFlag((yyval.node), "feature:flatnested")) {
+		     (yyval.node) = nested_forward_declaration((yyvsp[(1) - (10)].id), (yyvsp[(2) - (10)].id), (yyvsp[(3) - (10)].str), Copy((yyvsp[(3) - (10)].str)), (yyvsp[(10) - (10)].node));
+		   } else if (nscope_inner) {
+		     /* this is tricky */
+		     /* we add the declaration in the original namespace */
+		     if (Strcmp(nodeType(nscope_inner), "class") == 0 && cparse_cplusplus && ignore_nested_classes && !GetFlag((yyval.node), "feature:flatnested"))
+		       (yyval.node) = nested_forward_declaration((yyvsp[(1) - (10)].id), (yyvsp[(2) - (10)].id), (yyvsp[(3) - (10)].str), Copy((yyvsp[(3) - (10)].str)), (yyvsp[(10) - (10)].node));
+		     appendChild(nscope_inner, (yyval.node));
+		     Swig_symbol_setscope(Getattr(nscope_inner, "symtab"));
+		     Delete(Namespaceprefix);
+		     Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		     yyrename = Copy(Getattr((yyval.node), "class_rename"));
+		     add_symbols((yyval.node));
+		     Delattr((yyval.node), "class_rename");
+		     /* but the variable definition in the current scope */
+		     Swig_symbol_setscope(cscope);
+		     Delete(Namespaceprefix);
+		     Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		     add_symbols((yyvsp[(10) - (10)].node));
+		     if (nscope) {
+		       (yyval.node) = nscope; /* here we return recreated namespace tower instead of the class itself */
+		       if ((yyvsp[(10) - (10)].node)) {
+			 appendSibling((yyval.node), (yyvsp[(10) - (10)].node));
+		       }
+		     } else if (!SwigType_istemplate(ty) && template_parameters == 0) { /* for template we need the class itself */
+		       (yyval.node) = (yyvsp[(10) - (10)].node);
+		     }
+		   } else {
+		     Delete(yyrename);
+		     yyrename = 0;
+		     if (!cparse_cplusplus && currentOuterClass) { /* nested C structs go into global scope*/
+		       Node *outer = currentOuterClass;
+		       while (Getattr(outer, "nested:outer"))
+			 outer = Getattr(outer, "nested:outer");
+		       appendSibling(outer, (yyval.node));
+		       Swig_symbol_setscope(cscope); /* declaration goes in the parent scope */
+		       add_symbols((yyvsp[(10) - (10)].node));
+		       set_scope_to_global();
+		       Delete(Namespaceprefix);
+		       Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		       yyrename = Copy(Getattr((yyval.node), "class_rename"));
+		       add_symbols((yyval.node));
+		       if (!cparse_cplusplusout)
+			 Delattr((yyval.node), "nested:outer");
+		       Delattr((yyval.node), "class_rename");
+		       (yyval.node) = 0;
+		     } else {
+		       yyrename = Copy(Getattr((yyval.node), "class_rename"));
+		       add_symbols((yyval.node));
+		       add_symbols((yyvsp[(10) - (10)].node));
+		       Delattr((yyval.node), "class_rename");
+		     }
+		   }
+		   Delete(ty);
+		   Swig_symbol_setscope(cscope);
+		   Delete(Namespaceprefix);
+		   Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		   Classprefix = currentOuterClass ? Getattr(currentOuterClass, "Classprefix") : 0;
+	       ;}
+    break;
+
+  case 167:
+#line 3965 "parser.y"
+    {
+	       String *unnamed;
+	       String *code;
+	       unnamed = make_unnamed();
+	       (yyval.node) = new_node("class");
+	       Setline((yyval.node),cparse_start_line);
+	       Setattr((yyval.node),"kind",(yyvsp[(2) - (4)].id));
+	       if ((yyvsp[(3) - (4)].bases)) {
+		 Setattr((yyval.node),"baselist", Getattr((yyvsp[(3) - (4)].bases),"public"));
+		 Setattr((yyval.node),"protectedbaselist", Getattr((yyvsp[(3) - (4)].bases),"protected"));
+		 Setattr((yyval.node),"privatebaselist", Getattr((yyvsp[(3) - (4)].bases),"private"));
+	       }
+	       Setattr((yyval.node),"storage",(yyvsp[(1) - (4)].id));
+	       Setattr((yyval.node),"unnamed",unnamed);
+	       Setattr((yyval.node),"allows_typedef","1");
+	       if (currentOuterClass) {
+		 SetFlag((yyval.node), "nested");
+		 Setattr((yyval.node), "nested:outer", currentOuterClass);
+		 set_access_mode((yyval.node));
+	       }
+	       Swig_features_get(Swig_cparse_features(), Namespaceprefix, 0, 0, (yyval.node));
+	       /* save yyrename to the class attribute, to be used later in add_symbols()*/
+	       Setattr((yyval.node), "class_rename", make_name((yyval.node),0,0));
+	       if (strcmp((yyvsp[(2) - (4)].id),"class") == 0) {
+		 cplus_mode = CPLUS_PRIVATE;
+	       } else {
+		 cplus_mode = CPLUS_PUBLIC;
+	       }
+	       Swig_symbol_newscope();
+	       cparse_start_line = cparse_line;
+	       currentOuterClass = (yyval.node);
+	       inclass = 1;
+	       Classprefix = 0;
+	       Delete(Namespaceprefix);
+	       Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+	       /* save the structure declaration to make a typedef for it later*/
+	       code = get_raw_text_balanced('{', '}');
+	       Setattr((yyval.node), "code", code);
+	       Delete(code);
+	     ;}
+    break;
+
+  case 168:
+#line 4004 "parser.y"
+    {
+	       String *unnamed;
+               List *bases = 0;
+	       String *name = 0;
+	       Node *n;
+	       Classprefix = 0;
+	       (void)(yyvsp[(5) - (8)].node);
+	       (yyval.node) = currentOuterClass;
+	       currentOuterClass = Getattr((yyval.node), "nested:outer");
+	       if (!currentOuterClass)
+		 inclass = 0;
+	       else
+		 restore_access_mode((yyval.node));
+	       unnamed = Getattr((yyval.node),"unnamed");
+               /* Check for pure-abstract class */
+	       Setattr((yyval.node),"abstracts", pure_abstracts((yyvsp[(6) - (8)].node)));
+	       n = (yyvsp[(8) - (8)].node);
+	       if (cparse_cplusplus && currentOuterClass && ignore_nested_classes && !GetFlag((yyval.node), "feature:flatnested")) {
+		 String *name = n ? Copy(Getattr(n, "name")) : 0;
+		 (yyval.node) = nested_forward_declaration((yyvsp[(1) - (8)].id), (yyvsp[(2) - (8)].id), 0, name, n);
+		 Swig_symbol_popscope();
+	         Delete(Namespaceprefix);
+		 Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+	       } else if (n) {
+	         appendSibling((yyval.node),n);
+		 /* If a proper typedef name was given, we'll use it to set the scope name */
+		 name = try_to_find_a_name_for_unnamed_structure((yyvsp[(1) - (8)].id), n);
+		 if (name) {
+		   String *scpname = 0;
+		   SwigType *ty;
+		   Setattr((yyval.node),"tdname",name);
+		   Setattr((yyval.node),"name",name);
+		   Swig_symbol_setscopename(name);
+		   if ((yyvsp[(3) - (8)].bases))
+		     bases = Swig_make_inherit_list(name,Getattr((yyvsp[(3) - (8)].bases),"public"),Namespaceprefix);
+		   Swig_inherit_base_symbols(bases);
+
+		     /* If a proper name was given, we use that as the typedef, not unnamed */
+		   Clear(unnamed);
+		   Append(unnamed, name);
+		   if (cparse_cplusplus && !cparse_externc) {
+		     ty = NewString(name);
+		   } else {
+		     ty = NewStringf("%s %s", (yyvsp[(2) - (8)].id),name);
+		   }
+		   while (n) {
+		     Setattr(n,"storage",(yyvsp[(1) - (8)].id));
+		     Setattr(n, "type", ty);
+		     if (!cparse_cplusplus && currentOuterClass && (!Getattr(currentOuterClass, "name"))) {
+		       SetFlag(n,"hasconsttype");
+		       SetFlag(n,"feature:immutable");
+		     }
+		     n = nextSibling(n);
+		   }
+		   n = (yyvsp[(8) - (8)].node);
+
+		   /* Check for previous extensions */
+		   {
+		     String *clsname = Swig_symbol_qualifiedscopename(0);
+		     Node *am = Getattr(Swig_extend_hash(),clsname);
+		     if (am) {
+		       /* Merge the extension into the symbol table */
+		       Swig_extend_merge((yyval.node),am);
+		       Swig_extend_append_previous((yyval.node),am);
+		       Delattr(Swig_extend_hash(),clsname);
+		     }
+		     Delete(clsname);
+		   }
+		   if (!classes) classes = NewHash();
+		   scpname = Swig_symbol_qualifiedscopename(0);
+		   Setattr(classes,scpname,(yyval.node));
+		   Delete(scpname);
+		 } else { /* no suitable name was found for a struct */
+		   Setattr((yyval.node), "nested:unnamed", Getattr(n, "name")); /* save the name of the first declarator for later use in name generation*/
+		   while (n) { /* attach unnamed struct to the declarators, so that they would receive proper type later*/
+		     Setattr(n, "nested:unnamedtype", (yyval.node));
+		     Setattr(n, "storage", (yyvsp[(1) - (8)].id));
+		     n = nextSibling(n);
+		   }
+		   n = (yyvsp[(8) - (8)].node);
+		   Swig_symbol_setscopename("<unnamed>");
+		 }
+		 appendChild((yyval.node),(yyvsp[(6) - (8)].node));
+		 /* Pop the scope */
+		 Setattr((yyval.node),"symtab",Swig_symbol_popscope());
+		 if (name) {
+		   Delete(yyrename);
+		   yyrename = Copy(Getattr((yyval.node), "class_rename"));
+		   Delete(Namespaceprefix);
+		   Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		   add_symbols((yyval.node));
+		   add_symbols(n);
+		   Delattr((yyval.node), "class_rename");
+		 }else if (cparse_cplusplus)
+		   (yyval.node) = 0; /* ignore unnamed structs for C++ */
+	         Delete(unnamed);
+	       } else { /* unnamed struct w/o declarator*/
+		 Swig_symbol_popscope();
+	         Delete(Namespaceprefix);
+		 Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		 add_symbols((yyvsp[(6) - (8)].node));
+		 Delete((yyval.node));
+		 (yyval.node) = (yyvsp[(6) - (8)].node); /* pass member list to outer class/namespace (instead of self)*/
+	       }
+	       Classprefix = currentOuterClass ? Getattr(currentOuterClass, "Classprefix") : 0;
+              ;}
+    break;
+
+  case 169:
+#line 4112 "parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 170:
+#line 4113 "parser.y"
+    {
+                        (yyval.node) = new_node("cdecl");
+                        Setattr((yyval.node),"name",(yyvsp[(1) - (4)].decl).id);
+                        Setattr((yyval.node),"decl",(yyvsp[(1) - (4)].decl).type);
+                        Setattr((yyval.node),"parms",(yyvsp[(1) - (4)].decl).parms);
+			set_nextSibling((yyval.node), (yyvsp[(4) - (4)].node));
+                    ;}
+    break;
+
+  case 171:
+#line 4125 "parser.y"
+    {
+              if ((yyvsp[(1) - (4)].id) && (Strcmp((yyvsp[(1) - (4)].id),"friend") == 0)) {
+		/* Ignore */
+                (yyval.node) = 0; 
+	      } else {
+		(yyval.node) = new_node("classforward");
+		Setattr((yyval.node),"kind",(yyvsp[(2) - (4)].id));
+		Setattr((yyval.node),"name",(yyvsp[(3) - (4)].str));
+		Setattr((yyval.node),"sym:weak", "1");
+		add_symbols((yyval.node));
+	      }
+             ;}
+    break;
+
+  case 172:
+#line 4143 "parser.y"
+    { 
+		    if (currentOuterClass)
+		      Setattr(currentOuterClass, "template_parameters", template_parameters);
+		    template_parameters = (yyvsp[(3) - (4)].tparms); 
+		    parsing_template_declaration = 1;
+		  ;}
+    break;
+
+  case 173:
+#line 4148 "parser.y"
+    {
+			String *tname = 0;
+			int     error = 0;
+
+			/* check if we get a namespace node with a class declaration, and retrieve the class */
+			Symtab *cscope = Swig_symbol_current();
+			Symtab *sti = 0;
+			Node *ntop = (yyvsp[(6) - (6)].node);
+			Node *ni = ntop;
+			SwigType *ntype = ni ? nodeType(ni) : 0;
+			while (ni && Strcmp(ntype,"namespace") == 0) {
+			  sti = Getattr(ni,"symtab");
+			  ni = firstChild(ni);
+			  ntype = nodeType(ni);
+			}
+			if (sti) {
+			  Swig_symbol_setscope(sti);
+			  Delete(Namespaceprefix);
+			  Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+			  (yyvsp[(6) - (6)].node) = ni;
+			}
+
+			(yyval.node) = (yyvsp[(6) - (6)].node);
+			if ((yyval.node)) tname = Getattr((yyval.node),"name");
+			
+			/* Check if the class is a template specialization */
+			if (((yyval.node)) && (Strchr(tname,'<')) && (!is_operator(tname))) {
+			  /* If a specialization.  Check if defined. */
+			  Node *tempn = 0;
+			  {
+			    String *tbase = SwigType_templateprefix(tname);
+			    tempn = Swig_symbol_clookup_local(tbase,0);
+			    if (!tempn || (Strcmp(nodeType(tempn),"template") != 0)) {
+			      SWIG_WARN_NODE_BEGIN(tempn);
+			      Swig_warning(WARN_PARSE_TEMPLATE_SP_UNDEF, Getfile((yyval.node)),Getline((yyval.node)),"Specialization of non-template '%s'.\n", tbase);
+			      SWIG_WARN_NODE_END(tempn);
+			      tempn = 0;
+			      error = 1;
+			    }
+			    Delete(tbase);
+			  }
+			  Setattr((yyval.node),"specialization","1");
+			  Setattr((yyval.node),"templatetype",nodeType((yyval.node)));
+			  set_nodeType((yyval.node),"template");
+			  /* Template partial specialization */
+			  if (tempn && ((yyvsp[(3) - (6)].tparms)) && ((yyvsp[(6) - (6)].node))) {
+			    List   *tlist;
+			    String *targs = SwigType_templateargs(tname);
+			    tlist = SwigType_parmlist(targs);
+			    /*			  Printf(stdout,"targs = '%s' %s\n", targs, tlist); */
+			    if (!Getattr((yyval.node),"sym:weak")) {
+			      Setattr((yyval.node),"sym:typename","1");
+			    }
+			    
+			    if (Len(tlist) != ParmList_len(Getattr(tempn,"templateparms"))) {
+			      Swig_error(Getfile((yyval.node)),Getline((yyval.node)),"Inconsistent argument count in template partial specialization. %d %d\n", Len(tlist), ParmList_len(Getattr(tempn,"templateparms")));
+			      
+			    } else {
+
+			    /* This code builds the argument list for the partial template
+			       specialization.  This is a little hairy, but the idea is as
+			       follows:
+
+			       $3 contains a list of arguments supplied for the template.
+			       For example template<class T>.
+
+			       tlist is a list of the specialization arguments--which may be
+			       different.  For example class<int,T>.
+
+			       tp is a copy of the arguments in the original template definition.
+       
+			       The patching algorithm walks through the list of supplied
+			       arguments ($3), finds the position in the specialization arguments
+			       (tlist), and then patches the name in the argument list of the
+			       original template.
+			    */
+
+			    {
+			      String *pn;
+			      Parm *p, *p1;
+			      int i, nargs;
+			      Parm *tp = CopyParmList(Getattr(tempn,"templateparms"));
+			      nargs = Len(tlist);
+			      p = (yyvsp[(3) - (6)].tparms);
+			      while (p) {
+				for (i = 0; i < nargs; i++){
+				  pn = Getattr(p,"name");
+				  if (Strcmp(pn,SwigType_base(Getitem(tlist,i))) == 0) {
+				    int j;
+				    Parm *p1 = tp;
+				    for (j = 0; j < i; j++) {
+				      p1 = nextSibling(p1);
+				    }
+				    Setattr(p1,"name",pn);
+				    Setattr(p1,"partialarg","1");
+				  }
+				}
+				p = nextSibling(p);
+			      }
+			      p1 = tp;
+			      i = 0;
+			      while (p1) {
+				if (!Getattr(p1,"partialarg")) {
+				  Delattr(p1,"name");
+				  Setattr(p1,"type", Getitem(tlist,i));
+				} 
+				i++;
+				p1 = nextSibling(p1);
+			      }
+			      Setattr((yyval.node),"templateparms",tp);
+			      Delete(tp);
+			    }
+  #if 0
+			    /* Patch the parameter list */
+			    if (tempn) {
+			      Parm *p,*p1;
+			      ParmList *tp = CopyParmList(Getattr(tempn,"templateparms"));
+			      p = (yyvsp[(3) - (6)].tparms);
+			      p1 = tp;
+			      while (p && p1) {
+				String *pn = Getattr(p,"name");
+				Printf(stdout,"pn = '%s'\n", pn);
+				if (pn) Setattr(p1,"name",pn);
+				else Delattr(p1,"name");
+				pn = Getattr(p,"type");
+				if (pn) Setattr(p1,"type",pn);
+				p = nextSibling(p);
+				p1 = nextSibling(p1);
+			      }
+			      Setattr((yyval.node),"templateparms",tp);
+			      Delete(tp);
+			    } else {
+			      Setattr((yyval.node),"templateparms",(yyvsp[(3) - (6)].tparms));
+			    }
+  #endif
+			    Delattr((yyval.node),"specialization");
+			    Setattr((yyval.node),"partialspecialization","1");
+			    /* Create a specialized name for matching */
+			    {
+			      Parm *p = (yyvsp[(3) - (6)].tparms);
+			      String *fname = NewString(Getattr((yyval.node),"name"));
+			      String *ffname = 0;
+			      ParmList *partialparms = 0;
+
+			      char   tmp[32];
+			      int    i, ilen;
+			      while (p) {
+				String *n = Getattr(p,"name");
+				if (!n) {
+				  p = nextSibling(p);
+				  continue;
+				}
+				ilen = Len(tlist);
+				for (i = 0; i < ilen; i++) {
+				  if (Strstr(Getitem(tlist,i),n)) {
+				    sprintf(tmp,"$%d",i+1);
+				    Replaceid(fname,n,tmp);
+				  }
+				}
+				p = nextSibling(p);
+			      }
+			      /* Patch argument names with typedef */
+			      {
+				Iterator tt;
+				Parm *parm_current = 0;
+				List *tparms = SwigType_parmlist(fname);
+				ffname = SwigType_templateprefix(fname);
+				Append(ffname,"<(");
+				for (tt = First(tparms); tt.item; ) {
+				  SwigType *rtt = Swig_symbol_typedef_reduce(tt.item,0);
+				  SwigType *ttr = Swig_symbol_type_qualify(rtt,0);
+
+				  Parm *newp = NewParmWithoutFileLineInfo(ttr, 0);
+				  if (partialparms)
+				    set_nextSibling(parm_current, newp);
+				  else
+				    partialparms = newp;
+				  parm_current = newp;
+
+				  Append(ffname,ttr);
+				  tt = Next(tt);
+				  if (tt.item) Putc(',',ffname);
+				  Delete(rtt);
+				  Delete(ttr);
+				}
+				Delete(tparms);
+				Append(ffname,")>");
+			      }
+			      {
+				Node *new_partial = NewHash();
+				String *partials = Getattr(tempn,"partials");
+				if (!partials) {
+				  partials = NewList();
+				  Setattr(tempn,"partials",partials);
+				  Delete(partials);
+				}
+				/*			      Printf(stdout,"partial: fname = '%s', '%s'\n", fname, Swig_symbol_typedef_reduce(fname,0)); */
+				Setattr(new_partial, "partialparms", partialparms);
+				Setattr(new_partial, "templcsymname", ffname);
+				Append(partials, new_partial);
+			      }
+			      Setattr((yyval.node),"partialargs",ffname);
+			      Swig_symbol_cadd(ffname,(yyval.node));
+			    }
+			    }
+			    Delete(tlist);
+			    Delete(targs);
+			  } else {
+			    /* An explicit template specialization */
+			    /* add default args from primary (unspecialized) template */
+			    String *ty = Swig_symbol_template_deftype(tname,0);
+			    String *fname = Swig_symbol_type_qualify(ty,0);
+			    Swig_symbol_cadd(fname,(yyval.node));
+			    Delete(ty);
+			    Delete(fname);
+			  }
+			}  else if ((yyval.node)) {
+			  Setattr((yyval.node),"templatetype",nodeType((yyvsp[(6) - (6)].node)));
+			  set_nodeType((yyval.node),"template");
+			  Setattr((yyval.node),"templateparms", (yyvsp[(3) - (6)].tparms));
+			  if (!Getattr((yyval.node),"sym:weak")) {
+			    Setattr((yyval.node),"sym:typename","1");
+			  }
+			  add_symbols((yyval.node));
+			  default_arguments((yyval.node));
+			  /* We also place a fully parameterized version in the symbol table */
+			  {
+			    Parm *p;
+			    String *fname = NewStringf("%s<(", Getattr((yyval.node),"name"));
+			    p = (yyvsp[(3) - (6)].tparms);
+			    while (p) {
+			      String *n = Getattr(p,"name");
+			      if (!n) n = Getattr(p,"type");
+			      Append(fname,n);
+			      p = nextSibling(p);
+			      if (p) Putc(',',fname);
+			    }
+			    Append(fname,")>");
+			    Swig_symbol_cadd(fname,(yyval.node));
+			  }
+			}
+			(yyval.node) = ntop;
+			Swig_symbol_setscope(cscope);
+			Delete(Namespaceprefix);
+			Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+			if (error || (nscope_inner && Strcmp(nodeType(nscope_inner), "class") == 0)) {
+			  (yyval.node) = 0;
+			}
+			if (currentOuterClass)
+			  template_parameters = Getattr(currentOuterClass, "template_parameters");
+			else
+			  template_parameters = 0;
+			parsing_template_declaration = 0;
+                ;}
+    break;
+
+  case 174:
+#line 4404 "parser.y"
+    {
+		  Swig_warning(WARN_PARSE_EXPLICIT_TEMPLATE, cparse_file, cparse_line, "Explicit template instantiation ignored.\n");
+                  (yyval.node) = 0; 
+		;}
+    break;
+
+  case 175:
+#line 4410 "parser.y"
+    {
+			Swig_warning(WARN_PARSE_EXPLICIT_TEMPLATE, cparse_file, cparse_line, "Explicit template instantiation ignored.\n");
+                  (yyval.node) = 0; 
+		;}
+    break;
+
+  case 176:
+#line 4416 "parser.y"
+    {
+		  Swig_warning(WARN_PARSE_EXTERN_TEMPLATE, cparse_file, cparse_line, "Extern template ignored.\n");
+                  (yyval.node) = 0; 
+                ;}
+    break;
+
+  case 177:
+#line 4422 "parser.y"
+    {
+			Swig_warning(WARN_PARSE_EXTERN_TEMPLATE, cparse_file, cparse_line, "Extern template ignored.\n");
+                  (yyval.node) = 0; 
+		;}
+    break;
+
+  case 178:
+#line 4428 "parser.y"
+    {
+		  (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 179:
+#line 4431 "parser.y"
+    {
+                   (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 180:
+#line 4434 "parser.y"
+    {
+                   (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 181:
+#line 4437 "parser.y"
+    {
+		  (yyval.node) = 0;
+                ;}
+    break;
+
+  case 182:
+#line 4440 "parser.y"
+    {
+                  (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 183:
+#line 4443 "parser.y"
+    {
+                  (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 184:
+#line 4448 "parser.y"
+    {
+		   /* Rip out the parameter names */
+		  Parm *p = (yyvsp[(1) - (1)].pl);
+		  (yyval.tparms) = (yyvsp[(1) - (1)].pl);
+
+		  while (p) {
+		    String *name = Getattr(p,"name");
+		    if (!name) {
+		      /* Hmmm. Maybe it's a 'class T' parameter */
+		      char *type = Char(Getattr(p,"type"));
+		      /* Template template parameter */
+		      if (strncmp(type,"template<class> ",16) == 0) {
+			type += 16;
+		      }
+		      if ((strncmp(type,"class ",6) == 0) || (strncmp(type,"typename ", 9) == 0)) {
+			char *t = strchr(type,' ');
+			Setattr(p,"name", t+1);
+		      } else 
+                      /* Variadic template args */
+		      if ((strncmp(type,"class... ",9) == 0) || (strncmp(type,"typename... ", 12) == 0)) {
+			char *t = strchr(type,' ');
+			Setattr(p,"name", t+1);
+			Setattr(p,"variadic", "1");
+		      } else {
+			/*
+			 Swig_error(cparse_file, cparse_line, "Missing template parameter name\n");
+			 $$.rparms = 0;
+			 $$.parms = 0;
+			 break; */
+		      }
+		    }
+		    p = nextSibling(p);
+		  }
+                 ;}
+    break;
+
+  case 185:
+#line 4484 "parser.y"
+    {
+                      set_nextSibling((yyvsp[(1) - (2)].p),(yyvsp[(2) - (2)].pl));
+                      (yyval.pl) = (yyvsp[(1) - (2)].p);
+                   ;}
+    break;
+
+  case 186:
+#line 4488 "parser.y"
+    { (yyval.pl) = 0; ;}
+    break;
+
+  case 187:
+#line 4491 "parser.y"
+    {
+		    (yyval.p) = NewParmWithoutFileLineInfo(NewString((yyvsp[(1) - (2)].id)), 0);
+		    Setattr((yyval.p), "value", (yyvsp[(2) - (2)].dtype).rawval ? (yyvsp[(2) - (2)].dtype).rawval : (yyvsp[(2) - (2)].dtype).val);
+                  ;}
+    break;
+
+  case 188:
+#line 4495 "parser.y"
+    {
+                    (yyval.p) = (yyvsp[(1) - (1)].p);
+                  ;}
+    break;
+
+  case 189:
+#line 4500 "parser.y"
+    {
+                         set_nextSibling((yyvsp[(2) - (3)].p),(yyvsp[(3) - (3)].pl));
+                         (yyval.pl) = (yyvsp[(2) - (3)].p);
+                       ;}
+    break;
+
+  case 190:
+#line 4504 "parser.y"
+    { (yyval.pl) = 0; ;}
+    break;
+
+  case 191:
+#line 4509 "parser.y"
+    {
+                  String *uname = Swig_symbol_type_qualify((yyvsp[(2) - (3)].str),0);
+		  String *name = Swig_scopename_last((yyvsp[(2) - (3)].str));
+                  (yyval.node) = new_node("using");
+		  Setattr((yyval.node),"uname",uname);
+		  Setattr((yyval.node),"name", name);
+		  Delete(uname);
+		  Delete(name);
+		  add_symbols((yyval.node));
+             ;}
+    break;
+
+  case 192:
+#line 4519 "parser.y"
+    {
+	       Node *n = Swig_symbol_clookup((yyvsp[(3) - (4)].str),0);
+	       if (!n) {
+		 Swig_error(cparse_file, cparse_line, "Nothing known about namespace '%s'\n", (yyvsp[(3) - (4)].str));
+		 (yyval.node) = 0;
+	       } else {
+
+		 while (Strcmp(nodeType(n),"using") == 0) {
+		   n = Getattr(n,"node");
+		 }
+		 if (n) {
+		   if (Strcmp(nodeType(n),"namespace") == 0) {
+		     Symtab *current = Swig_symbol_current();
+		     Symtab *symtab = Getattr(n,"symtab");
+		     (yyval.node) = new_node("using");
+		     Setattr((yyval.node),"node",n);
+		     Setattr((yyval.node),"namespace", (yyvsp[(3) - (4)].str));
+		     if (current != symtab) {
+		       Swig_symbol_inherit(symtab);
+		     }
+		   } else {
+		     Swig_error(cparse_file, cparse_line, "'%s' is not a namespace.\n", (yyvsp[(3) - (4)].str));
+		     (yyval.node) = 0;
+		   }
+		 } else {
+		   (yyval.node) = 0;
+		 }
+	       }
+             ;}
+    break;
+
+  case 193:
+#line 4550 "parser.y"
+    { 
+                Hash *h;
+		Node *parent_ns = 0;
+		List *scopes = Swig_scopename_tolist((yyvsp[(2) - (3)].str));
+		int ilen = Len(scopes);
+		int i;
+
+/*
+Printf(stdout, "==== Namespace %s creation...\n", $2);
+*/
+		(yyval.node) = 0;
+		for (i = 0; i < ilen; i++) {
+		  Node *ns = new_node("namespace");
+		  Symtab *current_symtab = Swig_symbol_current();
+		  String *scopename = Getitem(scopes, i);
+		  Setattr(ns, "name", scopename);
+		  (yyval.node) = ns;
+		  if (parent_ns)
+		    appendChild(parent_ns, ns);
+		  parent_ns = ns;
+		  h = Swig_symbol_clookup(scopename, 0);
+		  if (h && (current_symtab == Getattr(h, "sym:symtab")) && (Strcmp(nodeType(h), "namespace") == 0)) {
+/*
+Printf(stdout, "  Scope %s [found C++17 style]\n", scopename);
+*/
+		    if (Getattr(h, "alias")) {
+		      h = Getattr(h, "namespace");
+		      Swig_warning(WARN_PARSE_NAMESPACE_ALIAS, cparse_file, cparse_line, "Namespace alias '%s' not allowed here. Assuming '%s'\n",
+				   scopename, Getattr(h, "name"));
+		      scopename = Getattr(h, "name");
+		    }
+		    Swig_symbol_setscope(Getattr(h, "symtab"));
+		  } else {
+/*
+Printf(stdout, "  Scope %s [creating single scope C++17 style]\n", scopename);
+*/
+		    h = Swig_symbol_newscope();
+		    Swig_symbol_setscopename(scopename);
+		  }
+		  Delete(Namespaceprefix);
+		  Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		}
+		Delete(scopes);
+             ;}
+    break;
+
+  case 194:
+#line 4593 "parser.y"
+    {
+		Node *n = (yyvsp[(4) - (6)].node);
+		Node *top_ns = 0;
+		do {
+		  Setattr(n, "symtab", Swig_symbol_popscope());
+		  Delete(Namespaceprefix);
+		  Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+		  add_symbols(n);
+		  top_ns = n;
+		  n = parentNode(n);
+		} while(n);
+		appendChild((yyvsp[(4) - (6)].node), firstChild((yyvsp[(5) - (6)].node)));
+		Delete((yyvsp[(5) - (6)].node));
+		(yyval.node) = top_ns;
+             ;}
+    break;
+
+  case 195:
+#line 4608 "parser.y"
+    {
+	       Hash *h;
+	       (yyvsp[(1) - (2)].node) = Swig_symbol_current();
+	       h = Swig_symbol_clookup("    ",0);
+	       if (h && (Strcmp(nodeType(h),"namespace") == 0)) {
+		 Swig_symbol_setscope(Getattr(h,"symtab"));
+	       } else {
+		 Swig_symbol_newscope();
+		 /* we don't use "__unnamed__", but a long 'empty' name */
+		 Swig_symbol_setscopename("    ");
+	       }
+	       Namespaceprefix = 0;
+             ;}
+    break;
+
+  case 196:
+#line 4620 "parser.y"
+    {
+	       (yyval.node) = (yyvsp[(4) - (5)].node);
+	       set_nodeType((yyval.node),"namespace");
+	       Setattr((yyval.node),"unnamed","1");
+	       Setattr((yyval.node),"symtab", Swig_symbol_popscope());
+	       Swig_symbol_setscope((yyvsp[(1) - (5)].node));
+	       Delete(Namespaceprefix);
+	       Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+	       add_symbols((yyval.node));
+             ;}
+    break;
+
+  case 197:
+#line 4630 "parser.y"
+    {
+	       /* Namespace alias */
+	       Node *n;
+	       (yyval.node) = new_node("namespace");
+	       Setattr((yyval.node),"name",(yyvsp[(2) - (5)].id));
+	       Setattr((yyval.node),"alias",(yyvsp[(4) - (5)].str));
+	       n = Swig_symbol_clookup((yyvsp[(4) - (5)].str),0);
+	       if (!n) {
+		 Swig_error(cparse_file, cparse_line, "Unknown namespace '%s'\n", (yyvsp[(4) - (5)].str));
+		 (yyval.node) = 0;
+	       } else {
+		 if (Strcmp(nodeType(n),"namespace") != 0) {
+		   Swig_error(cparse_file, cparse_line, "'%s' is not a namespace\n",(yyvsp[(4) - (5)].str));
+		   (yyval.node) = 0;
+		 } else {
+		   while (Getattr(n,"alias")) {
+		     n = Getattr(n,"namespace");
+		   }
+		   Setattr((yyval.node),"namespace",n);
+		   add_symbols((yyval.node));
+		   /* Set up a scope alias */
+		   Swig_symbol_alias((yyvsp[(2) - (5)].id),Getattr(n,"symtab"));
+		 }
+	       }
+             ;}
+    break;
+
+  case 198:
+#line 4657 "parser.y"
+    {
+                   (yyval.node) = (yyvsp[(1) - (2)].node);
+                   /* Insert cpp_member (including any siblings) to the front of the cpp_members linked list */
+		   if ((yyval.node)) {
+		     Node *p = (yyval.node);
+		     Node *pp =0;
+		     while (p) {
+		       pp = p;
+		       p = nextSibling(p);
+		     }
+		     set_nextSibling(pp,(yyvsp[(2) - (2)].node));
+		     if ((yyvsp[(2) - (2)].node))
+		       set_previousSibling((yyvsp[(2) - (2)].node), pp);
+		   } else {
+		     (yyval.node) = (yyvsp[(2) - (2)].node);
+		   }
+             ;}
+    break;
+
+  case 199:
+#line 4674 "parser.y"
+    { 
+	       extendmode = 1;
+	       if (cplus_mode != CPLUS_PUBLIC) {
+		 Swig_error(cparse_file,cparse_line,"%%extend can only be used in a public section\n");
+	       }
+             ;}
+    break;
+
+  case 200:
+#line 4679 "parser.y"
+    {
+	       extendmode = 0;
+	     ;}
+    break;
+
+  case 201:
+#line 4681 "parser.y"
+    {
+	       (yyval.node) = new_node("extend");
+	       mark_nodes_as_extend((yyvsp[(4) - (7)].node));
+	       appendChild((yyval.node),(yyvsp[(4) - (7)].node));
+	       set_nextSibling((yyval.node),(yyvsp[(7) - (7)].node));
+	     ;}
+    break;
+
+  case 202:
+#line 4687 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 203:
+#line 4688 "parser.y"
+    { (yyval.node) = 0;;}
+    break;
+
+  case 204:
+#line 4689 "parser.y"
+    {
+	       Swig_error(cparse_file,cparse_line,"Syntax error in input(3).\n");
+	       Exit(EXIT_FAILURE);
+	       ;}
+    break;
+
+  case 205:
+#line 4692 "parser.y"
+    { 
+		 (yyval.node) = (yyvsp[(3) - (3)].node);
+   	     ;}
+    break;
+
+  case 206:
+#line 4703 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 207:
+#line 4704 "parser.y"
+    { 
+                 (yyval.node) = (yyvsp[(1) - (1)].node); 
+		 if (extendmode && current_class) {
+		   String *symname;
+		   symname= make_name((yyval.node),Getattr((yyval.node),"name"), Getattr((yyval.node),"decl"));
+		   if (Strcmp(symname,Getattr((yyval.node),"name")) == 0) {
+		     /* No renaming operation.  Set name to class name */
+		     Delete(yyrename);
+		     yyrename = NewString(Getattr(current_class,"sym:name"));
+		   } else {
+		     Delete(yyrename);
+		     yyrename = symname;
+		   }
+		 }
+		 add_symbols((yyval.node));
+                 default_arguments((yyval.node));
+             ;}
+    break;
+
+  case 208:
+#line 4721 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 209:
+#line 4722 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 210:
+#line 4723 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 211:
+#line 4724 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 212:
+#line 4725 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 213:
+#line 4726 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 214:
+#line 4727 "parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 215:
+#line 4728 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 216:
+#line 4729 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 217:
+#line 4730 "parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 218:
+#line 4731 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 219:
+#line 4732 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 220:
+#line 4733 "parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 221:
+#line 4734 "parser.y"
+    {(yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 222:
+#line 4735 "parser.y"
+    {(yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 223:
+#line 4736 "parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 224:
+#line 4738 "parser.y"
+    {
+		(yyval.node) = (yyvsp[(1) - (1)].node);
+	     ;}
+    break;
+
+  case 225:
+#line 4741 "parser.y"
+    {
+	         (yyval.node) = (yyvsp[(2) - (2)].node);
+		 set_comment((yyvsp[(2) - (2)].node), (yyvsp[(1) - (2)].str));
+	     ;}
+    break;
+
+  case 226:
+#line 4745 "parser.y"
+    {
+	         (yyval.node) = (yyvsp[(1) - (2)].node);
+		 set_comment((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].str));
+	     ;}
+    break;
+
+  case 227:
+#line 4757 "parser.y"
+    {
+              if (inclass || extendmode) {
+		SwigType *decl = NewStringEmpty();
+		(yyval.node) = new_node("constructor");
+		Setattr((yyval.node),"storage",(yyvsp[(1) - (6)].id));
+		Setattr((yyval.node),"name",(yyvsp[(2) - (6)].type));
+		Setattr((yyval.node),"parms",(yyvsp[(4) - (6)].pl));
+		SwigType_add_function(decl,(yyvsp[(4) - (6)].pl));
+		Setattr((yyval.node),"decl",decl);
+		Setattr((yyval.node),"throws",(yyvsp[(6) - (6)].decl).throws);
+		Setattr((yyval.node),"throw",(yyvsp[(6) - (6)].decl).throwf);
+		Setattr((yyval.node),"noexcept",(yyvsp[(6) - (6)].decl).nexcept);
+		Setattr((yyval.node),"final",(yyvsp[(6) - (6)].decl).final);
+		if (Len(scanner_ccode)) {
+		  String *code = Copy(scanner_ccode);
+		  Setattr((yyval.node),"code",code);
+		  Delete(code);
+		}
+		SetFlag((yyval.node),"feature:new");
+		if ((yyvsp[(6) - (6)].decl).defarg)
+		  Setattr((yyval.node),"value",(yyvsp[(6) - (6)].decl).defarg);
+	      } else {
+		(yyval.node) = 0;
+              }
+              ;}
+    break;
+
+  case 228:
+#line 4786 "parser.y"
+    {
+               String *name = NewStringf("%s",(yyvsp[(2) - (6)].str));
+	       if (*(Char(name)) != '~') Insert(name,0,"~");
+               (yyval.node) = new_node("destructor");
+	       Setattr((yyval.node),"name",name);
+	       Delete(name);
+	       if (Len(scanner_ccode)) {
+		 String *code = Copy(scanner_ccode);
+		 Setattr((yyval.node),"code",code);
+		 Delete(code);
+	       }
+	       {
+		 String *decl = NewStringEmpty();
+		 SwigType_add_function(decl,(yyvsp[(4) - (6)].pl));
+		 Setattr((yyval.node),"decl",decl);
+		 Delete(decl);
+	       }
+	       Setattr((yyval.node),"throws",(yyvsp[(6) - (6)].dtype).throws);
+	       Setattr((yyval.node),"throw",(yyvsp[(6) - (6)].dtype).throwf);
+	       Setattr((yyval.node),"noexcept",(yyvsp[(6) - (6)].dtype).nexcept);
+	       Setattr((yyval.node),"final",(yyvsp[(6) - (6)].dtype).final);
+	       if ((yyvsp[(6) - (6)].dtype).val)
+	         Setattr((yyval.node),"value",(yyvsp[(6) - (6)].dtype).val);
+	       if ((yyvsp[(6) - (6)].dtype).qualifier)
+		 Swig_error(cparse_file, cparse_line, "Destructor %s %s cannot have a qualifier.\n", Swig_name_decl((yyval.node)), SwigType_str((yyvsp[(6) - (6)].dtype).qualifier, 0));
+	       add_symbols((yyval.node));
+	      ;}
+    break;
+
+  case 229:
+#line 4816 "parser.y"
+    {
+		String *name;
+		(yyval.node) = new_node("destructor");
+		Setattr((yyval.node),"storage","virtual");
+	        name = NewStringf("%s",(yyvsp[(3) - (7)].str));
+		if (*(Char(name)) != '~') Insert(name,0,"~");
+		Setattr((yyval.node),"name",name);
+		Delete(name);
+		Setattr((yyval.node),"throws",(yyvsp[(7) - (7)].dtype).throws);
+		Setattr((yyval.node),"throw",(yyvsp[(7) - (7)].dtype).throwf);
+		Setattr((yyval.node),"noexcept",(yyvsp[(7) - (7)].dtype).nexcept);
+		Setattr((yyval.node),"final",(yyvsp[(7) - (7)].dtype).final);
+		if ((yyvsp[(7) - (7)].dtype).val)
+		  Setattr((yyval.node),"value",(yyvsp[(7) - (7)].dtype).val);
+		if (Len(scanner_ccode)) {
+		  String *code = Copy(scanner_ccode);
+		  Setattr((yyval.node),"code",code);
+		  Delete(code);
+		}
+		{
+		  String *decl = NewStringEmpty();
+		  SwigType_add_function(decl,(yyvsp[(5) - (7)].pl));
+		  Setattr((yyval.node),"decl",decl);
+		  Delete(decl);
+		}
+		if ((yyvsp[(7) - (7)].dtype).qualifier)
+		  Swig_error(cparse_file, cparse_line, "Destructor %s %s cannot have a qualifier.\n", Swig_name_decl((yyval.node)), SwigType_str((yyvsp[(7) - (7)].dtype).qualifier, 0));
+		add_symbols((yyval.node));
+	      ;}
+    break;
+
+  case 230:
+#line 4849 "parser.y"
+    {
+                 (yyval.node) = new_node("cdecl");
+                 Setattr((yyval.node),"type",(yyvsp[(3) - (8)].type));
+		 Setattr((yyval.node),"name",(yyvsp[(2) - (8)].str));
+		 Setattr((yyval.node),"storage",(yyvsp[(1) - (8)].id));
+
+		 SwigType_add_function((yyvsp[(4) - (8)].type),(yyvsp[(6) - (8)].pl));
+		 if ((yyvsp[(8) - (8)].dtype).qualifier) {
+		   SwigType_push((yyvsp[(4) - (8)].type),(yyvsp[(8) - (8)].dtype).qualifier);
+		 }
+		 if ((yyvsp[(8) - (8)].dtype).val) {
+		   Setattr((yyval.node),"value",(yyvsp[(8) - (8)].dtype).val);
+		 }
+		 Setattr((yyval.node),"refqualifier",(yyvsp[(8) - (8)].dtype).refqualifier);
+		 Setattr((yyval.node),"decl",(yyvsp[(4) - (8)].type));
+		 Setattr((yyval.node),"parms",(yyvsp[(6) - (8)].pl));
+		 Setattr((yyval.node),"conversion_operator","1");
+		 add_symbols((yyval.node));
+              ;}
+    break;
+
+  case 231:
+#line 4868 "parser.y"
+    {
+		 SwigType *decl;
+                 (yyval.node) = new_node("cdecl");
+                 Setattr((yyval.node),"type",(yyvsp[(3) - (8)].type));
+		 Setattr((yyval.node),"name",(yyvsp[(2) - (8)].str));
+		 Setattr((yyval.node),"storage",(yyvsp[(1) - (8)].id));
+		 decl = NewStringEmpty();
+		 SwigType_add_reference(decl);
+		 SwigType_add_function(decl,(yyvsp[(6) - (8)].pl));
+		 if ((yyvsp[(8) - (8)].dtype).qualifier) {
+		   SwigType_push(decl,(yyvsp[(8) - (8)].dtype).qualifier);
+		 }
+		 if ((yyvsp[(8) - (8)].dtype).val) {
+		   Setattr((yyval.node),"value",(yyvsp[(8) - (8)].dtype).val);
+		 }
+		 Setattr((yyval.node),"refqualifier",(yyvsp[(8) - (8)].dtype).refqualifier);
+		 Setattr((yyval.node),"decl",decl);
+		 Setattr((yyval.node),"parms",(yyvsp[(6) - (8)].pl));
+		 Setattr((yyval.node),"conversion_operator","1");
+		 add_symbols((yyval.node));
+	       ;}
+    break;
+
+  case 232:
+#line 4889 "parser.y"
+    {
+		 SwigType *decl;
+                 (yyval.node) = new_node("cdecl");
+                 Setattr((yyval.node),"type",(yyvsp[(3) - (8)].type));
+		 Setattr((yyval.node),"name",(yyvsp[(2) - (8)].str));
+		 Setattr((yyval.node),"storage",(yyvsp[(1) - (8)].id));
+		 decl = NewStringEmpty();
+		 SwigType_add_rvalue_reference(decl);
+		 SwigType_add_function(decl,(yyvsp[(6) - (8)].pl));
+		 if ((yyvsp[(8) - (8)].dtype).qualifier) {
+		   SwigType_push(decl,(yyvsp[(8) - (8)].dtype).qualifier);
+		 }
+		 if ((yyvsp[(8) - (8)].dtype).val) {
+		   Setattr((yyval.node),"value",(yyvsp[(8) - (8)].dtype).val);
+		 }
+		 Setattr((yyval.node),"refqualifier",(yyvsp[(8) - (8)].dtype).refqualifier);
+		 Setattr((yyval.node),"decl",decl);
+		 Setattr((yyval.node),"parms",(yyvsp[(6) - (8)].pl));
+		 Setattr((yyval.node),"conversion_operator","1");
+		 add_symbols((yyval.node));
+	       ;}
+    break;
+
+  case 233:
+#line 4911 "parser.y"
+    {
+		 SwigType *decl;
+                 (yyval.node) = new_node("cdecl");
+                 Setattr((yyval.node),"type",(yyvsp[(3) - (9)].type));
+		 Setattr((yyval.node),"name",(yyvsp[(2) - (9)].str));
+		 Setattr((yyval.node),"storage",(yyvsp[(1) - (9)].id));
+		 decl = NewStringEmpty();
+		 SwigType_add_pointer(decl);
+		 SwigType_add_reference(decl);
+		 SwigType_add_function(decl,(yyvsp[(7) - (9)].pl));
+		 if ((yyvsp[(9) - (9)].dtype).qualifier) {
+		   SwigType_push(decl,(yyvsp[(9) - (9)].dtype).qualifier);
+		 }
+		 if ((yyvsp[(9) - (9)].dtype).val) {
+		   Setattr((yyval.node),"value",(yyvsp[(9) - (9)].dtype).val);
+		 }
+		 Setattr((yyval.node),"refqualifier",(yyvsp[(9) - (9)].dtype).refqualifier);
+		 Setattr((yyval.node),"decl",decl);
+		 Setattr((yyval.node),"parms",(yyvsp[(7) - (9)].pl));
+		 Setattr((yyval.node),"conversion_operator","1");
+		 add_symbols((yyval.node));
+	       ;}
+    break;
+
+  case 234:
+#line 4934 "parser.y"
+    {
+		String *t = NewStringEmpty();
+		(yyval.node) = new_node("cdecl");
+		Setattr((yyval.node),"type",(yyvsp[(3) - (7)].type));
+		Setattr((yyval.node),"name",(yyvsp[(2) - (7)].str));
+		 Setattr((yyval.node),"storage",(yyvsp[(1) - (7)].id));
+		SwigType_add_function(t,(yyvsp[(5) - (7)].pl));
+		if ((yyvsp[(7) - (7)].dtype).qualifier) {
+		  SwigType_push(t,(yyvsp[(7) - (7)].dtype).qualifier);
+		}
+		if ((yyvsp[(7) - (7)].dtype).val) {
+		  Setattr((yyval.node),"value",(yyvsp[(7) - (7)].dtype).val);
+		}
+		Setattr((yyval.node),"refqualifier",(yyvsp[(7) - (7)].dtype).refqualifier);
+		Setattr((yyval.node),"decl",t);
+		Setattr((yyval.node),"parms",(yyvsp[(5) - (7)].pl));
+		Setattr((yyval.node),"conversion_operator","1");
+		add_symbols((yyval.node));
+              ;}
+    break;
+
+  case 235:
+#line 4957 "parser.y"
+    {
+                 skip_balanced('{','}');
+                 (yyval.node) = 0;
+               ;}
+    break;
+
+  case 236:
+#line 4965 "parser.y"
+    {
+                skip_balanced('(',')');
+                (yyval.node) = 0;
+              ;}
+    break;
+
+  case 237:
+#line 4972 "parser.y"
+    { 
+                (yyval.node) = new_node("access");
+		Setattr((yyval.node),"kind","public");
+                cplus_mode = CPLUS_PUBLIC;
+              ;}
+    break;
+
+  case 238:
+#line 4979 "parser.y"
+    { 
+                (yyval.node) = new_node("access");
+                Setattr((yyval.node),"kind","private");
+		cplus_mode = CPLUS_PRIVATE;
+	      ;}
+    break;
+
+  case 239:
+#line 4987 "parser.y"
+    { 
+		(yyval.node) = new_node("access");
+		Setattr((yyval.node),"kind","protected");
+		cplus_mode = CPLUS_PROTECTED;
+	      ;}
+    break;
+
+  case 240:
+#line 4995 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 241:
+#line 4998 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 242:
+#line 5002 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 243:
+#line 5005 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 244:
+#line 5006 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 245:
+#line 5007 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 246:
+#line 5008 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 247:
+#line 5009 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 248:
+#line 5010 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 249:
+#line 5011 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 250:
+#line 5012 "parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 251:
+#line 5015 "parser.y"
+    {
+	            Clear(scanner_ccode);
+		    (yyval.dtype).val = 0;
+		    (yyval.dtype).qualifier = (yyvsp[(1) - (2)].dtype).qualifier;
+		    (yyval.dtype).refqualifier = (yyvsp[(1) - (2)].dtype).refqualifier;
+		    (yyval.dtype).bitfield = 0;
+		    (yyval.dtype).throws = (yyvsp[(1) - (2)].dtype).throws;
+		    (yyval.dtype).throwf = (yyvsp[(1) - (2)].dtype).throwf;
+		    (yyval.dtype).nexcept = (yyvsp[(1) - (2)].dtype).nexcept;
+		    (yyval.dtype).final = (yyvsp[(1) - (2)].dtype).final;
+               ;}
+    break;
+
+  case 252:
+#line 5026 "parser.y"
+    {
+	            Clear(scanner_ccode);
+		    (yyval.dtype).val = (yyvsp[(3) - (4)].dtype).val;
+		    (yyval.dtype).qualifier = (yyvsp[(1) - (4)].dtype).qualifier;
+		    (yyval.dtype).refqualifier = (yyvsp[(1) - (4)].dtype).refqualifier;
+		    (yyval.dtype).bitfield = 0;
+		    (yyval.dtype).throws = (yyvsp[(1) - (4)].dtype).throws;
+		    (yyval.dtype).throwf = (yyvsp[(1) - (4)].dtype).throwf;
+		    (yyval.dtype).nexcept = (yyvsp[(1) - (4)].dtype).nexcept;
+		    (yyval.dtype).final = (yyvsp[(1) - (4)].dtype).final;
+               ;}
+    break;
+
+  case 253:
+#line 5037 "parser.y"
+    { 
+		    skip_balanced('{','}'); 
+		    (yyval.dtype).val = 0;
+		    (yyval.dtype).qualifier = (yyvsp[(1) - (2)].dtype).qualifier;
+		    (yyval.dtype).refqualifier = (yyvsp[(1) - (2)].dtype).refqualifier;
+		    (yyval.dtype).bitfield = 0;
+		    (yyval.dtype).throws = (yyvsp[(1) - (2)].dtype).throws;
+		    (yyval.dtype).throwf = (yyvsp[(1) - (2)].dtype).throwf;
+		    (yyval.dtype).nexcept = (yyvsp[(1) - (2)].dtype).nexcept;
+		    (yyval.dtype).final = (yyvsp[(1) - (2)].dtype).final;
+	       ;}
+    break;
+
+  case 254:
+#line 5050 "parser.y"
+    { 
+                     Clear(scanner_ccode);
+                     (yyval.dtype).val = 0;
+                     (yyval.dtype).qualifier = (yyvsp[(1) - (2)].dtype).qualifier;
+                     (yyval.dtype).refqualifier = (yyvsp[(1) - (2)].dtype).refqualifier;
+                     (yyval.dtype).bitfield = 0;
+                     (yyval.dtype).throws = (yyvsp[(1) - (2)].dtype).throws;
+                     (yyval.dtype).throwf = (yyvsp[(1) - (2)].dtype).throwf;
+                     (yyval.dtype).nexcept = (yyvsp[(1) - (2)].dtype).nexcept;
+                     (yyval.dtype).final = (yyvsp[(1) - (2)].dtype).final;
+                ;}
+    break;
+
+  case 255:
+#line 5061 "parser.y"
+    { 
+                     Clear(scanner_ccode);
+                     (yyval.dtype).val = (yyvsp[(3) - (4)].dtype).val;
+                     (yyval.dtype).qualifier = (yyvsp[(1) - (4)].dtype).qualifier;
+                     (yyval.dtype).refqualifier = (yyvsp[(1) - (4)].dtype).refqualifier;
+                     (yyval.dtype).bitfield = 0;
+                     (yyval.dtype).throws = (yyvsp[(1) - (4)].dtype).throws; 
+                     (yyval.dtype).throwf = (yyvsp[(1) - (4)].dtype).throwf; 
+                     (yyval.dtype).nexcept = (yyvsp[(1) - (4)].dtype).nexcept;
+                     (yyval.dtype).final = (yyvsp[(1) - (4)].dtype).final;
+               ;}
+    break;
+
+  case 256:
+#line 5072 "parser.y"
+    { 
+                     skip_balanced('{','}');
+                     (yyval.dtype).val = 0;
+                     (yyval.dtype).qualifier = (yyvsp[(1) - (2)].dtype).qualifier;
+                     (yyval.dtype).refqualifier = (yyvsp[(1) - (2)].dtype).refqualifier;
+                     (yyval.dtype).bitfield = 0;
+                     (yyval.dtype).throws = (yyvsp[(1) - (2)].dtype).throws; 
+                     (yyval.dtype).throwf = (yyvsp[(1) - (2)].dtype).throwf; 
+                     (yyval.dtype).nexcept = (yyvsp[(1) - (2)].dtype).nexcept;
+                     (yyval.dtype).final = (yyvsp[(1) - (2)].dtype).final;
+               ;}
+    break;
+
+  case 257:
+#line 5086 "parser.y"
+    { ;}
+    break;
+
+  case 258:
+#line 5089 "parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type);
+                  /* Printf(stdout,"primitive = '%s'\n", $$);*/
+                ;}
+    break;
+
+  case 259:
+#line 5092 "parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 260:
+#line 5093 "parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 261:
+#line 5097 "parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 262:
+#line 5099 "parser.y"
+    {
+		  (yyval.type) = (yyvsp[(1) - (1)].str);
+               ;}
+    break;
+
+  case 263:
+#line 5107 "parser.y"
+    {
+                   if (Strcmp((yyvsp[(2) - (2)].str),"C") == 0) {
+		     (yyval.id) = "externc";
+                   } else if (Strcmp((yyvsp[(2) - (2)].str),"C++") == 0) {
+		     (yyval.id) = "extern";
+		   } else {
+		     Swig_warning(WARN_PARSE_UNDEFINED_EXTERN,cparse_file, cparse_line,"Unrecognized extern type \"%s\".\n", (yyvsp[(2) - (2)].str));
+		     (yyval.id) = 0;
+		   }
+               ;}
+    break;
+
+  case 264:
+#line 5119 "parser.y"
+    { (yyval.id) = "extern"; ;}
+    break;
+
+  case 265:
+#line 5120 "parser.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); ;}
+    break;
+
+  case 266:
+#line 5121 "parser.y"
+    {
+                if (Equal((yyvsp[(1) - (2)].id), "extern")) {
+                  (yyval.id) = "extern thread_local";
+                } else {
+                  (yyval.id) = "externc thread_local";
+                }
+	       ;}
+    break;
+
+  case 267:
+#line 5128 "parser.y"
+    { (yyval.id) = "typedef"; ;}
+    break;
+
+  case 268:
+#line 5129 "parser.y"
+    { (yyval.id) = "static"; ;}
+    break;
+
+  case 269:
+#line 5130 "parser.y"
+    { (yyval.id) = "typedef"; ;}
+    break;
+
+  case 270:
+#line 5131 "parser.y"
+    { (yyval.id) = "virtual"; ;}
+    break;
+
+  case 271:
+#line 5132 "parser.y"
+    { (yyval.id) = "friend"; ;}
+    break;
+
+  case 272:
+#line 5133 "parser.y"
+    { (yyval.id) = "explicit"; ;}
+    break;
+
+  case 273:
+#line 5134 "parser.y"
+    { (yyval.id) = "constexpr"; ;}
+    break;
+
+  case 274:
+#line 5135 "parser.y"
+    { (yyval.id) = "explicit constexpr"; ;}
+    break;
+
+  case 275:
+#line 5136 "parser.y"
+    { (yyval.id) = "explicit constexpr"; ;}
+    break;
+
+  case 276:
+#line 5137 "parser.y"
+    { (yyval.id) = "static constexpr"; ;}
+    break;
+
+  case 277:
+#line 5138 "parser.y"
+    { (yyval.id) = "static constexpr"; ;}
+    break;
+
+  case 278:
+#line 5139 "parser.y"
+    { (yyval.id) = "thread_local"; ;}
+    break;
+
+  case 279:
+#line 5140 "parser.y"
+    { (yyval.id) = "static thread_local"; ;}
+    break;
+
+  case 280:
+#line 5141 "parser.y"
+    { (yyval.id) = "static thread_local"; ;}
+    break;
+
+  case 281:
+#line 5142 "parser.y"
+    { (yyval.id) = "extern thread_local"; ;}
+    break;
+
+  case 282:
+#line 5143 "parser.y"
+    { (yyval.id) = "extern thread_local"; ;}
+    break;
+
+  case 283:
+#line 5144 "parser.y"
+    { (yyval.id) = 0; ;}
+    break;
+
+  case 284:
+#line 5151 "parser.y"
+    {
+                 Parm *p;
+		 (yyval.pl) = (yyvsp[(1) - (1)].pl);
+		 p = (yyvsp[(1) - (1)].pl);
+                 while (p) {
+		   Replace(Getattr(p,"type"),"typename ", "", DOH_REPLACE_ANY);
+		   p = nextSibling(p);
+                 }
+               ;}
+    break;
+
+  case 285:
+#line 5162 "parser.y"
+    {
+                  set_nextSibling((yyvsp[(1) - (2)].p),(yyvsp[(2) - (2)].pl));
+                  (yyval.pl) = (yyvsp[(1) - (2)].p);
+		;}
+    break;
+
+  case 286:
+#line 5166 "parser.y"
+    {
+		  (yyval.pl) = 0;
+		  previousNode = currentNode;
+		  currentNode=0;
+	       ;}
+    break;
+
+  case 287:
+#line 5173 "parser.y"
+    {
+                 set_nextSibling((yyvsp[(2) - (3)].p),(yyvsp[(3) - (3)].pl));
+		 (yyval.pl) = (yyvsp[(2) - (3)].p);
+                ;}
+    break;
+
+  case 288:
+#line 5177 "parser.y"
+    {
+		 set_comment(previousNode, (yyvsp[(2) - (4)].str));
+                 set_nextSibling((yyvsp[(3) - (4)].p), (yyvsp[(4) - (4)].pl));
+		 (yyval.pl) = (yyvsp[(3) - (4)].p);
+               ;}
+    break;
+
+  case 289:
+#line 5182 "parser.y"
+    { (yyval.pl) = 0; ;}
+    break;
+
+  case 290:
+#line 5186 "parser.y"
+    {
+                   SwigType_push((yyvsp[(1) - (2)].type),(yyvsp[(2) - (2)].decl).type);
+		   (yyval.p) = NewParmWithoutFileLineInfo((yyvsp[(1) - (2)].type),(yyvsp[(2) - (2)].decl).id);
+		   previousNode = currentNode;
+		   currentNode = (yyval.p);
+		   Setfile((yyval.p),cparse_file);
+		   Setline((yyval.p),cparse_line);
+		   if ((yyvsp[(2) - (2)].decl).defarg) {
+		     Setattr((yyval.p),"value",(yyvsp[(2) - (2)].decl).defarg);
+		   }
+		;}
+    break;
+
+  case 291:
+#line 5198 "parser.y"
+    {
+                  (yyval.p) = NewParmWithoutFileLineInfo(NewStringf("template<class> %s %s", (yyvsp[(5) - (7)].id),(yyvsp[(6) - (7)].str)), 0);
+		  previousNode = currentNode;
+		  currentNode = (yyval.p);
+		  Setfile((yyval.p),cparse_file);
+		  Setline((yyval.p),cparse_line);
+                  if ((yyvsp[(7) - (7)].dtype).val) {
+                    Setattr((yyval.p),"value",(yyvsp[(7) - (7)].dtype).val);
+                  }
+                ;}
+    break;
+
+  case 292:
+#line 5208 "parser.y"
+    {
+		  SwigType *t = NewString("v(...)");
+		  (yyval.p) = NewParmWithoutFileLineInfo(t, 0);
+		  previousNode = currentNode;
+		  currentNode = (yyval.p);
+		  Setfile((yyval.p),cparse_file);
+		  Setline((yyval.p),cparse_line);
+		;}
+    break;
+
+  case 293:
+#line 5218 "parser.y"
+    {
+		  (yyval.p) = (yyvsp[(1) - (1)].p);
+		;}
+    break;
+
+  case 294:
+#line 5221 "parser.y"
+    {
+		  (yyval.p) = (yyvsp[(2) - (2)].p);
+		  set_comment((yyvsp[(2) - (2)].p), (yyvsp[(1) - (2)].str));
+		;}
+    break;
+
+  case 295:
+#line 5225 "parser.y"
+    {
+		  (yyval.p) = (yyvsp[(1) - (2)].p);
+		  set_comment((yyvsp[(1) - (2)].p), (yyvsp[(2) - (2)].str));
+		;}
+    break;
+
+  case 296:
+#line 5231 "parser.y"
+    {
+                 Parm *p;
+		 (yyval.p) = (yyvsp[(1) - (1)].p);
+		 p = (yyvsp[(1) - (1)].p);
+                 while (p) {
+		   if (Getattr(p,"type")) {
+		     Replace(Getattr(p,"type"),"typename ", "", DOH_REPLACE_ANY);
+		   }
+		   p = nextSibling(p);
+                 }
+               ;}
+    break;
+
+  case 297:
+#line 5244 "parser.y"
+    {
+                  set_nextSibling((yyvsp[(1) - (2)].p),(yyvsp[(2) - (2)].p));
+                  (yyval.p) = (yyvsp[(1) - (2)].p);
+		;}
+    break;
+
+  case 298:
+#line 5248 "parser.y"
+    { (yyval.p) = 0; ;}
+    break;
+
+  case 299:
+#line 5251 "parser.y"
+    {
+                 set_nextSibling((yyvsp[(2) - (3)].p),(yyvsp[(3) - (3)].p));
+		 (yyval.p) = (yyvsp[(2) - (3)].p);
+                ;}
+    break;
+
+  case 300:
+#line 5255 "parser.y"
+    { (yyval.p) = 0; ;}
+    break;
+
+  case 301:
+#line 5259 "parser.y"
+    {
+		  (yyval.p) = (yyvsp[(1) - (1)].p);
+		  {
+		    /* We need to make a possible adjustment for integer parameters. */
+		    SwigType *type;
+		    Node     *n = 0;
+
+		    while (!n) {
+		      type = Getattr((yyvsp[(1) - (1)].p),"type");
+		      n = Swig_symbol_clookup(type,0);     /* See if we can find a node that matches the typename */
+		      if ((n) && (Strcmp(nodeType(n),"cdecl") == 0)) {
+			SwigType *decl = Getattr(n,"decl");
+			if (!SwigType_isfunction(decl)) {
+			  String *value = Getattr(n,"value");
+			  if (value) {
+			    String *v = Copy(value);
+			    Setattr((yyvsp[(1) - (1)].p),"type",v);
+			    Delete(v);
+			    n = 0;
+			  }
+			}
+		      } else {
+			break;
+		      }
+		    }
+		  }
+
+               ;}
+    break;
+
+  case 302:
+#line 5287 "parser.y"
+    {
+                  (yyval.p) = NewParmWithoutFileLineInfo(0,0);
+                  Setfile((yyval.p),cparse_file);
+		  Setline((yyval.p),cparse_line);
+		  Setattr((yyval.p),"value",(yyvsp[(1) - (1)].dtype).val);
+               ;}
+    break;
+
+  case 303:
+#line 5295 "parser.y"
+    {
+		 (yyval.dtype) = (yyvsp[(1) - (2)].dtype);
+		 Printf((yyval.dtype).val, "%s", (yyvsp[(2) - (2)].dtype).val);
+	       ;}
+    break;
+
+  case 304:
+#line 5299 "parser.y"
+    { (yyval.dtype).val = NewStringEmpty(); ;}
+    break;
+
+  case 305:
+#line 5302 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf(",%s%s", (yyvsp[(2) - (3)].dtype).val, (yyvsp[(3) - (3)].dtype).val);
+		 (yyval.dtype).type = 0;
+	       ;}
+    break;
+
+  case 306:
+#line 5306 "parser.y"
+    { (yyval.dtype).val = NewStringEmpty(); ;}
+    break;
+
+  case 307:
+#line 5309 "parser.y"
+    { 
+                  (yyval.dtype) = (yyvsp[(2) - (2)].dtype); 
+		  if ((yyvsp[(2) - (2)].dtype).type == T_ERROR) {
+		    Swig_warning(WARN_PARSE_BAD_DEFAULT,cparse_file, cparse_line, "Can't set default argument (ignored)\n");
+		    (yyval.dtype).val = 0;
+		    (yyval.dtype).rawval = 0;
+		    (yyval.dtype).bitfield = 0;
+		    (yyval.dtype).throws = 0;
+		    (yyval.dtype).throwf = 0;
+		    (yyval.dtype).nexcept = 0;
+		    (yyval.dtype).final = 0;
+		  }
+               ;}
+    break;
+
+  case 308:
+#line 5322 "parser.y"
+    { 
+		  (yyval.dtype) = (yyvsp[(2) - (5)].dtype);
+		  if ((yyvsp[(2) - (5)].dtype).type == T_ERROR) {
+		    Swig_warning(WARN_PARSE_BAD_DEFAULT,cparse_file, cparse_line, "Can't set default argument (ignored)\n");
+		    (yyval.dtype) = (yyvsp[(2) - (5)].dtype);
+		    (yyval.dtype).val = 0;
+		    (yyval.dtype).rawval = 0;
+		    (yyval.dtype).bitfield = 0;
+		    (yyval.dtype).throws = 0;
+		    (yyval.dtype).throwf = 0;
+		    (yyval.dtype).nexcept = 0;
+		    (yyval.dtype).final = 0;
+		  } else {
+		    (yyval.dtype).val = NewStringf("%s[%s]",(yyvsp[(2) - (5)].dtype).val,(yyvsp[(4) - (5)].dtype).val); 
+		  }		  
+               ;}
+    break;
+
+  case 309:
+#line 5338 "parser.y"
+    {
+		 skip_balanced('{','}');
+		 (yyval.dtype).val = NewString(scanner_ccode);
+		 (yyval.dtype).rawval = 0;
+                 (yyval.dtype).type = T_INT;
+		 (yyval.dtype).bitfield = 0;
+		 (yyval.dtype).throws = 0;
+		 (yyval.dtype).throwf = 0;
+		 (yyval.dtype).nexcept = 0;
+		 (yyval.dtype).final = 0;
+	       ;}
+    break;
+
+  case 310:
+#line 5349 "parser.y"
+    { 
+		 (yyval.dtype).val = 0;
+		 (yyval.dtype).rawval = 0;
+		 (yyval.dtype).type = 0;
+		 (yyval.dtype).bitfield = (yyvsp[(2) - (2)].dtype).val;
+		 (yyval.dtype).throws = 0;
+		 (yyval.dtype).throwf = 0;
+		 (yyval.dtype).nexcept = 0;
+		 (yyval.dtype).final = 0;
+	       ;}
+    break;
+
+  case 311:
+#line 5359 "parser.y"
+    {
+                 (yyval.dtype).val = 0;
+                 (yyval.dtype).rawval = 0;
+                 (yyval.dtype).type = T_INT;
+		 (yyval.dtype).bitfield = 0;
+		 (yyval.dtype).throws = 0;
+		 (yyval.dtype).throwf = 0;
+		 (yyval.dtype).nexcept = 0;
+		 (yyval.dtype).final = 0;
+               ;}
+    break;
+
+  case 312:
+#line 5371 "parser.y"
+    {
+                 (yyval.decl) = (yyvsp[(1) - (2)].decl);
+		 (yyval.decl).defarg = (yyvsp[(2) - (2)].dtype).rawval ? (yyvsp[(2) - (2)].dtype).rawval : (yyvsp[(2) - (2)].dtype).val;
+            ;}
+    break;
+
+  case 313:
+#line 5375 "parser.y"
+    {
+              (yyval.decl) = (yyvsp[(1) - (2)].decl);
+	      (yyval.decl).defarg = (yyvsp[(2) - (2)].dtype).rawval ? (yyvsp[(2) - (2)].dtype).rawval : (yyvsp[(2) - (2)].dtype).val;
+            ;}
+    break;
+
+  case 314:
+#line 5379 "parser.y"
+    {
+   	      (yyval.decl).type = 0;
+              (yyval.decl).id = 0;
+	      (yyval.decl).defarg = (yyvsp[(1) - (1)].dtype).rawval ? (yyvsp[(1) - (1)].dtype).rawval : (yyvsp[(1) - (1)].dtype).val;
+            ;}
+    break;
+
+  case 315:
+#line 5386 "parser.y"
+    {
+	      SwigType *t;
+	      (yyval.decl) = (yyvsp[(1) - (5)].decl);
+	      t = NewStringEmpty();
+	      SwigType_add_function(t,(yyvsp[(3) - (5)].pl));
+	      if ((yyvsp[(5) - (5)].dtype).qualifier)
+	        SwigType_push(t, (yyvsp[(5) - (5)].dtype).qualifier);
+	      if (!(yyval.decl).have_parms) {
+		(yyval.decl).parms = (yyvsp[(3) - (5)].pl);
+		(yyval.decl).have_parms = 1;
+	      }
+	      if (!(yyval.decl).type) {
+		(yyval.decl).type = t;
+	      } else {
+		SwigType_push(t, (yyval.decl).type);
+		Delete((yyval.decl).type);
+		(yyval.decl).type = t;
+	      }
+	      (yyval.decl).defarg = 0;
+	    ;}
+    break;
+
+  case 316:
+#line 5408 "parser.y"
+    {
+                 (yyval.decl) = (yyvsp[(1) - (1)].decl);
+		 if (SwigType_isfunction((yyvsp[(1) - (1)].decl).type)) {
+		   Delete(SwigType_pop_function((yyvsp[(1) - (1)].decl).type));
+		 } else if (SwigType_isarray((yyvsp[(1) - (1)].decl).type)) {
+		   SwigType *ta = SwigType_pop_arrays((yyvsp[(1) - (1)].decl).type);
+		   if (SwigType_isfunction((yyvsp[(1) - (1)].decl).type)) {
+		     Delete(SwigType_pop_function((yyvsp[(1) - (1)].decl).type));
+		   } else {
+		     (yyval.decl).parms = 0;
+		   }
+		   SwigType_push((yyvsp[(1) - (1)].decl).type,ta);
+		   Delete(ta);
+		 } else {
+		   (yyval.decl).parms = 0;
+		 }
+            ;}
+    break;
+
+  case 317:
+#line 5425 "parser.y"
+    {
+              (yyval.decl) = (yyvsp[(1) - (1)].decl);
+	      if (SwigType_isfunction((yyvsp[(1) - (1)].decl).type)) {
+		Delete(SwigType_pop_function((yyvsp[(1) - (1)].decl).type));
+	      } else if (SwigType_isarray((yyvsp[(1) - (1)].decl).type)) {
+		SwigType *ta = SwigType_pop_arrays((yyvsp[(1) - (1)].decl).type);
+		if (SwigType_isfunction((yyvsp[(1) - (1)].decl).type)) {
+		  Delete(SwigType_pop_function((yyvsp[(1) - (1)].decl).type));
+		} else {
+		  (yyval.decl).parms = 0;
+		}
+		SwigType_push((yyvsp[(1) - (1)].decl).type,ta);
+		Delete(ta);
+	      } else {
+		(yyval.decl).parms = 0;
+	      }
+            ;}
+    break;
+
+  case 318:
+#line 5444 "parser.y"
+    {
+	      SwigType *t;
+	      (yyval.decl) = (yyvsp[(1) - (5)].decl);
+	      t = NewStringEmpty();
+	      SwigType_add_function(t, (yyvsp[(3) - (5)].pl));
+	      if ((yyvsp[(5) - (5)].dtype).qualifier)
+	        SwigType_push(t, (yyvsp[(5) - (5)].dtype).qualifier);
+	      if (!(yyval.decl).have_parms) {
+		(yyval.decl).parms = (yyvsp[(3) - (5)].pl);
+		(yyval.decl).have_parms = 1;
+	      }
+	      if (!(yyval.decl).type) {
+		(yyval.decl).type = t;
+	      } else {
+		SwigType_push(t, (yyval.decl).type);
+		Delete((yyval.decl).type);
+		(yyval.decl).type = t;
+	      }
+	    ;}
+    break;
+
+  case 319:
+#line 5463 "parser.y"
+    {
+   	      (yyval.decl).type = 0;
+              (yyval.decl).id = 0;
+	      (yyval.decl).parms = 0;
+	      ;}
+    break;
+
+  case 320:
+#line 5470 "parser.y"
+    {
+              (yyval.decl) = (yyvsp[(2) - (2)].decl);
+	      if ((yyval.decl).type) {
+		SwigType_push((yyvsp[(1) - (2)].type),(yyval.decl).type);
+		Delete((yyval.decl).type);
+	      }
+	      (yyval.decl).type = (yyvsp[(1) - (2)].type);
+           ;}
+    break;
+
+  case 321:
+#line 5478 "parser.y"
+    {
+              (yyval.decl) = (yyvsp[(3) - (3)].decl);
+	      SwigType_add_reference((yyvsp[(1) - (3)].type));
+              if ((yyval.decl).type) {
+		SwigType_push((yyvsp[(1) - (3)].type),(yyval.decl).type);
+		Delete((yyval.decl).type);
+	      }
+	      (yyval.decl).type = (yyvsp[(1) - (3)].type);
+           ;}
+    break;
+
+  case 322:
+#line 5487 "parser.y"
+    {
+              (yyval.decl) = (yyvsp[(3) - (3)].decl);
+	      SwigType_add_rvalue_reference((yyvsp[(1) - (3)].type));
+              if ((yyval.decl).type) {
+		SwigType_push((yyvsp[(1) - (3)].type),(yyval.decl).type);
+		Delete((yyval.decl).type);
+	      }
+	      (yyval.decl).type = (yyvsp[(1) - (3)].type);
+           ;}
+    break;
+
+  case 323:
+#line 5496 "parser.y"
+    {
+              (yyval.decl) = (yyvsp[(1) - (1)].decl);
+	      if (!(yyval.decl).type) (yyval.decl).type = NewStringEmpty();
+           ;}
+    break;
+
+  case 324:
+#line 5500 "parser.y"
+    {
+	     (yyval.decl) = (yyvsp[(2) - (2)].decl);
+	     (yyval.decl).type = NewStringEmpty();
+	     SwigType_add_reference((yyval.decl).type);
+	     if ((yyvsp[(2) - (2)].decl).type) {
+	       SwigType_push((yyval.decl).type,(yyvsp[(2) - (2)].decl).type);
+	       Delete((yyvsp[(2) - (2)].decl).type);
+	     }
+           ;}
+    break;
+
+  case 325:
+#line 5509 "parser.y"
+    {
+	     /* Introduced in C++11, move operator && */
+             /* Adds one S/R conflict */
+	     (yyval.decl) = (yyvsp[(2) - (2)].decl);
+	     (yyval.decl).type = NewStringEmpty();
+	     SwigType_add_rvalue_reference((yyval.decl).type);
+	     if ((yyvsp[(2) - (2)].decl).type) {
+	       SwigType_push((yyval.decl).type,(yyvsp[(2) - (2)].decl).type);
+	       Delete((yyvsp[(2) - (2)].decl).type);
+	     }
+           ;}
+    break;
+
+  case 326:
+#line 5520 "parser.y"
+    { 
+	     SwigType *t = NewStringEmpty();
+
+	     (yyval.decl) = (yyvsp[(3) - (3)].decl);
+	     SwigType_add_memberpointer(t,(yyvsp[(1) - (3)].str));
+	     if ((yyval.decl).type) {
+	       SwigType_push(t,(yyval.decl).type);
+	       Delete((yyval.decl).type);
+	     }
+	     (yyval.decl).type = t;
+	     ;}
+    break;
+
+  case 327:
+#line 5531 "parser.y"
+    { 
+	     SwigType *t = NewStringEmpty();
+	     (yyval.decl) = (yyvsp[(4) - (4)].decl);
+	     SwigType_add_memberpointer(t,(yyvsp[(2) - (4)].str));
+	     SwigType_push((yyvsp[(1) - (4)].type),t);
+	     if ((yyval.decl).type) {
+	       SwigType_push((yyvsp[(1) - (4)].type),(yyval.decl).type);
+	       Delete((yyval.decl).type);
+	     }
+	     (yyval.decl).type = (yyvsp[(1) - (4)].type);
+	     Delete(t);
+	   ;}
+    break;
+
+  case 328:
+#line 5543 "parser.y"
+    { 
+	     (yyval.decl) = (yyvsp[(5) - (5)].decl);
+	     SwigType_add_memberpointer((yyvsp[(1) - (5)].type),(yyvsp[(2) - (5)].str));
+	     SwigType_add_reference((yyvsp[(1) - (5)].type));
+	     if ((yyval.decl).type) {
+	       SwigType_push((yyvsp[(1) - (5)].type),(yyval.decl).type);
+	       Delete((yyval.decl).type);
+	     }
+	     (yyval.decl).type = (yyvsp[(1) - (5)].type);
+	   ;}
+    break;
+
+  case 329:
+#line 5553 "parser.y"
+    { 
+	     SwigType *t = NewStringEmpty();
+	     (yyval.decl) = (yyvsp[(4) - (4)].decl);
+	     SwigType_add_memberpointer(t,(yyvsp[(1) - (4)].str));
+	     SwigType_add_reference(t);
+	     if ((yyval.decl).type) {
+	       SwigType_push(t,(yyval.decl).type);
+	       Delete((yyval.decl).type);
+	     } 
+	     (yyval.decl).type = t;
+	   ;}
+    break;
+
+  case 330:
+#line 5567 "parser.y"
+    {
+              (yyval.decl) = (yyvsp[(3) - (3)].decl);
+	      if ((yyval.decl).type) {
+		SwigType_push((yyvsp[(1) - (3)].type),(yyval.decl).type);
+		Delete((yyval.decl).type);
+	      }
+	      (yyval.decl).type = (yyvsp[(1) - (3)].type);
+           ;}
+    break;
+
+  case 331:
+#line 5575 "parser.y"
+    {
+              (yyval.decl) = (yyvsp[(4) - (4)].decl);
+	      SwigType_add_reference((yyvsp[(1) - (4)].type));
+              if ((yyval.decl).type) {
+		SwigType_push((yyvsp[(1) - (4)].type),(yyval.decl).type);
+		Delete((yyval.decl).type);
+	      }
+	      (yyval.decl).type = (yyvsp[(1) - (4)].type);
+           ;}
+    break;
+
+  case 332:
+#line 5584 "parser.y"
+    {
+              (yyval.decl) = (yyvsp[(4) - (4)].decl);
+	      SwigType_add_rvalue_reference((yyvsp[(1) - (4)].type));
+              if ((yyval.decl).type) {
+		SwigType_push((yyvsp[(1) - (4)].type),(yyval.decl).type);
+		Delete((yyval.decl).type);
+	      }
+	      (yyval.decl).type = (yyvsp[(1) - (4)].type);
+           ;}
+    break;
+
+  case 333:
+#line 5593 "parser.y"
+    {
+              (yyval.decl) = (yyvsp[(2) - (2)].decl);
+	      if (!(yyval.decl).type) (yyval.decl).type = NewStringEmpty();
+           ;}
+    break;
+
+  case 334:
+#line 5597 "parser.y"
+    {
+	     (yyval.decl) = (yyvsp[(3) - (3)].decl);
+	     (yyval.decl).type = NewStringEmpty();
+	     SwigType_add_reference((yyval.decl).type);
+	     if ((yyvsp[(3) - (3)].decl).type) {
+	       SwigType_push((yyval.decl).type,(yyvsp[(3) - (3)].decl).type);
+	       Delete((yyvsp[(3) - (3)].decl).type);
+	     }
+           ;}
+    break;
+
+  case 335:
+#line 5606 "parser.y"
+    {
+	     /* Introduced in C++11, move operator && */
+             /* Adds one S/R conflict */
+	     (yyval.decl) = (yyvsp[(3) - (3)].decl);
+	     (yyval.decl).type = NewStringEmpty();
+	     SwigType_add_rvalue_reference((yyval.decl).type);
+	     if ((yyvsp[(3) - (3)].decl).type) {
+	       SwigType_push((yyval.decl).type,(yyvsp[(3) - (3)].decl).type);
+	       Delete((yyvsp[(3) - (3)].decl).type);
+	     }
+           ;}
+    break;
+
+  case 336:
+#line 5617 "parser.y"
+    {
+	     SwigType *t = NewStringEmpty();
+
+	     (yyval.decl) = (yyvsp[(4) - (4)].decl);
+	     SwigType_add_memberpointer(t,(yyvsp[(1) - (4)].str));
+	     if ((yyval.decl).type) {
+	       SwigType_push(t,(yyval.decl).type);
+	       Delete((yyval.decl).type);
+	     }
+	     (yyval.decl).type = t;
+	     ;}
+    break;
+
+  case 337:
+#line 5628 "parser.y"
+    {
+	     SwigType *t = NewStringEmpty();
+	     (yyval.decl) = (yyvsp[(5) - (5)].decl);
+	     SwigType_add_memberpointer(t,(yyvsp[(2) - (5)].str));
+	     SwigType_push((yyvsp[(1) - (5)].type),t);
+	     if ((yyval.decl).type) {
+	       SwigType_push((yyvsp[(1) - (5)].type),(yyval.decl).type);
+	       Delete((yyval.decl).type);
+	     }
+	     (yyval.decl).type = (yyvsp[(1) - (5)].type);
+	     Delete(t);
+	   ;}
+    break;
+
+  case 338:
+#line 5640 "parser.y"
+    {
+	     (yyval.decl) = (yyvsp[(6) - (6)].decl);
+	     SwigType_add_memberpointer((yyvsp[(1) - (6)].type),(yyvsp[(2) - (6)].str));
+	     SwigType_add_reference((yyvsp[(1) - (6)].type));
+	     if ((yyval.decl).type) {
+	       SwigType_push((yyvsp[(1) - (6)].type),(yyval.decl).type);
+	       Delete((yyval.decl).type);
+	     }
+	     (yyval.decl).type = (yyvsp[(1) - (6)].type);
+	   ;}
+    break;
+
+  case 339:
+#line 5650 "parser.y"
+    {
+	     (yyval.decl) = (yyvsp[(6) - (6)].decl);
+	     SwigType_add_memberpointer((yyvsp[(1) - (6)].type),(yyvsp[(2) - (6)].str));
+	     SwigType_add_rvalue_reference((yyvsp[(1) - (6)].type));
+	     if ((yyval.decl).type) {
+	       SwigType_push((yyvsp[(1) - (6)].type),(yyval.decl).type);
+	       Delete((yyval.decl).type);
+	     }
+	     (yyval.decl).type = (yyvsp[(1) - (6)].type);
+	   ;}
+    break;
+
+  case 340:
+#line 5660 "parser.y"
+    {
+	     SwigType *t = NewStringEmpty();
+	     (yyval.decl) = (yyvsp[(5) - (5)].decl);
+	     SwigType_add_memberpointer(t,(yyvsp[(1) - (5)].str));
+	     SwigType_add_reference(t);
+	     if ((yyval.decl).type) {
+	       SwigType_push(t,(yyval.decl).type);
+	       Delete((yyval.decl).type);
+	     } 
+	     (yyval.decl).type = t;
+	   ;}
+    break;
+
+  case 341:
+#line 5671 "parser.y"
+    {
+	     SwigType *t = NewStringEmpty();
+	     (yyval.decl) = (yyvsp[(5) - (5)].decl);
+	     SwigType_add_memberpointer(t,(yyvsp[(1) - (5)].str));
+	     SwigType_add_rvalue_reference(t);
+	     if ((yyval.decl).type) {
+	       SwigType_push(t,(yyval.decl).type);
+	       Delete((yyval.decl).type);
+	     } 
+	     (yyval.decl).type = t;
+	   ;}
+    break;
+
+  case 342:
+#line 5684 "parser.y"
+    {
+                /* Note: This is non-standard C.  Template declarator is allowed to follow an identifier */
+                 (yyval.decl).id = Char((yyvsp[(1) - (1)].str));
+		 (yyval.decl).type = 0;
+		 (yyval.decl).parms = 0;
+		 (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 343:
+#line 5691 "parser.y"
+    {
+                  (yyval.decl).id = Char(NewStringf("~%s",(yyvsp[(2) - (2)].str)));
+                  (yyval.decl).type = 0;
+                  (yyval.decl).parms = 0;
+                  (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 344:
+#line 5699 "parser.y"
+    {
+                  (yyval.decl).id = Char((yyvsp[(2) - (3)].str));
+                  (yyval.decl).type = 0;
+                  (yyval.decl).parms = 0;
+                  (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 345:
+#line 5715 "parser.y"
+    {
+		    (yyval.decl) = (yyvsp[(3) - (4)].decl);
+		    if ((yyval.decl).type) {
+		      SwigType_push((yyvsp[(2) - (4)].type),(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = (yyvsp[(2) - (4)].type);
+                  ;}
+    break;
+
+  case 346:
+#line 5723 "parser.y"
+    {
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(4) - (5)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_memberpointer(t,(yyvsp[(2) - (5)].str));
+		    if ((yyval.decl).type) {
+		      SwigType_push(t,(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+		    ;}
+    break;
+
+  case 347:
+#line 5734 "parser.y"
+    { 
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(1) - (3)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_array(t,"");
+		    if ((yyval.decl).type) {
+		      SwigType_push(t,(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 348:
+#line 5745 "parser.y"
+    { 
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(1) - (4)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_array(t,(yyvsp[(3) - (4)].dtype).val);
+		    if ((yyval.decl).type) {
+		      SwigType_push(t,(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 349:
+#line 5756 "parser.y"
+    {
+		    SwigType *t;
+                    (yyval.decl) = (yyvsp[(1) - (4)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_function(t,(yyvsp[(3) - (4)].pl));
+		    if (!(yyval.decl).have_parms) {
+		      (yyval.decl).parms = (yyvsp[(3) - (4)].pl);
+		      (yyval.decl).have_parms = 1;
+		    }
+		    if (!(yyval.decl).type) {
+		      (yyval.decl).type = t;
+		    } else {
+		      SwigType_push(t, (yyval.decl).type);
+		      Delete((yyval.decl).type);
+		      (yyval.decl).type = t;
+		    }
+		  ;}
+    break;
+
+  case 350:
+#line 5775 "parser.y"
+    {
+                /* Note: This is non-standard C.  Template declarator is allowed to follow an identifier */
+                 (yyval.decl).id = Char((yyvsp[(1) - (1)].str));
+		 (yyval.decl).type = 0;
+		 (yyval.decl).parms = 0;
+		 (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 351:
+#line 5783 "parser.y"
+    {
+                  (yyval.decl).id = Char(NewStringf("~%s",(yyvsp[(2) - (2)].str)));
+                  (yyval.decl).type = 0;
+                  (yyval.decl).parms = 0;
+                  (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 352:
+#line 5800 "parser.y"
+    {
+		    (yyval.decl) = (yyvsp[(3) - (4)].decl);
+		    if ((yyval.decl).type) {
+		      SwigType_push((yyvsp[(2) - (4)].type),(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = (yyvsp[(2) - (4)].type);
+                  ;}
+    break;
+
+  case 353:
+#line 5808 "parser.y"
+    {
+                    (yyval.decl) = (yyvsp[(3) - (4)].decl);
+		    if (!(yyval.decl).type) {
+		      (yyval.decl).type = NewStringEmpty();
+		    }
+		    SwigType_add_reference((yyval.decl).type);
+                  ;}
+    break;
+
+  case 354:
+#line 5815 "parser.y"
+    {
+                    (yyval.decl) = (yyvsp[(3) - (4)].decl);
+		    if (!(yyval.decl).type) {
+		      (yyval.decl).type = NewStringEmpty();
+		    }
+		    SwigType_add_rvalue_reference((yyval.decl).type);
+                  ;}
+    break;
+
+  case 355:
+#line 5822 "parser.y"
+    {
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(4) - (5)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_memberpointer(t,(yyvsp[(2) - (5)].str));
+		    if ((yyval.decl).type) {
+		      SwigType_push(t,(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+		  ;}
+    break;
+
+  case 356:
+#line 5833 "parser.y"
+    {
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(5) - (6)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_memberpointer(t, (yyvsp[(2) - (6)].str));
+		    SwigType_push(t, (yyvsp[(4) - (6)].str));
+		    if ((yyval.decl).type) {
+		      SwigType_push(t, (yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+		  ;}
+    break;
+
+  case 357:
+#line 5845 "parser.y"
+    {
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(4) - (5)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_memberpointer(t, (yyvsp[(2) - (5)].str));
+		    if ((yyval.decl).type) {
+		      SwigType_push(t, (yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+		  ;}
+    break;
+
+  case 358:
+#line 5856 "parser.y"
+    {
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(5) - (6)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_memberpointer(t, (yyvsp[(2) - (6)].str));
+		    SwigType_push(t, (yyvsp[(4) - (6)].str));
+		    if ((yyval.decl).type) {
+		      SwigType_push(t, (yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+		  ;}
+    break;
+
+  case 359:
+#line 5868 "parser.y"
+    { 
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(1) - (3)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_array(t,"");
+		    if ((yyval.decl).type) {
+		      SwigType_push(t,(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 360:
+#line 5879 "parser.y"
+    { 
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(1) - (4)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_array(t,(yyvsp[(3) - (4)].dtype).val);
+		    if ((yyval.decl).type) {
+		      SwigType_push(t,(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 361:
+#line 5890 "parser.y"
+    {
+		    SwigType *t;
+                    (yyval.decl) = (yyvsp[(1) - (4)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_function(t,(yyvsp[(3) - (4)].pl));
+		    if (!(yyval.decl).have_parms) {
+		      (yyval.decl).parms = (yyvsp[(3) - (4)].pl);
+		      (yyval.decl).have_parms = 1;
+		    }
+		    if (!(yyval.decl).type) {
+		      (yyval.decl).type = t;
+		    } else {
+		      SwigType_push(t, (yyval.decl).type);
+		      Delete((yyval.decl).type);
+		      (yyval.decl).type = t;
+		    }
+		  ;}
+    break;
+
+  case 362:
+#line 5910 "parser.y"
+    {
+		    SwigType *t;
+                    Append((yyvsp[(1) - (5)].str), " "); /* intervening space is mandatory */
+                    Append((yyvsp[(1) - (5)].str), Char((yyvsp[(2) - (5)].id)));
+		    (yyval.decl).id = Char((yyvsp[(1) - (5)].str));
+		    t = NewStringEmpty();
+		    SwigType_add_function(t,(yyvsp[(4) - (5)].pl));
+		    if (!(yyval.decl).have_parms) {
+		      (yyval.decl).parms = (yyvsp[(4) - (5)].pl);
+		      (yyval.decl).have_parms = 1;
+		    }
+		    if (!(yyval.decl).type) {
+		      (yyval.decl).type = t;
+		    } else {
+		      SwigType_push(t, (yyval.decl).type);
+		      Delete((yyval.decl).type);
+		      (yyval.decl).type = t;
+		    }
+		  ;}
+    break;
+
+  case 363:
+#line 5931 "parser.y"
+    {
+		    (yyval.decl).type = (yyvsp[(1) - (1)].type);
+                    (yyval.decl).id = 0;
+		    (yyval.decl).parms = 0;
+		    (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 364:
+#line 5937 "parser.y"
+    { 
+                     (yyval.decl) = (yyvsp[(2) - (2)].decl);
+                     SwigType_push((yyvsp[(1) - (2)].type),(yyvsp[(2) - (2)].decl).type);
+		     (yyval.decl).type = (yyvsp[(1) - (2)].type);
+		     Delete((yyvsp[(2) - (2)].decl).type);
+                  ;}
+    break;
+
+  case 365:
+#line 5943 "parser.y"
+    {
+		    (yyval.decl).type = (yyvsp[(1) - (2)].type);
+		    SwigType_add_reference((yyval.decl).type);
+		    (yyval.decl).id = 0;
+		    (yyval.decl).parms = 0;
+		    (yyval.decl).have_parms = 0;
+		  ;}
+    break;
+
+  case 366:
+#line 5950 "parser.y"
+    {
+		    (yyval.decl).type = (yyvsp[(1) - (2)].type);
+		    SwigType_add_rvalue_reference((yyval.decl).type);
+		    (yyval.decl).id = 0;
+		    (yyval.decl).parms = 0;
+		    (yyval.decl).have_parms = 0;
+		  ;}
+    break;
+
+  case 367:
+#line 5957 "parser.y"
+    {
+		    (yyval.decl) = (yyvsp[(3) - (3)].decl);
+		    SwigType_add_reference((yyvsp[(1) - (3)].type));
+		    if ((yyval.decl).type) {
+		      SwigType_push((yyvsp[(1) - (3)].type),(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = (yyvsp[(1) - (3)].type);
+                  ;}
+    break;
+
+  case 368:
+#line 5966 "parser.y"
+    {
+		    (yyval.decl) = (yyvsp[(3) - (3)].decl);
+		    SwigType_add_rvalue_reference((yyvsp[(1) - (3)].type));
+		    if ((yyval.decl).type) {
+		      SwigType_push((yyvsp[(1) - (3)].type),(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = (yyvsp[(1) - (3)].type);
+                  ;}
+    break;
+
+  case 369:
+#line 5975 "parser.y"
+    {
+		    (yyval.decl) = (yyvsp[(1) - (1)].decl);
+                  ;}
+    break;
+
+  case 370:
+#line 5978 "parser.y"
+    {
+		    (yyval.decl) = (yyvsp[(2) - (2)].decl);
+		    (yyval.decl).type = NewStringEmpty();
+		    SwigType_add_reference((yyval.decl).type);
+		    if ((yyvsp[(2) - (2)].decl).type) {
+		      SwigType_push((yyval.decl).type,(yyvsp[(2) - (2)].decl).type);
+		      Delete((yyvsp[(2) - (2)].decl).type);
+		    }
+                  ;}
+    break;
+
+  case 371:
+#line 5987 "parser.y"
+    {
+		    (yyval.decl) = (yyvsp[(2) - (2)].decl);
+		    (yyval.decl).type = NewStringEmpty();
+		    SwigType_add_rvalue_reference((yyval.decl).type);
+		    if ((yyvsp[(2) - (2)].decl).type) {
+		      SwigType_push((yyval.decl).type,(yyvsp[(2) - (2)].decl).type);
+		      Delete((yyvsp[(2) - (2)].decl).type);
+		    }
+                  ;}
+    break;
+
+  case 372:
+#line 5996 "parser.y"
+    {
+                    (yyval.decl).id = 0;
+                    (yyval.decl).parms = 0;
+		    (yyval.decl).have_parms = 0;
+                    (yyval.decl).type = NewStringEmpty();
+		    SwigType_add_reference((yyval.decl).type);
+                  ;}
+    break;
+
+  case 373:
+#line 6003 "parser.y"
+    {
+                    (yyval.decl).id = 0;
+                    (yyval.decl).parms = 0;
+		    (yyval.decl).have_parms = 0;
+                    (yyval.decl).type = NewStringEmpty();
+		    SwigType_add_rvalue_reference((yyval.decl).type);
+                  ;}
+    break;
+
+  case 374:
+#line 6010 "parser.y"
+    { 
+		    (yyval.decl).type = NewStringEmpty();
+                    SwigType_add_memberpointer((yyval.decl).type,(yyvsp[(1) - (2)].str));
+                    (yyval.decl).id = 0;
+                    (yyval.decl).parms = 0;
+		    (yyval.decl).have_parms = 0;
+      	          ;}
+    break;
+
+  case 375:
+#line 6017 "parser.y"
+    {
+		    (yyval.decl).type = NewStringEmpty();
+		    SwigType_add_memberpointer((yyval.decl).type, (yyvsp[(1) - (3)].str));
+		    SwigType_push((yyval.decl).type, (yyvsp[(3) - (3)].str));
+		    (yyval.decl).id = 0;
+		    (yyval.decl).parms = 0;
+		    (yyval.decl).have_parms = 0;
+		  ;}
+    break;
+
+  case 376:
+#line 6025 "parser.y"
+    { 
+		    SwigType *t = NewStringEmpty();
+                    (yyval.decl).type = (yyvsp[(1) - (3)].type);
+		    (yyval.decl).id = 0;
+		    (yyval.decl).parms = 0;
+		    (yyval.decl).have_parms = 0;
+		    SwigType_add_memberpointer(t,(yyvsp[(2) - (3)].str));
+		    SwigType_push((yyval.decl).type,t);
+		    Delete(t);
+                  ;}
+    break;
+
+  case 377:
+#line 6035 "parser.y"
+    { 
+		    (yyval.decl) = (yyvsp[(4) - (4)].decl);
+		    SwigType_add_memberpointer((yyvsp[(1) - (4)].type),(yyvsp[(2) - (4)].str));
+		    if ((yyval.decl).type) {
+		      SwigType_push((yyvsp[(1) - (4)].type),(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = (yyvsp[(1) - (4)].type);
+                  ;}
+    break;
+
+  case 378:
+#line 6046 "parser.y"
+    { 
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(1) - (3)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_array(t,"");
+		    if ((yyval.decl).type) {
+		      SwigType_push(t,(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 379:
+#line 6057 "parser.y"
+    { 
+		    SwigType *t;
+		    (yyval.decl) = (yyvsp[(1) - (4)].decl);
+		    t = NewStringEmpty();
+		    SwigType_add_array(t,(yyvsp[(3) - (4)].dtype).val);
+		    if ((yyval.decl).type) {
+		      SwigType_push(t,(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		    }
+		    (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 380:
+#line 6068 "parser.y"
+    { 
+		    (yyval.decl).type = NewStringEmpty();
+		    (yyval.decl).id = 0;
+		    (yyval.decl).parms = 0;
+		    (yyval.decl).have_parms = 0;
+		    SwigType_add_array((yyval.decl).type,"");
+                  ;}
+    break;
+
+  case 381:
+#line 6075 "parser.y"
+    { 
+		    (yyval.decl).type = NewStringEmpty();
+		    (yyval.decl).id = 0;
+		    (yyval.decl).parms = 0;
+		    (yyval.decl).have_parms = 0;
+		    SwigType_add_array((yyval.decl).type,(yyvsp[(2) - (3)].dtype).val);
+		  ;}
+    break;
+
+  case 382:
+#line 6082 "parser.y"
+    {
+                    (yyval.decl) = (yyvsp[(2) - (3)].decl);
+		  ;}
+    break;
+
+  case 383:
+#line 6085 "parser.y"
+    {
+		    SwigType *t;
+                    (yyval.decl) = (yyvsp[(1) - (4)].decl);
+		    t = NewStringEmpty();
+                    SwigType_add_function(t,(yyvsp[(3) - (4)].pl));
+		    if (!(yyval.decl).type) {
+		      (yyval.decl).type = t;
+		    } else {
+		      SwigType_push(t,(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		      (yyval.decl).type = t;
+		    }
+		    if (!(yyval.decl).have_parms) {
+		      (yyval.decl).parms = (yyvsp[(3) - (4)].pl);
+		      (yyval.decl).have_parms = 1;
+		    }
+		  ;}
+    break;
+
+  case 384:
+#line 6102 "parser.y"
+    {
+		    SwigType *t;
+                    (yyval.decl) = (yyvsp[(1) - (5)].decl);
+		    t = NewStringEmpty();
+                    SwigType_add_function(t,(yyvsp[(3) - (5)].pl));
+		    SwigType_push(t, (yyvsp[(5) - (5)].dtype).qualifier);
+		    if (!(yyval.decl).type) {
+		      (yyval.decl).type = t;
+		    } else {
+		      SwigType_push(t,(yyval.decl).type);
+		      Delete((yyval.decl).type);
+		      (yyval.decl).type = t;
+		    }
+		    if (!(yyval.decl).have_parms) {
+		      (yyval.decl).parms = (yyvsp[(3) - (5)].pl);
+		      (yyval.decl).have_parms = 1;
+		    }
+		  ;}
+    break;
+
+  case 385:
+#line 6120 "parser.y"
+    {
+                    (yyval.decl).type = NewStringEmpty();
+                    SwigType_add_function((yyval.decl).type,(yyvsp[(2) - (3)].pl));
+		    (yyval.decl).parms = (yyvsp[(2) - (3)].pl);
+		    (yyval.decl).have_parms = 1;
+		    (yyval.decl).id = 0;
+                  ;}
+    break;
+
+  case 386:
+#line 6130 "parser.y"
+    { 
+             (yyval.type) = NewStringEmpty();
+             SwigType_add_pointer((yyval.type));
+	     SwigType_push((yyval.type),(yyvsp[(2) - (3)].str));
+	     SwigType_push((yyval.type),(yyvsp[(3) - (3)].type));
+	     Delete((yyvsp[(3) - (3)].type));
+           ;}
+    break;
+
+  case 387:
+#line 6137 "parser.y"
+    {
+	     (yyval.type) = NewStringEmpty();
+	     SwigType_add_pointer((yyval.type));
+	     SwigType_push((yyval.type),(yyvsp[(2) - (2)].type));
+	     Delete((yyvsp[(2) - (2)].type));
+	   ;}
+    break;
+
+  case 388:
+#line 6143 "parser.y"
+    { 
+	     (yyval.type) = NewStringEmpty();
+	     SwigType_add_pointer((yyval.type));
+	     SwigType_push((yyval.type),(yyvsp[(2) - (2)].str));
+           ;}
+    break;
+
+  case 389:
+#line 6148 "parser.y"
+    {
+	     (yyval.type) = NewStringEmpty();
+	     SwigType_add_pointer((yyval.type));
+           ;}
+    break;
+
+  case 390:
+#line 6155 "parser.y"
+    {
+		  (yyval.dtype).qualifier = (yyvsp[(1) - (1)].str);
+		  (yyval.dtype).refqualifier = 0;
+	       ;}
+    break;
+
+  case 391:
+#line 6159 "parser.y"
+    {
+		  (yyval.dtype).qualifier = (yyvsp[(1) - (2)].str);
+		  (yyval.dtype).refqualifier = (yyvsp[(2) - (2)].str);
+		  SwigType_push((yyval.dtype).qualifier, (yyvsp[(2) - (2)].str));
+	       ;}
+    break;
+
+  case 392:
+#line 6164 "parser.y"
+    {
+		  (yyval.dtype).qualifier = NewStringEmpty();
+		  (yyval.dtype).refqualifier = (yyvsp[(1) - (1)].str);
+		  SwigType_push((yyval.dtype).qualifier, (yyvsp[(1) - (1)].str));
+	       ;}
+    break;
+
+  case 393:
+#line 6171 "parser.y"
+    {
+	          (yyval.str) = NewStringEmpty();
+	          SwigType_add_reference((yyval.str));
+	       ;}
+    break;
+
+  case 394:
+#line 6175 "parser.y"
+    {
+	          (yyval.str) = NewStringEmpty();
+	          SwigType_add_rvalue_reference((yyval.str));
+	       ;}
+    break;
+
+  case 395:
+#line 6181 "parser.y"
+    {
+	          (yyval.str) = NewStringEmpty();
+	          if ((yyvsp[(1) - (1)].id)) SwigType_add_qualifier((yyval.str),(yyvsp[(1) - (1)].id));
+               ;}
+    break;
+
+  case 396:
+#line 6185 "parser.y"
+    {
+		  (yyval.str) = (yyvsp[(2) - (2)].str);
+	          if ((yyvsp[(1) - (2)].id)) SwigType_add_qualifier((yyval.str),(yyvsp[(1) - (2)].id));
+               ;}
+    break;
+
+  case 397:
+#line 6191 "parser.y"
+    { (yyval.id) = "const"; ;}
+    break;
+
+  case 398:
+#line 6192 "parser.y"
+    { (yyval.id) = "volatile"; ;}
+    break;
+
+  case 399:
+#line 6193 "parser.y"
+    { (yyval.id) = 0; ;}
+    break;
+
+  case 400:
+#line 6199 "parser.y"
+    {
+                   (yyval.type) = (yyvsp[(1) - (1)].type);
+                   Replace((yyval.type),"typename ","", DOH_REPLACE_ANY);
+                ;}
+    break;
+
+  case 401:
+#line 6205 "parser.y"
+    {
+                   (yyval.type) = (yyvsp[(2) - (2)].type);
+	           SwigType_push((yyval.type),(yyvsp[(1) - (2)].str));
+               ;}
+    break;
+
+  case 402:
+#line 6209 "parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 403:
+#line 6210 "parser.y"
+    {
+		  (yyval.type) = (yyvsp[(1) - (2)].type);
+	          SwigType_push((yyval.type),(yyvsp[(2) - (2)].str));
+	       ;}
+    break;
+
+  case 404:
+#line 6214 "parser.y"
+    {
+		  (yyval.type) = (yyvsp[(2) - (3)].type);
+	          SwigType_push((yyval.type),(yyvsp[(3) - (3)].str));
+	          SwigType_push((yyval.type),(yyvsp[(1) - (3)].str));
+	       ;}
+    break;
+
+  case 405:
+#line 6221 "parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type);
+                  /* Printf(stdout,"primitive = '%s'\n", $$);*/
+               ;}
+    break;
+
+  case 406:
+#line 6224 "parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 407:
+#line 6225 "parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 408:
+#line 6229 "parser.y"
+    { (yyval.type) = NewStringf("enum %s", (yyvsp[(2) - (2)].str)); ;}
+    break;
+
+  case 409:
+#line 6230 "parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 410:
+#line 6232 "parser.y"
+    {
+		  (yyval.type) = (yyvsp[(1) - (1)].str);
+               ;}
+    break;
+
+  case 411:
+#line 6235 "parser.y"
+    { 
+		 (yyval.type) = NewStringf("%s %s", (yyvsp[(1) - (2)].id), (yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 412:
+#line 6238 "parser.y"
+    {
+                 (yyval.type) = (yyvsp[(1) - (1)].type);
+               ;}
+    break;
+
+  case 413:
+#line 6243 "parser.y"
+    {
+                 Node *n = Swig_symbol_clookup((yyvsp[(3) - (4)].str),0);
+                 if (!n) {
+		   Swig_error(cparse_file, cparse_line, "Identifier %s not defined.\n", (yyvsp[(3) - (4)].str));
+                   (yyval.type) = (yyvsp[(3) - (4)].str);
+                 } else {
+                   (yyval.type) = Getattr(n, "type");
+                 }
+               ;}
+    break;
+
+  case 414:
+#line 6254 "parser.y"
+    {
+		 if (!(yyvsp[(1) - (1)].ptype).type) (yyvsp[(1) - (1)].ptype).type = NewString("int");
+		 if ((yyvsp[(1) - (1)].ptype).us) {
+		   (yyval.type) = NewStringf("%s %s", (yyvsp[(1) - (1)].ptype).us, (yyvsp[(1) - (1)].ptype).type);
+		   Delete((yyvsp[(1) - (1)].ptype).us);
+                   Delete((yyvsp[(1) - (1)].ptype).type);
+		 } else {
+                   (yyval.type) = (yyvsp[(1) - (1)].ptype).type;
+		 }
+		 if (Cmp((yyval.type),"signed int") == 0) {
+		   Delete((yyval.type));
+		   (yyval.type) = NewString("int");
+                 } else if (Cmp((yyval.type),"signed long") == 0) {
+		   Delete((yyval.type));
+                   (yyval.type) = NewString("long");
+                 } else if (Cmp((yyval.type),"signed short") == 0) {
+		   Delete((yyval.type));
+		   (yyval.type) = NewString("short");
+		 } else if (Cmp((yyval.type),"signed long long") == 0) {
+		   Delete((yyval.type));
+		   (yyval.type) = NewString("long long");
+		 }
+               ;}
+    break;
+
+  case 415:
+#line 6279 "parser.y"
+    { 
+                 (yyval.ptype) = (yyvsp[(1) - (1)].ptype);
+               ;}
+    break;
+
+  case 416:
+#line 6282 "parser.y"
+    {
+                    if ((yyvsp[(1) - (2)].ptype).us && (yyvsp[(2) - (2)].ptype).us) {
+		      Swig_error(cparse_file, cparse_line, "Extra %s specifier.\n", (yyvsp[(2) - (2)].ptype).us);
+		    }
+                    (yyval.ptype) = (yyvsp[(2) - (2)].ptype);
+                    if ((yyvsp[(1) - (2)].ptype).us) (yyval.ptype).us = (yyvsp[(1) - (2)].ptype).us;
+		    if ((yyvsp[(1) - (2)].ptype).type) {
+		      if (!(yyvsp[(2) - (2)].ptype).type) (yyval.ptype).type = (yyvsp[(1) - (2)].ptype).type;
+		      else {
+			int err = 0;
+			if ((Cmp((yyvsp[(1) - (2)].ptype).type,"long") == 0)) {
+			  if ((Cmp((yyvsp[(2) - (2)].ptype).type,"long") == 0) || (Strncmp((yyvsp[(2) - (2)].ptype).type,"double",6) == 0)) {
+			    (yyval.ptype).type = NewStringf("long %s", (yyvsp[(2) - (2)].ptype).type);
+			  } else if (Cmp((yyvsp[(2) - (2)].ptype).type,"int") == 0) {
+			    (yyval.ptype).type = (yyvsp[(1) - (2)].ptype).type;
+			  } else {
+			    err = 1;
+			  }
+			} else if ((Cmp((yyvsp[(1) - (2)].ptype).type,"short")) == 0) {
+			  if (Cmp((yyvsp[(2) - (2)].ptype).type,"int") == 0) {
+			    (yyval.ptype).type = (yyvsp[(1) - (2)].ptype).type;
+			  } else {
+			    err = 1;
+			  }
+			} else if (Cmp((yyvsp[(1) - (2)].ptype).type,"int") == 0) {
+			  (yyval.ptype).type = (yyvsp[(2) - (2)].ptype).type;
+			} else if (Cmp((yyvsp[(1) - (2)].ptype).type,"double") == 0) {
+			  if (Cmp((yyvsp[(2) - (2)].ptype).type,"long") == 0) {
+			    (yyval.ptype).type = NewString("long double");
+			  } else if (Cmp((yyvsp[(2) - (2)].ptype).type,"_Complex") == 0) {
+			    (yyval.ptype).type = NewString("double _Complex");
+			  } else {
+			    err = 1;
+			  }
+			} else if (Cmp((yyvsp[(1) - (2)].ptype).type,"float") == 0) {
+			  if (Cmp((yyvsp[(2) - (2)].ptype).type,"_Complex") == 0) {
+			    (yyval.ptype).type = NewString("float _Complex");
+			  } else {
+			    err = 1;
+			  }
+			} else if (Cmp((yyvsp[(1) - (2)].ptype).type,"_Complex") == 0) {
+			  (yyval.ptype).type = NewStringf("%s _Complex", (yyvsp[(2) - (2)].ptype).type);
+			} else {
+			  err = 1;
+			}
+			if (err) {
+			  Swig_error(cparse_file, cparse_line, "Extra %s specifier.\n", (yyvsp[(1) - (2)].ptype).type);
+			}
+		      }
+		    }
+               ;}
+    break;
+
+  case 417:
+#line 6336 "parser.y"
+    { 
+		    (yyval.ptype).type = NewString("int");
+                    (yyval.ptype).us = 0;
+               ;}
+    break;
+
+  case 418:
+#line 6340 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("short");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 419:
+#line 6344 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("long");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 420:
+#line 6348 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("char");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 421:
+#line 6352 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("wchar_t");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 422:
+#line 6356 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("float");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 423:
+#line 6360 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("double");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 424:
+#line 6364 "parser.y"
+    { 
+                    (yyval.ptype).us = NewString("signed");
+                    (yyval.ptype).type = 0;
+                ;}
+    break;
+
+  case 425:
+#line 6368 "parser.y"
+    { 
+                    (yyval.ptype).us = NewString("unsigned");
+                    (yyval.ptype).type = 0;
+                ;}
+    break;
+
+  case 426:
+#line 6372 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("_Complex");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 427:
+#line 6376 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("__int8");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 428:
+#line 6380 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("__int16");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 429:
+#line 6384 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("__int32");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 430:
+#line 6388 "parser.y"
+    { 
+                    (yyval.ptype).type = NewString("__int64");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 431:
+#line 6394 "parser.y"
+    { /* scanner_check_typedef(); */ ;}
+    break;
+
+  case 432:
+#line 6394 "parser.y"
+    {
+                   (yyval.dtype) = (yyvsp[(2) - (2)].dtype);
+		   if ((yyval.dtype).type == T_STRING) {
+		     (yyval.dtype).rawval = NewStringf("\"%(escape)s\"",(yyval.dtype).val);
+		   } else if ((yyval.dtype).type != T_CHAR && (yyval.dtype).type != T_WSTRING && (yyval.dtype).type != T_WCHAR) {
+		     (yyval.dtype).rawval = NewStringf("%s", (yyval.dtype).val);
+		   }
+		   (yyval.dtype).qualifier = 0;
+		   (yyval.dtype).refqualifier = 0;
+		   (yyval.dtype).bitfield = 0;
+		   (yyval.dtype).throws = 0;
+		   (yyval.dtype).throwf = 0;
+		   (yyval.dtype).nexcept = 0;
+		   (yyval.dtype).final = 0;
+		   scanner_ignore_typedef();
+                ;}
+    break;
+
+  case 433:
+#line 6410 "parser.y"
+    {
+		  (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+		;}
+    break;
+
+  case 434:
+#line 6415 "parser.y"
+    {
+		  (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+		;}
+    break;
+
+  case 435:
+#line 6418 "parser.y"
+    {
+		  (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+		;}
+    break;
+
+  case 436:
+#line 6424 "parser.y"
+    {
+		  (yyval.dtype).val = NewString("delete");
+		  (yyval.dtype).rawval = 0;
+		  (yyval.dtype).type = T_STRING;
+		  (yyval.dtype).qualifier = 0;
+		  (yyval.dtype).refqualifier = 0;
+		  (yyval.dtype).bitfield = 0;
+		  (yyval.dtype).throws = 0;
+		  (yyval.dtype).throwf = 0;
+		  (yyval.dtype).nexcept = 0;
+		  (yyval.dtype).final = 0;
+		;}
+    break;
+
+  case 437:
+#line 6439 "parser.y"
+    {
+		  (yyval.dtype).val = NewString("default");
+		  (yyval.dtype).rawval = 0;
+		  (yyval.dtype).type = T_STRING;
+		  (yyval.dtype).qualifier = 0;
+		  (yyval.dtype).refqualifier = 0;
+		  (yyval.dtype).bitfield = 0;
+		  (yyval.dtype).throws = 0;
+		  (yyval.dtype).throwf = 0;
+		  (yyval.dtype).nexcept = 0;
+		  (yyval.dtype).final = 0;
+		;}
+    break;
+
+  case 438:
+#line 6455 "parser.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); ;}
+    break;
+
+  case 439:
+#line 6456 "parser.y"
+    { (yyval.id) = (char *) 0;;}
+    break;
+
+  case 444:
+#line 6475 "parser.y"
+    {
+		  Setattr((yyvsp[(1) - (1)].node),"_last",(yyvsp[(1) - (1)].node));
+		  (yyval.node) = (yyvsp[(1) - (1)].node);
+		;}
+    break;
+
+  case 445:
+#line 6479 "parser.y"
+    {
+		  Setattr((yyvsp[(1) - (2)].node),"_last",(yyvsp[(1) - (2)].node));
+		  set_comment((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].str));
+		  (yyval.node) = (yyvsp[(1) - (2)].node);
+		;}
+    break;
+
+  case 446:
+#line 6484 "parser.y"
+    {
+		  if ((yyvsp[(3) - (3)].node)) {
+		    set_nextSibling((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
+		    Setattr((yyvsp[(1) - (3)].node),"_last",Getattr((yyvsp[(3) - (3)].node),"_last"));
+		    Setattr((yyvsp[(3) - (3)].node),"_last",NULL);
+		  } else {
+		    Setattr((yyvsp[(1) - (3)].node),"_last",(yyvsp[(1) - (3)].node));
+		  }
+		  (yyval.node) = (yyvsp[(1) - (3)].node);
+		;}
+    break;
+
+  case 447:
+#line 6494 "parser.y"
+    {
+		  if ((yyvsp[(4) - (4)].node)) {
+		    set_nextSibling((yyvsp[(1) - (4)].node), (yyvsp[(4) - (4)].node));
+		    Setattr((yyvsp[(1) - (4)].node),"_last",Getattr((yyvsp[(4) - (4)].node),"_last"));
+		    Setattr((yyvsp[(4) - (4)].node),"_last",NULL);
+		  } else {
+		    Setattr((yyvsp[(1) - (4)].node),"_last",(yyvsp[(1) - (4)].node));
+		  }
+		  set_comment((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].str));
+		  (yyval.node) = (yyvsp[(1) - (4)].node);
+		;}
+    break;
+
+  case 448:
+#line 6505 "parser.y"
+    {
+		  (yyval.node) = 0;
+		;}
+    break;
+
+  case 449:
+#line 6510 "parser.y"
+    {
+		  (yyval.node) = (yyvsp[(2) - (3)].node);
+		;}
+    break;
+
+  case 450:
+#line 6515 "parser.y"
+    {
+		  (yyval.node) = (yyvsp[(1) - (1)].node);
+		;}
+    break;
+
+  case 451:
+#line 6518 "parser.y"
+    {
+		  (yyval.node) = (yyvsp[(2) - (2)].node);
+		  set_comment((yyvsp[(2) - (2)].node), (yyvsp[(1) - (2)].str));
+		;}
+    break;
+
+  case 452:
+#line 6524 "parser.y"
+    {
+		   SwigType *type = NewSwigType(T_INT);
+		   (yyval.node) = new_node("enumitem");
+		   Setattr((yyval.node),"name",(yyvsp[(1) - (1)].id));
+		   Setattr((yyval.node),"type",type);
+		   SetFlag((yyval.node),"feature:immutable");
+		   Delete(type);
+		 ;}
+    break;
+
+  case 453:
+#line 6532 "parser.y"
+    {
+		   SwigType *type = NewSwigType((yyvsp[(3) - (3)].dtype).type == T_BOOL ? T_BOOL : ((yyvsp[(3) - (3)].dtype).type == T_CHAR ? T_CHAR : T_INT));
+		   (yyval.node) = new_node("enumitem");
+		   Setattr((yyval.node),"name",(yyvsp[(1) - (3)].id));
+		   Setattr((yyval.node),"type",type);
+		   SetFlag((yyval.node),"feature:immutable");
+		   Setattr((yyval.node),"enumvalue", (yyvsp[(3) - (3)].dtype).val);
+		   Setattr((yyval.node),"value",(yyvsp[(1) - (3)].id));
+		   Delete(type);
+                 ;}
+    break;
+
+  case 454:
+#line 6544 "parser.y"
+    {
+                   (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+		   if (((yyval.dtype).type != T_INT) && ((yyval.dtype).type != T_UINT) &&
+		       ((yyval.dtype).type != T_LONG) && ((yyval.dtype).type != T_ULONG) &&
+		       ((yyval.dtype).type != T_LONGLONG) && ((yyval.dtype).type != T_ULONGLONG) &&
+		       ((yyval.dtype).type != T_SHORT) && ((yyval.dtype).type != T_USHORT) &&
+		       ((yyval.dtype).type != T_SCHAR) && ((yyval.dtype).type != T_UCHAR) &&
+		       ((yyval.dtype).type != T_CHAR) && ((yyval.dtype).type != T_BOOL)) {
+		     Swig_error(cparse_file,cparse_line,"Type error. Expecting an integral type\n");
+		   }
+                ;}
+    break;
+
+  case 455:
+#line 6559 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 456:
+#line 6560 "parser.y"
+    {
+		 Node *n;
+		 (yyval.dtype).val = (yyvsp[(1) - (1)].type);
+		 (yyval.dtype).type = T_INT;
+		 /* Check if value is in scope */
+		 n = Swig_symbol_clookup((yyvsp[(1) - (1)].type),0);
+		 if (n) {
+                   /* A band-aid for enum values used in expressions. */
+                   if (Strcmp(nodeType(n),"enumitem") == 0) {
+                     String *q = Swig_symbol_qualified(n);
+                     if (q) {
+                       (yyval.dtype).val = NewStringf("%s::%s", q, Getattr(n,"name"));
+                       Delete(q);
+                     }
+                   }
+		 }
+               ;}
+    break;
+
+  case 457:
+#line 6580 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s->%s", (yyvsp[(1) - (3)].id), (yyvsp[(3) - (3)].id));
+		 (yyval.dtype).type = 0;
+	       ;}
+    break;
+
+  case 458:
+#line 6584 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s->%s(%s)", (yyvsp[(1) - (6)].id), (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].dtype).val);
+		 (yyval.dtype).type = 0;
+	       ;}
+    break;
+
+  case 459:
+#line 6588 "parser.y"
+    {
+		 (yyval.dtype) = (yyvsp[(1) - (3)].dtype);
+		 Printf((yyval.dtype).val, "->%s", (yyvsp[(3) - (3)].id));
+	       ;}
+    break;
+
+  case 460:
+#line 6592 "parser.y"
+    {
+		 (yyval.dtype) = (yyvsp[(1) - (6)].dtype);
+		 Printf((yyval.dtype).val, "->%s(%s)", (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].dtype).val);
+	       ;}
+    break;
+
+  case 461:
+#line 6596 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s.%s", (yyvsp[(1) - (3)].id), (yyvsp[(3) - (3)].id));
+		 (yyval.dtype).type = 0;
+	       ;}
+    break;
+
+  case 462:
+#line 6600 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s.%s(%s)", (yyvsp[(1) - (6)].id), (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].dtype).val);
+		 (yyval.dtype).type = 0;
+	       ;}
+    break;
+
+  case 463:
+#line 6604 "parser.y"
+    {
+		 (yyval.dtype) = (yyvsp[(1) - (3)].dtype);
+		 Printf((yyval.dtype).val, ".%s", (yyvsp[(3) - (3)].id));
+	       ;}
+    break;
+
+  case 464:
+#line 6608 "parser.y"
+    {
+		 (yyval.dtype) = (yyvsp[(1) - (6)].dtype);
+		 Printf((yyval.dtype).val, ".%s(%s)", (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].dtype).val);
+	       ;}
+    break;
+
+  case 465:
+#line 6615 "parser.y"
+    {
+		    (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+               ;}
+    break;
+
+  case 466:
+#line 6618 "parser.y"
+    {
+		    (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+               ;}
+    break;
+
+  case 467:
+#line 6621 "parser.y"
+    {
+		    (yyval.dtype).val = (yyvsp[(1) - (1)].str);
+                    (yyval.dtype).type = T_STRING;
+               ;}
+    break;
+
+  case 468:
+#line 6625 "parser.y"
+    {
+		  SwigType_push((yyvsp[(3) - (5)].type),(yyvsp[(4) - (5)].decl).type);
+		  (yyval.dtype).val = NewStringf("sizeof(%s)",SwigType_str((yyvsp[(3) - (5)].type),0));
+		  (yyval.dtype).type = T_ULONG;
+               ;}
+    break;
+
+  case 469:
+#line 6630 "parser.y"
+    {
+		  SwigType_push((yyvsp[(4) - (6)].type),(yyvsp[(5) - (6)].decl).type);
+		  (yyval.dtype).val = NewStringf("sizeof...(%s)",SwigType_str((yyvsp[(4) - (6)].type),0));
+		  (yyval.dtype).type = T_ULONG;
+               ;}
+    break;
+
+  case 470:
+#line 6642 "parser.y"
+    {
+		  (yyval.dtype).val = NewStringf("sizeof(%s)", (yyvsp[(3) - (4)].dtype).val);
+		 (yyval.dtype).type = T_ULONG;
+	       ;}
+    break;
+
+  case 471:
+#line 6650 "parser.y"
+    {
+		  (yyval.dtype).val = NewStringf("sizeof(%s)", (yyvsp[(2) - (2)].dtype).val);
+		  (yyval.dtype).type = T_ULONG;
+	       ;}
+    break;
+
+  case 472:
+#line 6654 "parser.y"
+    {
+		    (yyval.dtype).val = (yyvsp[(1) - (1)].str);
+		    (yyval.dtype).rawval = NewStringf("L\"%s\"", (yyval.dtype).val);
+                    (yyval.dtype).type = T_WSTRING;
+	       ;}
+    break;
+
+  case 473:
+#line 6659 "parser.y"
+    {
+		  (yyval.dtype).val = NewString((yyvsp[(1) - (1)].str));
+		  if (Len((yyval.dtype).val)) {
+		    (yyval.dtype).rawval = NewStringf("'%(escape)s'", (yyval.dtype).val);
+		  } else {
+		    (yyval.dtype).rawval = NewString("'\\0'");
+		  }
+		  (yyval.dtype).type = T_CHAR;
+		  (yyval.dtype).bitfield = 0;
+		  (yyval.dtype).throws = 0;
+		  (yyval.dtype).throwf = 0;
+		  (yyval.dtype).nexcept = 0;
+		  (yyval.dtype).final = 0;
+	       ;}
+    break;
+
+  case 474:
+#line 6673 "parser.y"
+    {
+		  (yyval.dtype).val = NewString((yyvsp[(1) - (1)].str));
+		  if (Len((yyval.dtype).val)) {
+		    (yyval.dtype).rawval = NewStringf("L\'%s\'", (yyval.dtype).val);
+		  } else {
+		    (yyval.dtype).rawval = NewString("L'\\0'");
+		  }
+		  (yyval.dtype).type = T_WCHAR;
+		  (yyval.dtype).bitfield = 0;
+		  (yyval.dtype).throws = 0;
+		  (yyval.dtype).throwf = 0;
+		  (yyval.dtype).nexcept = 0;
+		  (yyval.dtype).final = 0;
+	       ;}
+    break;
+
+  case 475:
+#line 6690 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 476:
+#line 6691 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 477:
+#line 6694 "parser.y"
+    {
+		    (yyval.dtype).val = NewStringf("(%s)",(yyvsp[(2) - (3)].dtype).val);
+		    if ((yyvsp[(2) - (3)].dtype).rawval) {
+		      (yyval.dtype).rawval = NewStringf("(%s)",(yyvsp[(2) - (3)].dtype).rawval);
+		    }
+		    (yyval.dtype).type = (yyvsp[(2) - (3)].dtype).type;
+	       ;}
+    break;
+
+  case 478:
+#line 6704 "parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(4) - (4)].dtype);
+		 if ((yyvsp[(4) - (4)].dtype).type != T_STRING) {
+		   switch ((yyvsp[(2) - (4)].dtype).type) {
+		     case T_FLOAT:
+		     case T_DOUBLE:
+		     case T_LONGDOUBLE:
+		     case T_FLTCPLX:
+		     case T_DBLCPLX:
+		       (yyval.dtype).val = NewStringf("(%s)%s", (yyvsp[(2) - (4)].dtype).val, (yyvsp[(4) - (4)].dtype).val); /* SwigType_str and decimal points don't mix! */
+		       break;
+		     default:
+		       (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (4)].dtype).val,0), (yyvsp[(4) - (4)].dtype).val);
+		       break;
+		   }
+		 }
+		 (yyval.dtype).type = promote((yyvsp[(2) - (4)].dtype).type, (yyvsp[(4) - (4)].dtype).type);
+ 	       ;}
+    break;
+
+  case 479:
+#line 6722 "parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(5) - (5)].dtype);
+		 if ((yyvsp[(5) - (5)].dtype).type != T_STRING) {
+		   SwigType_push((yyvsp[(2) - (5)].dtype).val,(yyvsp[(3) - (5)].type));
+		   (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (5)].dtype).val,0), (yyvsp[(5) - (5)].dtype).val);
+		 }
+ 	       ;}
+    break;
+
+  case 480:
+#line 6729 "parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(5) - (5)].dtype);
+		 if ((yyvsp[(5) - (5)].dtype).type != T_STRING) {
+		   SwigType_add_reference((yyvsp[(2) - (5)].dtype).val);
+		   (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (5)].dtype).val,0), (yyvsp[(5) - (5)].dtype).val);
+		 }
+ 	       ;}
+    break;
+
+  case 481:
+#line 6736 "parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(5) - (5)].dtype);
+		 if ((yyvsp[(5) - (5)].dtype).type != T_STRING) {
+		   SwigType_add_rvalue_reference((yyvsp[(2) - (5)].dtype).val);
+		   (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (5)].dtype).val,0), (yyvsp[(5) - (5)].dtype).val);
+		 }
+ 	       ;}
+    break;
+
+  case 482:
+#line 6743 "parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(6) - (6)].dtype);
+		 if ((yyvsp[(6) - (6)].dtype).type != T_STRING) {
+		   SwigType_push((yyvsp[(2) - (6)].dtype).val,(yyvsp[(3) - (6)].type));
+		   SwigType_add_reference((yyvsp[(2) - (6)].dtype).val);
+		   (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (6)].dtype).val,0), (yyvsp[(6) - (6)].dtype).val);
+		 }
+ 	       ;}
+    break;
+
+  case 483:
+#line 6751 "parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(6) - (6)].dtype);
+		 if ((yyvsp[(6) - (6)].dtype).type != T_STRING) {
+		   SwigType_push((yyvsp[(2) - (6)].dtype).val,(yyvsp[(3) - (6)].type));
+		   SwigType_add_rvalue_reference((yyvsp[(2) - (6)].dtype).val);
+		   (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (6)].dtype).val,0), (yyvsp[(6) - (6)].dtype).val);
+		 }
+ 	       ;}
+    break;
+
+  case 484:
+#line 6759 "parser.y"
+    {
+		 (yyval.dtype) = (yyvsp[(2) - (2)].dtype);
+                 (yyval.dtype).val = NewStringf("&%s",(yyvsp[(2) - (2)].dtype).val);
+	       ;}
+    break;
+
+  case 485:
+#line 6763 "parser.y"
+    {
+		 (yyval.dtype) = (yyvsp[(2) - (2)].dtype);
+                 (yyval.dtype).val = NewStringf("*%s",(yyvsp[(2) - (2)].dtype).val);
+	       ;}
+    break;
+
+  case 486:
+#line 6769 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 487:
+#line 6770 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 488:
+#line 6771 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 489:
+#line 6772 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 490:
+#line 6773 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 491:
+#line 6774 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 492:
+#line 6775 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 493:
+#line 6776 "parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 494:
+#line 6779 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s+%s", COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+	       ;}
+    break;
+
+  case 495:
+#line 6783 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s-%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+	       ;}
+    break;
+
+  case 496:
+#line 6787 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s*%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+	       ;}
+    break;
+
+  case 497:
+#line 6791 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s/%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+	       ;}
+    break;
+
+  case 498:
+#line 6795 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s%%%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+	       ;}
+    break;
+
+  case 499:
+#line 6799 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s&%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+	       ;}
+    break;
+
+  case 500:
+#line 6803 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s|%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+	       ;}
+    break;
+
+  case 501:
+#line 6807 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s^%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+	       ;}
+    break;
+
+  case 502:
+#line 6811 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s << %s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = promote_type((yyvsp[(1) - (3)].dtype).type);
+	       ;}
+    break;
+
+  case 503:
+#line 6815 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s >> %s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = promote_type((yyvsp[(1) - (3)].dtype).type);
+	       ;}
+    break;
+
+  case 504:
+#line 6819 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s&&%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+	       ;}
+    break;
+
+  case 505:
+#line 6823 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s||%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+	       ;}
+    break;
+
+  case 506:
+#line 6827 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s==%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+	       ;}
+    break;
+
+  case 507:
+#line 6831 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s!=%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+	       ;}
+    break;
+
+  case 508:
+#line 6839 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s > %s", COMPOUND_EXPR_VAL((yyvsp[(2) - (5)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(4) - (5)].dtype)));
+		 (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+	       ;}
+    break;
+
+  case 509:
+#line 6849 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s < %s", COMPOUND_EXPR_VAL((yyvsp[(2) - (5)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(4) - (5)].dtype)));
+		 (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+	       ;}
+    break;
+
+  case 510:
+#line 6853 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s >= %s", COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+	       ;}
+    break;
+
+  case 511:
+#line 6857 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s <= %s", COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+	       ;}
+    break;
+
+  case 512:
+#line 6861 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s <=> %s", COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+		 /* Really `<=>` returns one of `std::strong_ordering`,
+		  * `std::partial_ordering` or `std::weak_ordering`, but we
+		  * fake it by treating the return value as `int`.  The main
+		  * thing to do with the return value in this context is to
+		  * compare it with 0, for which `int` does the job. */
+		 (yyval.dtype).type = T_INT;
+	       ;}
+    break;
+
+  case 513:
+#line 6870 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("%s?%s:%s", COMPOUND_EXPR_VAL((yyvsp[(1) - (5)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(3) - (5)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(5) - (5)].dtype)));
+		 /* This may not be exactly right, but is probably good enough
+		  * for the purposes of parsing constant expressions. */
+		 (yyval.dtype).type = promote((yyvsp[(3) - (5)].dtype).type, (yyvsp[(5) - (5)].dtype).type);
+	       ;}
+    break;
+
+  case 514:
+#line 6876 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("-%s",(yyvsp[(2) - (2)].dtype).val);
+		 (yyval.dtype).type = (yyvsp[(2) - (2)].dtype).type;
+	       ;}
+    break;
+
+  case 515:
+#line 6880 "parser.y"
+    {
+                 (yyval.dtype).val = NewStringf("+%s",(yyvsp[(2) - (2)].dtype).val);
+		 (yyval.dtype).type = (yyvsp[(2) - (2)].dtype).type;
+	       ;}
+    break;
+
+  case 516:
+#line 6884 "parser.y"
+    {
+		 (yyval.dtype).val = NewStringf("~%s",(yyvsp[(2) - (2)].dtype).val);
+		 (yyval.dtype).type = (yyvsp[(2) - (2)].dtype).type;
+	       ;}
+    break;
+
+  case 517:
+#line 6888 "parser.y"
+    {
+                 (yyval.dtype).val = NewStringf("!%s",COMPOUND_EXPR_VAL((yyvsp[(2) - (2)].dtype)));
+		 (yyval.dtype).type = T_INT;
+	       ;}
+    break;
+
+  case 518:
+#line 6892 "parser.y"
+    {
+		 String *qty;
+                 skip_balanced('(',')');
+		 qty = Swig_symbol_type_qualify((yyvsp[(1) - (2)].type),0);
+		 if (SwigType_istemplate(qty)) {
+		   String *nstr = SwigType_namestr(qty);
+		   Delete(qty);
+		   qty = nstr;
+		 }
+		 (yyval.dtype).val = NewStringf("%s%s",qty,scanner_ccode);
+		 Clear(scanner_ccode);
+		 (yyval.dtype).type = T_INT;
+		 Delete(qty);
+               ;}
+    break;
+
+  case 519:
+#line 6908 "parser.y"
+    {
+	        (yyval.str) = NewString("...");
+	      ;}
+    break;
+
+  case 520:
+#line 6911 "parser.y"
+    {
+	        (yyval.str) = 0;
+	      ;}
+    break;
+
+  case 521:
+#line 6916 "parser.y"
+    {
+		 (yyval.bases) = (yyvsp[(1) - (1)].bases);
+               ;}
+    break;
+
+  case 522:
+#line 6921 "parser.y"
+    { inherit_list = 1; ;}
+    break;
+
+  case 523:
+#line 6921 "parser.y"
+    { (yyval.bases) = (yyvsp[(3) - (3)].bases); inherit_list = 0; ;}
+    break;
+
+  case 524:
+#line 6922 "parser.y"
+    { (yyval.bases) = 0; ;}
+    break;
+
+  case 525:
+#line 6925 "parser.y"
+    {
+		   Hash *list = NewHash();
+		   Node *base = (yyvsp[(1) - (1)].node);
+		   Node *name = Getattr(base,"name");
+		   List *lpublic = NewList();
+		   List *lprotected = NewList();
+		   List *lprivate = NewList();
+		   Setattr(list,"public",lpublic);
+		   Setattr(list,"protected",lprotected);
+		   Setattr(list,"private",lprivate);
+		   Delete(lpublic);
+		   Delete(lprotected);
+		   Delete(lprivate);
+		   Append(Getattr(list,Getattr(base,"access")),name);
+	           (yyval.bases) = list;
+               ;}
+    break;
+
+  case 526:
+#line 6942 "parser.y"
+    {
+		   Hash *list = (yyvsp[(1) - (3)].bases);
+		   Node *base = (yyvsp[(3) - (3)].node);
+		   Node *name = Getattr(base,"name");
+		   Append(Getattr(list,Getattr(base,"access")),name);
+                   (yyval.bases) = list;
+               ;}
+    break;
+
+  case 527:
+#line 6951 "parser.y"
+    {
+		 (yyval.intvalue) = cparse_line;
+	       ;}
+    break;
+
+  case 528:
+#line 6953 "parser.y"
+    {
+		 (yyval.node) = NewHash();
+		 Setfile((yyval.node),cparse_file);
+		 Setline((yyval.node),(yyvsp[(2) - (4)].intvalue));
+		 Setattr((yyval.node),"name",(yyvsp[(3) - (4)].str));
+		 Setfile((yyvsp[(3) - (4)].str),cparse_file);
+		 Setline((yyvsp[(3) - (4)].str),(yyvsp[(2) - (4)].intvalue));
+                 if (last_cpptype && (Strcmp(last_cpptype,"struct") != 0)) {
+		   Setattr((yyval.node),"access","private");
+		   Swig_warning(WARN_PARSE_NO_ACCESS, Getfile((yyval.node)), Getline((yyval.node)), "No access specifier given for base class '%s' (ignored).\n", SwigType_namestr((yyvsp[(3) - (4)].str)));
+                 } else {
+		   Setattr((yyval.node),"access","public");
+		 }
+		 if ((yyvsp[(4) - (4)].str))
+		   SetFlag((yyval.node), "variadic");
+               ;}
+    break;
+
+  case 529:
+#line 6969 "parser.y"
+    {
+		 (yyval.intvalue) = cparse_line;
+	       ;}
+    break;
+
+  case 530:
+#line 6971 "parser.y"
+    {
+		 (yyval.node) = NewHash();
+		 Setfile((yyval.node),cparse_file);
+		 Setline((yyval.node),(yyvsp[(3) - (6)].intvalue));
+		 Setattr((yyval.node),"name",(yyvsp[(5) - (6)].str));
+		 Setfile((yyvsp[(5) - (6)].str),cparse_file);
+		 Setline((yyvsp[(5) - (6)].str),(yyvsp[(3) - (6)].intvalue));
+		 Setattr((yyval.node),"access",(yyvsp[(2) - (6)].id));
+	         if (Strcmp((yyvsp[(2) - (6)].id),"public") != 0) {
+		   Swig_warning(WARN_PARSE_PRIVATE_INHERIT, Getfile((yyval.node)), Getline((yyval.node)), "%s inheritance from base '%s' (ignored).\n", (yyvsp[(2) - (6)].id), SwigType_namestr((yyvsp[(5) - (6)].str)));
+		 }
+		 if ((yyvsp[(6) - (6)].str))
+		   SetFlag((yyval.node), "variadic");
+               ;}
+    break;
+
+  case 531:
+#line 6987 "parser.y"
+    { (yyval.id) = (char*)"public"; ;}
+    break;
+
+  case 532:
+#line 6988 "parser.y"
+    { (yyval.id) = (char*)"private"; ;}
+    break;
+
+  case 533:
+#line 6989 "parser.y"
+    { (yyval.id) = (char*)"protected"; ;}
+    break;
+
+  case 534:
+#line 6992 "parser.y"
+    { 
+                   (yyval.id) = (char*)"class"; 
+		   if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 535:
+#line 6996 "parser.y"
+    { 
+                   (yyval.id) = (char *)"typename"; 
+		   if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 536:
+#line 7000 "parser.y"
+    {
+                   (yyval.id) = (char *)"class..."; 
+		   if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 537:
+#line 7004 "parser.y"
+    {
+                   (yyval.id) = (char *)"typename..."; 
+		   if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 538:
+#line 7010 "parser.y"
+    {
+                 (yyval.id) = (yyvsp[(1) - (1)].id);
+               ;}
+    break;
+
+  case 539:
+#line 7013 "parser.y"
+    { 
+                   (yyval.id) = (char*)"struct"; 
+		   if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 540:
+#line 7017 "parser.y"
+    {
+                   (yyval.id) = (char*)"union"; 
+		   if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 541:
+#line 7023 "parser.y"
+    {
+                   (yyval.id) = (char*)"class";
+		   if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 542:
+#line 7027 "parser.y"
+    {
+                   (yyval.id) = (char*)"struct";
+		   if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 543:
+#line 7031 "parser.y"
+    {
+                   (yyval.id) = (char*)"union";
+		   if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 544:
+#line 7037 "parser.y"
+    {
+		   (yyval.id) = (yyvsp[(1) - (1)].id);
+               ;}
+    break;
+
+  case 545:
+#line 7040 "parser.y"
+    {
+		   (yyval.id) = 0;
+               ;}
+    break;
+
+  case 548:
+#line 7049 "parser.y"
+    {
+                   (yyval.str) = 0;
+	       ;}
+    break;
+
+  case 549:
+#line 7052 "parser.y"
+    {
+                   (yyval.str) = NewString("1");
+	       ;}
+    break;
+
+  case 550:
+#line 7055 "parser.y"
+    {
+                   (yyval.str) = NewString("1");
+	       ;}
+    break;
+
+  case 551:
+#line 7058 "parser.y"
+    {
+                   (yyval.str) = NewString("1");
+	       ;}
+    break;
+
+  case 552:
+#line 7063 "parser.y"
+    {
+                   (yyval.str) = (yyvsp[(1) - (1)].str);
+               ;}
+    break;
+
+  case 553:
+#line 7066 "parser.y"
+    {
+                   (yyval.str) = 0;
+               ;}
+    break;
+
+  case 554:
+#line 7071 "parser.y"
+    {
+                   (yyval.str) = NewString("1");
+               ;}
+    break;
+
+  case 555:
+#line 7074 "parser.y"
+    {
+                   (yyval.str) = 0;
+               ;}
+    break;
+
+  case 556:
+#line 7079 "parser.y"
+    {
+                    (yyval.dtype).throws = (yyvsp[(3) - (4)].pl);
+                    (yyval.dtype).throwf = NewString("1");
+                    (yyval.dtype).nexcept = 0;
+                    (yyval.dtype).final = 0;
+	       ;}
+    break;
+
+  case 557:
+#line 7085 "parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = NewString("true");
+                    (yyval.dtype).final = 0;
+	       ;}
+    break;
+
+  case 558:
+#line 7091 "parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = 0;
+                    (yyval.dtype).final = (yyvsp[(1) - (1)].str);
+	       ;}
+    break;
+
+  case 559:
+#line 7097 "parser.y"
+    {
+                    (yyval.dtype).throws = (yyvsp[(3) - (5)].pl);
+                    (yyval.dtype).throwf = NewString("1");
+                    (yyval.dtype).nexcept = 0;
+                    (yyval.dtype).final = (yyvsp[(5) - (5)].str);
+	       ;}
+    break;
+
+  case 560:
+#line 7103 "parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = NewString("true");
+                    (yyval.dtype).final = (yyvsp[(2) - (2)].str);
+	       ;}
+    break;
+
+  case 561:
+#line 7109 "parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = (yyvsp[(3) - (4)].dtype).val;
+                    (yyval.dtype).final = 0;
+	       ;}
+    break;
+
+  case 562:
+#line 7117 "parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = 0;
+                    (yyval.dtype).final = 0;
+                    (yyval.dtype).qualifier = (yyvsp[(1) - (1)].dtype).qualifier;
+                    (yyval.dtype).refqualifier = (yyvsp[(1) - (1)].dtype).refqualifier;
+               ;}
+    break;
+
+  case 563:
+#line 7125 "parser.y"
+    {
+		    (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+                    (yyval.dtype).qualifier = 0;
+                    (yyval.dtype).refqualifier = 0;
+               ;}
+    break;
+
+  case 564:
+#line 7130 "parser.y"
+    {
+		    (yyval.dtype) = (yyvsp[(2) - (2)].dtype);
+                    (yyval.dtype).qualifier = (yyvsp[(1) - (2)].dtype).qualifier;
+                    (yyval.dtype).refqualifier = (yyvsp[(1) - (2)].dtype).refqualifier;
+               ;}
+    break;
+
+  case 565:
+#line 7137 "parser.y"
+    {
+                    (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+               ;}
+    break;
+
+  case 566:
+#line 7140 "parser.y"
+    { 
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = 0;
+                    (yyval.dtype).final = 0;
+                    (yyval.dtype).qualifier = 0;
+                    (yyval.dtype).refqualifier = 0;
+               ;}
+    break;
+
+  case 567:
+#line 7150 "parser.y"
+    { 
+                    Clear(scanner_ccode); 
+                    (yyval.decl).have_parms = 0; 
+                    (yyval.decl).defarg = 0; 
+		    (yyval.decl).throws = (yyvsp[(1) - (3)].dtype).throws;
+		    (yyval.decl).throwf = (yyvsp[(1) - (3)].dtype).throwf;
+		    (yyval.decl).nexcept = (yyvsp[(1) - (3)].dtype).nexcept;
+		    (yyval.decl).final = (yyvsp[(1) - (3)].dtype).final;
+                    if ((yyvsp[(1) - (3)].dtype).qualifier)
+                      Swig_error(cparse_file, cparse_line, "Constructor cannot have a qualifier.\n");
+               ;}
+    break;
+
+  case 568:
+#line 7161 "parser.y"
+    { 
+                    skip_balanced('{','}'); 
+                    (yyval.decl).have_parms = 0; 
+                    (yyval.decl).defarg = 0; 
+                    (yyval.decl).throws = (yyvsp[(1) - (3)].dtype).throws;
+                    (yyval.decl).throwf = (yyvsp[(1) - (3)].dtype).throwf;
+                    (yyval.decl).nexcept = (yyvsp[(1) - (3)].dtype).nexcept;
+                    (yyval.decl).final = (yyvsp[(1) - (3)].dtype).final;
+                    if ((yyvsp[(1) - (3)].dtype).qualifier)
+                      Swig_error(cparse_file, cparse_line, "Constructor cannot have a qualifier.\n");
+               ;}
+    break;
+
+  case 569:
+#line 7172 "parser.y"
+    { 
+                    Clear(scanner_ccode); 
+                    (yyval.decl).parms = (yyvsp[(2) - (4)].pl); 
+                    (yyval.decl).have_parms = 1; 
+                    (yyval.decl).defarg = 0; 
+		    (yyval.decl).throws = 0;
+		    (yyval.decl).throwf = 0;
+		    (yyval.decl).nexcept = 0;
+		    (yyval.decl).final = 0;
+               ;}
+    break;
+
+  case 570:
+#line 7182 "parser.y"
+    {
+                    skip_balanced('{','}'); 
+                    (yyval.decl).parms = (yyvsp[(2) - (4)].pl); 
+                    (yyval.decl).have_parms = 1; 
+                    (yyval.decl).defarg = 0; 
+                    (yyval.decl).throws = 0;
+                    (yyval.decl).throwf = 0;
+                    (yyval.decl).nexcept = 0;
+                    (yyval.decl).final = 0;
+               ;}
+    break;
+
+  case 571:
+#line 7192 "parser.y"
+    { 
+                    (yyval.decl).have_parms = 0; 
+                    (yyval.decl).defarg = (yyvsp[(2) - (3)].dtype).val; 
+                    (yyval.decl).throws = 0;
+                    (yyval.decl).throwf = 0;
+                    (yyval.decl).nexcept = 0;
+                    (yyval.decl).final = 0;
+               ;}
+    break;
+
+  case 572:
+#line 7200 "parser.y"
+    {
+                    (yyval.decl).have_parms = 0;
+                    (yyval.decl).defarg = (yyvsp[(3) - (4)].dtype).val;
+                    (yyval.decl).throws = (yyvsp[(1) - (4)].dtype).throws;
+                    (yyval.decl).throwf = (yyvsp[(1) - (4)].dtype).throwf;
+                    (yyval.decl).nexcept = (yyvsp[(1) - (4)].dtype).nexcept;
+                    (yyval.decl).final = (yyvsp[(1) - (4)].dtype).final;
+                    if ((yyvsp[(1) - (4)].dtype).qualifier)
+                      Swig_error(cparse_file, cparse_line, "Constructor cannot have a qualifier.\n");
+               ;}
+    break;
+
+  case 579:
+#line 7222 "parser.y"
+    {
+		  skip_balanced('(',')');
+		  Clear(scanner_ccode);
+		;}
+    break;
+
+  case 580:
+#line 7234 "parser.y"
+    {
+		  skip_balanced('{','}');
+		  Clear(scanner_ccode);
+		;}
+    break;
+
+  case 581:
+#line 7240 "parser.y"
+    {
+                     String *s = NewStringEmpty();
+                     SwigType_add_template(s,(yyvsp[(2) - (3)].p));
+                     (yyval.id) = Char(s);
+		     scanner_last_id(1);
+                ;}
+    break;
+
+  case 582:
+#line 7249 "parser.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); ;}
+    break;
+
+  case 583:
+#line 7250 "parser.y"
+    { (yyval.id) = Swig_copy_string("override"); ;}
+    break;
+
+  case 584:
+#line 7251 "parser.y"
+    { (yyval.id) = Swig_copy_string("final"); ;}
+    break;
+
+  case 585:
+#line 7254 "parser.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); ;}
+    break;
+
+  case 586:
+#line 7255 "parser.y"
+    { (yyval.id) = Char((yyvsp[(1) - (1)].dtype).val); ;}
+    break;
+
+  case 587:
+#line 7256 "parser.y"
+    { (yyval.id) = Char((yyvsp[(1) - (1)].str)); ;}
+    break;
+
+  case 588:
+#line 7259 "parser.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); ;}
+    break;
+
+  case 589:
+#line 7260 "parser.y"
+    { (yyval.id) = 0; ;}
+    break;
+
+  case 590:
+#line 7263 "parser.y"
+    { 
+                  (yyval.str) = 0;
+		  if (!(yyval.str)) (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].str),(yyvsp[(2) - (2)].str));
+      	          Delete((yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 591:
+#line 7268 "parser.y"
+    {
+		 (yyval.str) = NewStringf("::%s%s",(yyvsp[(3) - (4)].str),(yyvsp[(4) - (4)].str));
+                 Delete((yyvsp[(4) - (4)].str));
+               ;}
+    break;
+
+  case 592:
+#line 7272 "parser.y"
+    {
+		 (yyval.str) = NewString((yyvsp[(1) - (1)].str));
+   	       ;}
+    break;
+
+  case 593:
+#line 7275 "parser.y"
+    {
+		 (yyval.str) = NewStringf("::%s",(yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 594:
+#line 7278 "parser.y"
+    {
+                 (yyval.str) = NewStringf("%s", (yyvsp[(1) - (1)].str));
+	       ;}
+    break;
+
+  case 595:
+#line 7281 "parser.y"
+    {
+                 (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].str), (yyvsp[(2) - (2)].id));
+	       ;}
+    break;
+
+  case 596:
+#line 7284 "parser.y"
+    {
+                 (yyval.str) = NewStringf("::%s",(yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 597:
+#line 7289 "parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s%s",(yyvsp[(2) - (3)].str),(yyvsp[(3) - (3)].str));
+		   Delete((yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 598:
+#line 7293 "parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s",(yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 599:
+#line 7296 "parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s",(yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 600:
+#line 7303 "parser.y"
+    {
+		 (yyval.str) = NewStringf("::~%s",(yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 601:
+#line 7309 "parser.y"
+    {
+		(yyval.str) = NewStringf("%s", (yyvsp[(1) - (1)].id));
+	      ;}
+    break;
+
+  case 602:
+#line 7312 "parser.y"
+    {
+		(yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].id), (yyvsp[(2) - (2)].id));
+	      ;}
+    break;
+
+  case 603:
+#line 7317 "parser.y"
+    {
+		(yyval.str) = (yyvsp[(1) - (1)].str);
+	      ;}
+    break;
+
+  case 604:
+#line 7320 "parser.y"
+    {
+		(yyval.str) = NewStringf("%s%s", (yyvsp[(2) - (3)].id), (yyvsp[(3) - (3)].id));
+	      ;}
+    break;
+
+  case 605:
+#line 7326 "parser.y"
+    {
+                  (yyval.str) = 0;
+		  if (!(yyval.str)) (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].id),(yyvsp[(2) - (2)].str));
+      	          Delete((yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 606:
+#line 7331 "parser.y"
+    {
+		 (yyval.str) = NewStringf("::%s%s",(yyvsp[(3) - (4)].id),(yyvsp[(4) - (4)].str));
+                 Delete((yyvsp[(4) - (4)].str));
+               ;}
+    break;
+
+  case 607:
+#line 7335 "parser.y"
+    {
+		 (yyval.str) = NewString((yyvsp[(1) - (1)].id));
+   	       ;}
+    break;
+
+  case 608:
+#line 7338 "parser.y"
+    {
+		 (yyval.str) = NewStringf("::%s",(yyvsp[(3) - (3)].id));
+               ;}
+    break;
+
+  case 609:
+#line 7341 "parser.y"
+    {
+                 (yyval.str) = NewString((yyvsp[(1) - (1)].str));
+	       ;}
+    break;
+
+  case 610:
+#line 7344 "parser.y"
+    {
+                 (yyval.str) = NewStringf("::%s",(yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 611:
+#line 7349 "parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s%s",(yyvsp[(2) - (3)].id),(yyvsp[(3) - (3)].str));
+		   Delete((yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 612:
+#line 7353 "parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s",(yyvsp[(2) - (2)].id));
+               ;}
+    break;
+
+  case 613:
+#line 7356 "parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s",(yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 614:
+#line 7359 "parser.y"
+    {
+		 (yyval.str) = NewStringf("::~%s",(yyvsp[(2) - (2)].id));
+               ;}
+    break;
+
+  case 615:
+#line 7365 "parser.y"
+    { 
+                   (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].str), (yyvsp[(2) - (2)].id));
+               ;}
+    break;
+
+  case 616:
+#line 7368 "parser.y"
+    { (yyval.str) = NewString((yyvsp[(1) - (1)].id));;}
+    break;
+
+  case 617:
+#line 7371 "parser.y"
+    {
+                   (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].str), (yyvsp[(2) - (2)].id));
+               ;}
+    break;
+
+  case 618:
+#line 7379 "parser.y"
+    { (yyval.str) = NewString((yyvsp[(1) - (1)].id));;}
+    break;
+
+  case 619:
+#line 7382 "parser.y"
+    {
+		 (yyval.str) = (yyvsp[(1) - (1)].str);
+               ;}
+    break;
+
+  case 620:
+#line 7385 "parser.y"
+    {
+                  skip_balanced('{','}');
+		  (yyval.str) = NewString(scanner_ccode);
+               ;}
+    break;
+
+  case 621:
+#line 7389 "parser.y"
+    {
+		 (yyval.str) = (yyvsp[(1) - (1)].str);
+              ;}
+    break;
+
+  case 622:
+#line 7394 "parser.y"
+    {
+                  Hash *n;
+                  (yyval.node) = NewHash();
+                  n = (yyvsp[(2) - (3)].node);
+                  while(n) {
+                     String *name, *value;
+                     name = Getattr(n,"name");
+                     value = Getattr(n,"value");
+		     if (!value) value = (String *) "1";
+                     Setattr((yyval.node),name, value);
+		     n = nextSibling(n);
+		  }
+               ;}
+    break;
+
+  case 623:
+#line 7407 "parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 624:
+#line 7411 "parser.y"
+    {
+		 (yyval.node) = NewHash();
+		 Setattr((yyval.node),"name",(yyvsp[(1) - (3)].id));
+		 Setattr((yyval.node),"value",(yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 625:
+#line 7416 "parser.y"
+    {
+		 (yyval.node) = NewHash();
+		 Setattr((yyval.node),"name",(yyvsp[(1) - (5)].id));
+		 Setattr((yyval.node),"value",(yyvsp[(3) - (5)].str));
+		 set_nextSibling((yyval.node),(yyvsp[(5) - (5)].node));
+               ;}
+    break;
+
+  case 626:
+#line 7422 "parser.y"
+    {
+                 (yyval.node) = NewHash();
+                 Setattr((yyval.node),"name",(yyvsp[(1) - (1)].id));
+	       ;}
+    break;
+
+  case 627:
+#line 7426 "parser.y"
+    {
+                 (yyval.node) = NewHash();
+                 Setattr((yyval.node),"name",(yyvsp[(1) - (3)].id));
+                 set_nextSibling((yyval.node),(yyvsp[(3) - (3)].node));
+               ;}
+    break;
+
+  case 628:
+#line 7431 "parser.y"
+    {
+                 (yyval.node) = (yyvsp[(3) - (3)].node);
+		 Setattr((yyval.node),"name",(yyvsp[(1) - (3)].id));
+               ;}
+    break;
+
+  case 629:
+#line 7435 "parser.y"
+    {
+                 (yyval.node) = (yyvsp[(3) - (5)].node);
+		 Setattr((yyval.node),"name",(yyvsp[(1) - (5)].id));
+		 set_nextSibling((yyval.node),(yyvsp[(5) - (5)].node));
+               ;}
+    break;
+
+  case 630:
+#line 7442 "parser.y"
+    {
+		 (yyval.str) = (yyvsp[(1) - (1)].str);
+               ;}
+    break;
+
+  case 631:
+#line 7445 "parser.y"
+    {
+                 (yyval.str) = Char((yyvsp[(1) - (1)].dtype).val);
+               ;}
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+#line 12845 "parser.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+#line 7452 "parser.y"
+
+
+SwigType *Swig_cparse_type(String *s) {
+   String *ns;
+   ns = NewStringf("%s;",s);
+   Seek(ns,0,SEEK_SET);
+   scanner_file(ns);
+   top = 0;
+   scanner_next_token(PARSETYPE);
+   yyparse();
+   /*   Printf(stdout,"typeparse: '%s' ---> '%s'\n", s, top); */
+   return top;
+}
+
+
+Parm *Swig_cparse_parm(String *s) {
+   String *ns;
+   ns = NewStringf("%s;",s);
+   Seek(ns,0,SEEK_SET);
+   scanner_file(ns);
+   top = 0;
+   scanner_next_token(PARSEPARM);
+   yyparse();
+   /*   Printf(stdout,"typeparse: '%s' ---> '%s'\n", s, top); */
+   Delete(ns);
+   return top;
+}
+
+
+ParmList *Swig_cparse_parms(String *s, Node *file_line_node) {
+   String *ns;
+   char *cs = Char(s);
+   if (cs && cs[0] != '(') {
+     ns = NewStringf("(%s);",s);
+   } else {
+     ns = NewStringf("%s;",s);
+   }
+   Setfile(ns, Getfile(file_line_node));
+   Setline(ns, Getline(file_line_node));
+   Seek(ns,0,SEEK_SET);
+   scanner_file(ns);
+   top = 0;
+   scanner_next_token(PARSEPARMS);
+   yyparse();
+   /*   Printf(stdout,"typeparse: '%s' ---> '%s'\n", s, top); */
+   return top;
+}
+
+
diff --git a/Source/CParse/parser.h b/Source/CParse/parser.h
new file mode 100644
index 000000000..6e1da8516
--- /dev/null
+++ b/Source/CParse/parser.h
@@ -0,0 +1,394 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     END = 0,
+     ID = 258,
+     HBLOCK = 259,
+     POUND = 260,
+     STRING = 261,
+     WSTRING = 262,
+     INCLUDE = 263,
+     IMPORT = 264,
+     INSERT = 265,
+     CHARCONST = 266,
+     WCHARCONST = 267,
+     NUM_INT = 268,
+     NUM_FLOAT = 269,
+     NUM_UNSIGNED = 270,
+     NUM_LONG = 271,
+     NUM_ULONG = 272,
+     NUM_LONGLONG = 273,
+     NUM_ULONGLONG = 274,
+     NUM_BOOL = 275,
+     TYPEDEF = 276,
+     TYPE_INT = 277,
+     TYPE_UNSIGNED = 278,
+     TYPE_SHORT = 279,
+     TYPE_LONG = 280,
+     TYPE_FLOAT = 281,
+     TYPE_DOUBLE = 282,
+     TYPE_CHAR = 283,
+     TYPE_WCHAR = 284,
+     TYPE_VOID = 285,
+     TYPE_SIGNED = 286,
+     TYPE_BOOL = 287,
+     TYPE_COMPLEX = 288,
+     TYPE_TYPEDEF = 289,
+     TYPE_RAW = 290,
+     TYPE_NON_ISO_INT8 = 291,
+     TYPE_NON_ISO_INT16 = 292,
+     TYPE_NON_ISO_INT32 = 293,
+     TYPE_NON_ISO_INT64 = 294,
+     LPAREN = 295,
+     RPAREN = 296,
+     COMMA = 297,
+     SEMI = 298,
+     EXTERN = 299,
+     INIT = 300,
+     LBRACE = 301,
+     RBRACE = 302,
+     PERIOD = 303,
+     ELLIPSIS = 304,
+     CONST_QUAL = 305,
+     VOLATILE = 306,
+     REGISTER = 307,
+     STRUCT = 308,
+     UNION = 309,
+     EQUAL = 310,
+     SIZEOF = 311,
+     MODULE = 312,
+     LBRACKET = 313,
+     RBRACKET = 314,
+     BEGINFILE = 315,
+     ENDOFFILE = 316,
+     ILLEGAL = 317,
+     CONSTANT = 318,
+     NAME = 319,
+     RENAME = 320,
+     NAMEWARN = 321,
+     EXTEND = 322,
+     PRAGMA = 323,
+     FEATURE = 324,
+     VARARGS = 325,
+     ENUM = 326,
+     CLASS = 327,
+     TYPENAME = 328,
+     PRIVATE = 329,
+     PUBLIC = 330,
+     PROTECTED = 331,
+     COLON = 332,
+     STATIC = 333,
+     VIRTUAL = 334,
+     FRIEND = 335,
+     THROW = 336,
+     CATCH = 337,
+     EXPLICIT = 338,
+     STATIC_ASSERT = 339,
+     CONSTEXPR = 340,
+     THREAD_LOCAL = 341,
+     DECLTYPE = 342,
+     AUTO = 343,
+     NOEXCEPT = 344,
+     OVERRIDE = 345,
+     FINAL = 346,
+     USING = 347,
+     NAMESPACE = 348,
+     NATIVE = 349,
+     INLINE = 350,
+     TYPEMAP = 351,
+     EXCEPT = 352,
+     ECHO = 353,
+     APPLY = 354,
+     CLEAR = 355,
+     SWIGTEMPLATE = 356,
+     FRAGMENT = 357,
+     WARN = 358,
+     LESSTHAN = 359,
+     GREATERTHAN = 360,
+     DELETE_KW = 361,
+     DEFAULT = 362,
+     LESSTHANOREQUALTO = 363,
+     GREATERTHANOREQUALTO = 364,
+     EQUALTO = 365,
+     NOTEQUALTO = 366,
+     LESSEQUALGREATER = 367,
+     ARROW = 368,
+     QUESTIONMARK = 369,
+     TYPES = 370,
+     PARMS = 371,
+     NONID = 372,
+     DSTAR = 373,
+     DCNOT = 374,
+     TEMPLATE = 375,
+     OPERATOR = 376,
+     CONVERSIONOPERATOR = 377,
+     PARSETYPE = 378,
+     PARSEPARM = 379,
+     PARSEPARMS = 380,
+     DOXYGENSTRING = 381,
+     DOXYGENPOSTSTRING = 382,
+     CAST = 383,
+     LOR = 384,
+     LAND = 385,
+     OR = 386,
+     XOR = 387,
+     AND = 388,
+     RSHIFT = 389,
+     LSHIFT = 390,
+     MINUS = 391,
+     PLUS = 392,
+     MODULO = 393,
+     SLASH = 394,
+     STAR = 395,
+     LNOT = 396,
+     NOT = 397,
+     UMINUS = 398,
+     DCOLON = 399
+   };
+#endif
+/* Tokens.  */
+#define END 0
+#define ID 258
+#define HBLOCK 259
+#define POUND 260
+#define STRING 261
+#define WSTRING 262
+#define INCLUDE 263
+#define IMPORT 264
+#define INSERT 265
+#define CHARCONST 266
+#define WCHARCONST 267
+#define NUM_INT 268
+#define NUM_FLOAT 269
+#define NUM_UNSIGNED 270
+#define NUM_LONG 271
+#define NUM_ULONG 272
+#define NUM_LONGLONG 273
+#define NUM_ULONGLONG 274
+#define NUM_BOOL 275
+#define TYPEDEF 276
+#define TYPE_INT 277
+#define TYPE_UNSIGNED 278
+#define TYPE_SHORT 279
+#define TYPE_LONG 280
+#define TYPE_FLOAT 281
+#define TYPE_DOUBLE 282
+#define TYPE_CHAR 283
+#define TYPE_WCHAR 284
+#define TYPE_VOID 285
+#define TYPE_SIGNED 286
+#define TYPE_BOOL 287
+#define TYPE_COMPLEX 288
+#define TYPE_TYPEDEF 289
+#define TYPE_RAW 290
+#define TYPE_NON_ISO_INT8 291
+#define TYPE_NON_ISO_INT16 292
+#define TYPE_NON_ISO_INT32 293
+#define TYPE_NON_ISO_INT64 294
+#define LPAREN 295
+#define RPAREN 296
+#define COMMA 297
+#define SEMI 298
+#define EXTERN 299
+#define INIT 300
+#define LBRACE 301
+#define RBRACE 302
+#define PERIOD 303
+#define ELLIPSIS 304
+#define CONST_QUAL 305
+#define VOLATILE 306
+#define REGISTER 307
+#define STRUCT 308
+#define UNION 309
+#define EQUAL 310
+#define SIZEOF 311
+#define MODULE 312
+#define LBRACKET 313
+#define RBRACKET 314
+#define BEGINFILE 315
+#define ENDOFFILE 316
+#define ILLEGAL 317
+#define CONSTANT 318
+#define NAME 319
+#define RENAME 320
+#define NAMEWARN 321
+#define EXTEND 322
+#define PRAGMA 323
+#define FEATURE 324
+#define VARARGS 325
+#define ENUM 326
+#define CLASS 327
+#define TYPENAME 328
+#define PRIVATE 329
+#define PUBLIC 330
+#define PROTECTED 331
+#define COLON 332
+#define STATIC 333
+#define VIRTUAL 334
+#define FRIEND 335
+#define THROW 336
+#define CATCH 337
+#define EXPLICIT 338
+#define STATIC_ASSERT 339
+#define CONSTEXPR 340
+#define THREAD_LOCAL 341
+#define DECLTYPE 342
+#define AUTO 343
+#define NOEXCEPT 344
+#define OVERRIDE 345
+#define FINAL 346
+#define USING 347
+#define NAMESPACE 348
+#define NATIVE 349
+#define INLINE 350
+#define TYPEMAP 351
+#define EXCEPT 352
+#define ECHO 353
+#define APPLY 354
+#define CLEAR 355
+#define SWIGTEMPLATE 356
+#define FRAGMENT 357
+#define WARN 358
+#define LESSTHAN 359
+#define GREATERTHAN 360
+#define DELETE_KW 361
+#define DEFAULT 362
+#define LESSTHANOREQUALTO 363
+#define GREATERTHANOREQUALTO 364
+#define EQUALTO 365
+#define NOTEQUALTO 366
+#define LESSEQUALGREATER 367
+#define ARROW 368
+#define QUESTIONMARK 369
+#define TYPES 370
+#define PARMS 371
+#define NONID 372
+#define DSTAR 373
+#define DCNOT 374
+#define TEMPLATE 375
+#define OPERATOR 376
+#define CONVERSIONOPERATOR 377
+#define PARSETYPE 378
+#define PARSEPARM 379
+#define PARSEPARMS 380
+#define DOXYGENSTRING 381
+#define DOXYGENPOSTSTRING 382
+#define CAST 383
+#define LOR 384
+#define LAND 385
+#define OR 386
+#define XOR 387
+#define AND 388
+#define RSHIFT 389
+#define LSHIFT 390
+#define MINUS 391
+#define PLUS 392
+#define MODULO 393
+#define SLASH 394
+#define STAR 395
+#define LNOT 396
+#define NOT 397
+#define UMINUS 398
+#define DCOLON 399
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 1554 "parser.y"
+{
+  const char  *id;
+  List  *bases;
+  struct Define {
+    String *val;
+    String *rawval;
+    int     type;
+    String *qualifier;
+    String *refqualifier;
+    String *bitfield;
+    Parm   *throws;
+    String *throwf;
+    String *nexcept;
+    String *final;
+  } dtype;
+  struct {
+    const char *type;
+    String *filename;
+    int   line;
+  } loc;
+  struct {
+    char      *id;
+    SwigType  *type;
+    String    *defarg;
+    ParmList  *parms;
+    short      have_parms;
+    ParmList  *throws;
+    String    *throwf;
+    String    *nexcept;
+    String    *final;
+  } decl;
+  Parm         *tparms;
+  struct {
+    String     *method;
+    Hash       *kwargs;
+  } tmap;
+  struct {
+    String     *type;
+    String     *us;
+  } ptype;
+  SwigType     *type;
+  String       *str;
+  Parm         *p;
+  ParmList     *pl;
+  int           intvalue;
+  Node         *node;
+}
+/* Line 1529 of yacc.c.  */
+#line 387 "parser.h"
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
diff --git a/Lib/swigwarn.swg b/Lib/swigwarn.swg
new file mode 100644
index 000000000..6a069220e
--- /dev/null
+++ b/Lib/swigwarn.swg
@@ -0,0 +1,300 @@
+/* SWIG warning codes - generated from swigwarn.h - do not edit */
+
+
+%define SWIGWARN_NONE                     0 %enddef
+
+/* -- Deprecated features -- */
+
+%define SWIGWARN_DEPRECATED_EXTERN        101 %enddef
+%define SWIGWARN_DEPRECATED_VAL           102 %enddef
+%define SWIGWARN_DEPRECATED_OUT           103 %enddef
+%define SWIGWARN_DEPRECATED_DISABLEDOC    104 %enddef
+%define SWIGWARN_DEPRECATED_ENABLEDOC     105 %enddef
+%define SWIGWARN_DEPRECATED_DOCONLY       106 %enddef
+%define SWIGWARN_DEPRECATED_STYLE         107 %enddef
+%define SWIGWARN_DEPRECATED_LOCALSTYLE    108 %enddef
+%define SWIGWARN_DEPRECATED_TITLE         109 %enddef
+%define SWIGWARN_DEPRECATED_SECTION       110 %enddef
+%define SWIGWARN_DEPRECATED_SUBSECTION    111 %enddef
+%define SWIGWARN_DEPRECATED_SUBSUBSECTION 112 %enddef
+%define SWIGWARN_DEPRECATED_ADDMETHODS    113 %enddef
+%define SWIGWARN_DEPRECATED_READONLY      114 %enddef
+%define SWIGWARN_DEPRECATED_READWRITE     115 %enddef
+%define SWIGWARN_DEPRECATED_EXCEPT        116 %enddef
+%define SWIGWARN_DEPRECATED_NEW           117 %enddef
+%define SWIGWARN_DEPRECATED_EXCEPT_TM     118 %enddef
+%define SWIGWARN_DEPRECATED_IGNORE_TM     119 %enddef
+%define SWIGWARN_DEPRECATED_OPTC          120 %enddef
+%define SWIGWARN_DEPRECATED_NAME          121 %enddef
+%define SWIGWARN_DEPRECATED_NOEXTERN      122 %enddef
+%define SWIGWARN_DEPRECATED_NODEFAULT     123 %enddef
+/* Unused since 4.1.0: #define WARN_DEPRECATED_TYPEMAP_LANG  124 */
+%define SWIGWARN_DEPRECATED_INPUT_FILE    125 %enddef
+%define SWIGWARN_DEPRECATED_NESTED_WORKAROUND 126 %enddef
+
+/* -- Preprocessor -- */
+
+%define SWIGWARN_PP_MISSING_FILE          201 %enddef
+%define SWIGWARN_PP_EVALUATION            202 %enddef
+%define SWIGWARN_PP_INCLUDEALL_IMPORTALL  203 %enddef
+%define SWIGWARN_PP_CPP_WARNING           204 %enddef
+%define SWIGWARN_PP_CPP_ERROR             205 %enddef
+%define SWIGWARN_PP_UNEXPECTED_TOKENS     206 %enddef
+
+/* -- C/C++ Parser -- */
+
+%define SWIGWARN_PARSE_CLASS_KEYWORD      301 %enddef
+%define SWIGWARN_PARSE_REDEFINED          302 %enddef
+%define SWIGWARN_PARSE_EXTEND_UNDEF       303 %enddef
+%define SWIGWARN_PARSE_UNSUPPORTED_VALUE  304 %enddef
+%define SWIGWARN_PARSE_BAD_VALUE          305 %enddef
+%define SWIGWARN_PARSE_PRIVATE            306 %enddef
+%define SWIGWARN_PARSE_BAD_DEFAULT        307 %enddef
+%define SWIGWARN_PARSE_NAMESPACE_ALIAS    308 %enddef
+%define SWIGWARN_PARSE_PRIVATE_INHERIT    309 %enddef
+%define SWIGWARN_PARSE_TEMPLATE_REPEAT    310 %enddef
+%define SWIGWARN_PARSE_TEMPLATE_PARTIAL   311 %enddef
+%define SWIGWARN_PARSE_UNNAMED_NESTED_CLASS 312 %enddef
+%define SWIGWARN_PARSE_UNDEFINED_EXTERN   313 %enddef
+%define SWIGWARN_PARSE_KEYWORD            314 %enddef
+%define SWIGWARN_PARSE_USING_UNDEF        315 %enddef
+%define SWIGWARN_PARSE_MODULE_REPEAT      316 %enddef
+%define SWIGWARN_PARSE_TEMPLATE_SP_UNDEF  317 %enddef
+%define SWIGWARN_PARSE_TEMPLATE_AMBIG     318 %enddef
+%define SWIGWARN_PARSE_NO_ACCESS          319 %enddef
+%define SWIGWARN_PARSE_EXPLICIT_TEMPLATE  320 %enddef
+%define SWIGWARN_PARSE_BUILTIN_NAME       321 %enddef
+%define SWIGWARN_PARSE_REDUNDANT          322 %enddef
+%define SWIGWARN_PARSE_REC_INHERITANCE    323 %enddef
+%define SWIGWARN_PARSE_NESTED_TEMPLATE    324 %enddef
+%define SWIGWARN_PARSE_NAMED_NESTED_CLASS 325 %enddef
+%define SWIGWARN_PARSE_EXTEND_NAME        326 %enddef
+%define SWIGWARN_PARSE_EXTERN_TEMPLATE    327 %enddef
+
+%define SWIGWARN_CPP11_LAMBDA             340 %enddef
+%define SWIGWARN_CPP11_ALIAS_DECLARATION  341 %enddef  /* redundant now */
+%define SWIGWARN_CPP11_ALIAS_TEMPLATE     342 %enddef  /* redundant now */
+%define SWIGWARN_CPP11_VARIADIC_TEMPLATE  343 %enddef
+
+%define SWIGWARN_IGNORE_OPERATOR_NEW        350 %enddef	/* new */
+%define SWIGWARN_IGNORE_OPERATOR_DELETE     351 %enddef	/* delete */
+%define SWIGWARN_IGNORE_OPERATOR_PLUS       352 %enddef	/* + */
+%define SWIGWARN_IGNORE_OPERATOR_MINUS      353 %enddef	/* - */
+%define SWIGWARN_IGNORE_OPERATOR_MUL        354 %enddef	/* * */
+%define SWIGWARN_IGNORE_OPERATOR_DIV        355 %enddef	/* / */
+%define SWIGWARN_IGNORE_OPERATOR_MOD        356 %enddef	/* % */
+%define SWIGWARN_IGNORE_OPERATOR_XOR        357 %enddef	/* ^ */
+%define SWIGWARN_IGNORE_OPERATOR_AND        358 %enddef	/* & */
+%define SWIGWARN_IGNORE_OPERATOR_OR         359 %enddef	/* | */
+%define SWIGWARN_IGNORE_OPERATOR_NOT        360 %enddef	/* ~ */
+%define SWIGWARN_IGNORE_OPERATOR_LNOT       361 %enddef	/* ! */
+%define SWIGWARN_IGNORE_OPERATOR_EQ         362 %enddef	/* = */
+%define SWIGWARN_IGNORE_OPERATOR_LT         363 %enddef	/* < */
+%define SWIGWARN_IGNORE_OPERATOR_GT         364 %enddef	/* > */
+%define SWIGWARN_IGNORE_OPERATOR_PLUSEQ     365 %enddef	/* += */
+%define SWIGWARN_IGNORE_OPERATOR_MINUSEQ    366 %enddef	/* -= */
+%define SWIGWARN_IGNORE_OPERATOR_MULEQ      367 %enddef	/* *= */
+%define SWIGWARN_IGNORE_OPERATOR_DIVEQ      368 %enddef	/* /= */
+%define SWIGWARN_IGNORE_OPERATOR_MODEQ      369 %enddef	/* %= */
+%define SWIGWARN_IGNORE_OPERATOR_XOREQ      370 %enddef	/* ^= */
+%define SWIGWARN_IGNORE_OPERATOR_ANDEQ      371 %enddef	/* &= */
+%define SWIGWARN_IGNORE_OPERATOR_OREQ       372 %enddef	/* |= */
+%define SWIGWARN_IGNORE_OPERATOR_LSHIFT     373 %enddef	/* << */
+%define SWIGWARN_IGNORE_OPERATOR_RSHIFT     374 %enddef	/* >> */
+%define SWIGWARN_IGNORE_OPERATOR_LSHIFTEQ   375 %enddef	/* <<= */
+%define SWIGWARN_IGNORE_OPERATOR_RSHIFTEQ   376 %enddef	/* >>= */
+%define SWIGWARN_IGNORE_OPERATOR_EQUALTO    377 %enddef	/* == */
+%define SWIGWARN_IGNORE_OPERATOR_NOTEQUAL   378 %enddef	/* != */
+%define SWIGWARN_IGNORE_OPERATOR_LTEQUAL    379 %enddef	/* <= */
+%define SWIGWARN_IGNORE_OPERATOR_GTEQUAL    380 %enddef	/* >= */
+%define SWIGWARN_IGNORE_OPERATOR_LAND       381 %enddef	/* && */
+%define SWIGWARN_IGNORE_OPERATOR_LOR        382 %enddef	/* || */
+%define SWIGWARN_IGNORE_OPERATOR_PLUSPLUS   383 %enddef	/* ++ */
+%define SWIGWARN_IGNORE_OPERATOR_MINUSMINUS 384 %enddef	/* -- */
+%define SWIGWARN_IGNORE_OPERATOR_COMMA      385 %enddef	/* , */
+%define SWIGWARN_IGNORE_OPERATOR_ARROWSTAR  386 %enddef	/* ->* */
+%define SWIGWARN_IGNORE_OPERATOR_ARROW      387 %enddef	/* -> */
+%define SWIGWARN_IGNORE_OPERATOR_CALL       388 %enddef	/* () */
+%define SWIGWARN_IGNORE_OPERATOR_INDEX      389 %enddef	/* [] */
+%define SWIGWARN_IGNORE_OPERATOR_UPLUS      390 %enddef	/* + */
+%define SWIGWARN_IGNORE_OPERATOR_UMINUS     391 %enddef	/* - */
+%define SWIGWARN_IGNORE_OPERATOR_UMUL       392 %enddef	/* * */
+%define SWIGWARN_IGNORE_OPERATOR_UAND       393 %enddef	/* & */
+%define SWIGWARN_IGNORE_OPERATOR_NEWARR     394 %enddef	/* new [] */
+%define SWIGWARN_IGNORE_OPERATOR_DELARR     395 %enddef	/* delete [] */
+%define SWIGWARN_IGNORE_OPERATOR_REF        396 %enddef	/* operator *() */
+%define SWIGWARN_IGNORE_OPERATOR_LTEQUALGT  397 %enddef	/* <=> */
+
+/* please leave 350-399 free for WARN_IGNORE_OPERATOR_* */
+
+/* -- Type system and typemaps -- */
+
+%define SWIGWARN_TYPE_UNDEFINED_CLASS     401 %enddef
+%define SWIGWARN_TYPE_INCOMPLETE          402 %enddef
+%define SWIGWARN_TYPE_ABSTRACT            403 %enddef
+%define SWIGWARN_TYPE_REDEFINED           404 %enddef
+%define SWIGWARN_TYPE_RVALUE_REF_QUALIFIER_IGNORED 405 %enddef
+
+%define SWIGWARN_TYPEMAP_SOURCETARGET     450 %enddef /* No longer issued */
+%define SWIGWARN_TYPEMAP_CHARLEAK         451 %enddef
+%define SWIGWARN_TYPEMAP_SWIGTYPE         452 %enddef /* No longer issued */
+%define SWIGWARN_TYPEMAP_APPLY_UNDEF      453 %enddef
+%define SWIGWARN_TYPEMAP_SWIGTYPELEAK     454 %enddef
+%define SWIGWARN_TYPEMAP_WCHARLEAK        455 %enddef
+
+%define SWIGWARN_TYPEMAP_IN_UNDEF         460 %enddef
+%define SWIGWARN_TYPEMAP_OUT_UNDEF        461 %enddef
+%define SWIGWARN_TYPEMAP_VARIN_UNDEF      462 %enddef
+%define SWIGWARN_TYPEMAP_VAROUT_UNDEF     463 %enddef
+%define SWIGWARN_TYPEMAP_CONST_UNDEF      464 %enddef
+%define SWIGWARN_TYPEMAP_UNDEF            465 %enddef
+%define SWIGWARN_TYPEMAP_VAR_UNDEF        466 %enddef
+%define SWIGWARN_TYPEMAP_TYPECHECK        467 %enddef
+%define SWIGWARN_TYPEMAP_THROW            468 %enddef
+%define SWIGWARN_TYPEMAP_DIRECTORIN_UNDEF  469 %enddef
+%define SWIGWARN_TYPEMAP_THREAD_UNSAFE     470 %enddef	/* mostly used in directorout typemaps */
+%define SWIGWARN_TYPEMAP_DIRECTOROUT_UNDEF 471 %enddef
+%define SWIGWARN_TYPEMAP_TYPECHECK_UNDEF   472 %enddef
+%define SWIGWARN_TYPEMAP_DIRECTOROUT_PTR   473 %enddef
+%define SWIGWARN_TYPEMAP_OUT_OPTIMAL_IGNORED  474 %enddef
+%define SWIGWARN_TYPEMAP_OUT_OPTIMAL_MULTIPLE 475 %enddef
+%define SWIGWARN_TYPEMAP_INITIALIZER_LIST  476 %enddef
+%define SWIGWARN_TYPEMAP_DIRECTORTHROWS_UNDEF 477 %enddef
+
+/* -- Fragments -- */
+%define SWIGWARN_FRAGMENT_NOT_FOUND       490 %enddef
+
+/* -- General code generation -- */
+
+%define SWIGWARN_LANG_OVERLOAD_DECL       501 %enddef
+%define SWIGWARN_LANG_OVERLOAD_CONSTRUCT  502 %enddef
+%define SWIGWARN_LANG_IDENTIFIER          503 %enddef
+%define SWIGWARN_LANG_RETURN_TYPE         504 %enddef
+%define SWIGWARN_LANG_VARARGS             505 %enddef
+%define SWIGWARN_LANG_VARARGS_KEYWORD     506 %enddef
+%define SWIGWARN_LANG_NATIVE_UNIMPL       507 %enddef
+%define SWIGWARN_LANG_DEREF_SHADOW        508 %enddef
+%define SWIGWARN_LANG_OVERLOAD_SHADOW     509 %enddef
+%define SWIGWARN_LANG_FRIEND_IGNORE       510 %enddef
+%define SWIGWARN_LANG_OVERLOAD_KEYWORD    511 %enddef
+%define SWIGWARN_LANG_OVERLOAD_CONST      512 %enddef
+%define SWIGWARN_LANG_CLASS_UNNAMED       513 %enddef
+%define SWIGWARN_LANG_DIRECTOR_VDESTRUCT  514 %enddef
+%define SWIGWARN_LANG_DISCARD_CONST       515 %enddef
+%define SWIGWARN_LANG_OVERLOAD_IGNORED    516 %enddef
+%define SWIGWARN_LANG_DIRECTOR_ABSTRACT   517 %enddef
+%define SWIGWARN_LANG_PORTABILITY_FILENAME 518 %enddef
+%define SWIGWARN_LANG_TEMPLATE_METHOD_IGNORE 519 %enddef
+%define SWIGWARN_LANG_SMARTPTR_MISSING    520 %enddef
+%define SWIGWARN_LANG_ILLEGAL_DESTRUCTOR  521 %enddef
+%define SWIGWARN_LANG_EXTEND_CONSTRUCTOR  522 %enddef
+%define SWIGWARN_LANG_EXTEND_DESTRUCTOR   523 %enddef
+%define SWIGWARN_LANG_EXPERIMENTAL        524 %enddef
+%define SWIGWARN_LANG_DIRECTOR_FINAL      525 %enddef
+%define SWIGWARN_LANG_USING_NAME_DIFFERENT 526 %enddef
+
+/* -- Doxygen comments -- */
+
+%define SWIGWARN_DOXYGEN_UNKNOWN_COMMAND          560 %enddef
+%define SWIGWARN_DOXYGEN_UNEXPECTED_END_OF_COMMENT  561 %enddef
+%define SWIGWARN_DOXYGEN_COMMAND_EXPECTED         562 %enddef
+%define SWIGWARN_DOXYGEN_HTML_ERROR               563 %enddef
+%define SWIGWARN_DOXYGEN_COMMAND_ERROR            564 %enddef
+%define SWIGWARN_DOXYGEN_UNKNOWN_CHARACTER        565 %enddef
+%define SWIGWARN_DOXYGEN_UNEXPECTED_ITERATOR_VALUE  566 %enddef
+
+/* -- Reserved (600-699) -- */
+
+/* -- Language module specific warnings (700 - 899) -- */
+
+
+%define SWIGWARN_D_TYPEMAP_CTYPE_UNDEF            700 %enddef
+%define SWIGWARN_D_TYPEMAP_IMTYPE_UNDEF           701 %enddef
+%define SWIGWARN_D_TYPEMAP_DTYPE_UNDEF            702 %enddef
+%define SWIGWARN_D_MULTIPLE_INHERITANCE           703 %enddef
+%define SWIGWARN_D_TYPEMAP_CLASSMOD_UNDEF         704 %enddef
+%define SWIGWARN_D_TYPEMAP_DBODY_UNDEF            705 %enddef
+%define SWIGWARN_D_TYPEMAP_DOUT_UNDEF             706 %enddef
+%define SWIGWARN_D_TYPEMAP_DIN_UNDEF              707 %enddef
+%define SWIGWARN_D_TYPEMAP_DDIRECTORIN_UNDEF      708 %enddef
+%define SWIGWARN_D_TYPEMAP_DCONSTRUCTOR_UNDEF     709 %enddef
+%define SWIGWARN_D_EXCODE_MISSING                 710 %enddef
+%define SWIGWARN_D_CANTHROW_MISSING               711 %enddef
+%define SWIGWARN_D_NO_DIRECTORCONNECT_ATTR        712 %enddef
+%define SWIGWARN_D_NAME_COLLISION                 713 %enddef
+
+/* please leave 700-719 free for D */
+
+%define SWIGWARN_SCILAB_TRUNCATED_NAME            720 %enddef
+
+/* please leave 720-739 free for Scilab */
+
+%define SWIGWARN_PYTHON_INDENT_MISMATCH           740 %enddef
+
+/* please leave 740-749 free for Python */
+
+%define SWIGWARN_R_MISSING_RTYPECHECK_TYPEMAP     750 %enddef
+
+/* please leave 750-759 free for R */
+
+%define SWIGWARN_RUBY_WRONG_NAME                  801 %enddef
+%define SWIGWARN_RUBY_MULTIPLE_INHERITANCE        802 %enddef
+
+/* please leave 800-809 free for Ruby */
+
+%define SWIGWARN_JAVA_TYPEMAP_JNI_UNDEF           810 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_JTYPE_UNDEF         811 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_JSTYPE_UNDEF        812 %enddef
+%define SWIGWARN_JAVA_MULTIPLE_INHERITANCE        813 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_GETCPTR_UNDEF       814 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_CLASSMOD_UNDEF      815 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_JAVABODY_UNDEF      816 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_JAVAOUT_UNDEF       817 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_JAVAIN_UNDEF        818 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_JAVADIRECTORIN_UNDEF    819 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_JAVADIRECTOROUT_UNDEF   820 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_INTERFACECODE_UNDEF 821 %enddef
+%define SWIGWARN_JAVA_COVARIANT_RET               822 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_JAVACONSTRUCT_UNDEF 823 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_DIRECTORIN_NODESC   824 %enddef
+%define SWIGWARN_JAVA_NO_DIRECTORCONNECT_ATTR     825 %enddef
+%define SWIGWARN_JAVA_NSPACE_WITHOUT_PACKAGE      826 %enddef
+%define SWIGWARN_JAVA_TYPEMAP_INTERFACEMODIFIERS_UNDEF 827 %enddef
+
+/* please leave 810-829 free for Java */
+
+%define SWIGWARN_CSHARP_TYPEMAP_CTYPE_UNDEF       830 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_CSTYPE_UNDEF      831 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_CSWTYPE_UNDEF     832 %enddef
+%define SWIGWARN_CSHARP_MULTIPLE_INHERITANCE      833 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_GETCPTR_UNDEF     834 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_CLASSMOD_UNDEF    835 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_CSBODY_UNDEF      836 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_CSOUT_UNDEF       837 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_CSIN_UNDEF        838 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_CSDIRECTORIN_UNDEF    839 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_CSDIRECTOROUT_UNDEF   840 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_INTERFACECODE_UNDEF   841 %enddef
+%define SWIGWARN_CSHARP_COVARIANT_RET             842 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_CSCONSTRUCT_UNDEF 843 %enddef
+%define SWIGWARN_CSHARP_EXCODE                    844 %enddef
+%define SWIGWARN_CSHARP_CANTHROW                  845 %enddef
+%define SWIGWARN_CSHARP_NO_DIRECTORCONNECT_ATTR   846 %enddef
+%define SWIGWARN_CSHARP_TYPEMAP_INTERFACEMODIFIERS_UNDEF 847 %enddef
+
+/* please leave 830-849 free for C# */
+
+/* 850-860 were used by Modula 3 (removed in SWIG 4.1.0) - avoid reusing for now */
+
+%define SWIGWARN_PHP_MULTIPLE_INHERITANCE         870 %enddef
+%define SWIGWARN_PHP_UNKNOWN_PRAGMA               871 %enddef
+%define SWIGWARN_PHP_PUBLIC_BASE                  872 %enddef
+
+/* please leave 870-889 free for PHP */
+
+%define SWIGWARN_GO_NAME_CONFLICT                 890 %enddef
+
+/* please leave 890-899 free for Go */
+
+/* -- User defined warnings (900 - 999) -- */
+
